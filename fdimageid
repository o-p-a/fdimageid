#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# フロッピーディスクイメージファイルの識別
#
# 2024/09/14 opa⁠🙂
#----------------------------------------------------------------

require "optparse"

ProgName = "fdimageid"
Version = "1.02"
#=====dpk===== Copyright2024
Copyright = "Copyright (c) 2024 by opa"
#=====dpk=====

class String
	def to_byte;	unpack1("C");	end
	def to_word;	unpack1("v");	end
	def to_dword;	unpack1("V");	end

	def to_bytes;	unpack("C*");	end
	def to_words;	unpack("v*");	end
	def to_dwords;	unpack("V*");	end
end

class Integer
	def to_hex;	"#{to_s(16)}h";	end
end

class DiskImage
	IMAGE_FORMATNAME = "Abstruct floppy disk image"
	IMAGE_EXTNAMES = []
	COMMON_GEOMETRIES = [
		# 0                     1      2      3    4     5     6     7
		# description           size   media  cyls heads nsecs ssize ssize1
		["2TD 9.12MB 88VA",  9338880, :"2td",  240,    2,   38,  512],
		["2ED 2.88MB",       2949120, :"2ed",   80,    2,   36,  512],
		["2HQ16 1.6MB",      1638400, :"2hd",   80,    2,   20,  512],
		["2HQ 1.44MB PC/AT", 1474560, :"2hd",   80,    2,   18,  512],
		["2HS/2HDE 1.44MB",  1474560, :"2hd",   80,    2,    9, 1024],
		["2HD 1.23MB PC-98", 1261568, :"2hd",   77,    2,    8, 1024],
		["2HDA 1.28MB",      1310720, :"2hd",   80,    2,    8, 1024],
		["2HC 1.2MB PC/AT",  1228800, :"2hd",   80,    2,   15,  512],
		["2HD 1.00MB",       1025024, :"2hd",   77,    2,   26,  256],
		["2HD 1.04MB",       1064960, :"2hd",   80,    2,   26,  256],
		["2HD DISK BASIC",   1021696, :"2hd",   77,    2,   26,  256,  128],
		["2DD 800KB",         819200, :"2dd",   80,    2,   10,  512],
		["2DD 720KB MSX",     737280, :"2dd",   80,    2,    9,  512],
		["2DD 640KB",         655360, :"2dd",   80,    2,    8,  512],
		["2DD DISK BASIC",    655360, :"2dd",   80,    2,   16,  256],
		["2D 360KB",          368640, :"2d",    40,    2,    9,  512],
		["1DD 360KB",         368640, :"1dd",   80,    1,   18,  256],
		["2D 320KB",          327680, :"2d",    40,    2,   16,  256],
		["1DD 320KB",         327680, :"1dd",   80,    1,   16,  256],
		["1D 180KB",          184320, :"1d",    40,    1,   18,  256],
		["1D 160KB",          163840, :"1d",    40,    1,   16,  256],
		["1D 140KB",          143360, :"1d",    35,    1,   16,  256],
	]

	def COMMON_GEOMETRIES.find_desc(desc)
		return find{ |g| g[0] == desc }
	end

	attr_accessor(:track, :mediatype, :writeprotect, :comment)

	def self.image_formsts
		return [
			DIM, NFD_r0, NFD_r1, SLF, V98FDD, ERCVFD, MAHALITO, HFE, SCP, DIP, D88, FDI, DCU, XDF,
		]
	end

	def self.image_formatname
		return self::IMAGE_FORMATNAME
	end

	def self.image_extnames
		return self::IMAGE_EXTNAMES
	end

	def self.image_extnames_s
		return "[#{image_extnames.join(" ")}]"
	end

	def self.guess_image_format(filename:nil, data:nil)
		data = IO.binread(filename)  if filename
		return image_formsts.find{ |c| c.image?(data) }
	end

	def self.mediatype_s(mediatype)
		case mediatype
		when nil, :"1d", :"1dd", :"2d", :"2dd", :"2hd", :"2ed", :"2td"
			return mediatype.to_s.upcase
		when :unknown
			return "不明"
		else
			return "不正な値(#{mediatype})"
		end
	end

	def initialize(filename:nil, data:nil)
		clear
		data = IO.binread(filename)  if filename
		load(data)  if data
	end

	def clear
		@track = []
		@mediatype = nil # :"1d", :"1dd", :"2d", :"2dd", :"2hd", :"2ed", :"2td", :unknown
		@writeprotect = nil # true:Write Protected false:Writeable
		@comment = nil
		return self
	end

	def to_h
		return {
			track: @track.map{ |t| t.to_h },
			mediatype: @mediatype,
			writeprotect: @writeprotect,
			comment: @comment,
		}
	end

	class Track
		attr_accessor(:sector)

		def initialize
			clear
		end

		def clear
			@sector = []
			return self
		end

		def copy(another)
			@sector = another.sector.map{ |s| Sector.new.copy(s) }
			return self
		end

		def to_h
			return {
				sector: @sector.map{ |r| r.to_h },
			}
		end

		# 空か?
		def empty?
			return @sector.empty?
		end

		# トラックに含まれるセクタ数
		def nsectors
			return @sector.length
		end

		# C(シリンダ)番号 不統一の場合は :mix
		def c
			return nil  if empty?
			val = @sector.first.c
			return @sector.all?{ |s| s.c == val } ? val : :mix
		end

		# H(ヘッド)番号 不統一の場合は :mix
		def h
			return nil  if empty?
			val = @sector.first.h
			return @sector.all?{ |s| s.h == val } ? val : :mix
		end

		# R(レコード)番号の配列
		def r
			return @sector.map{ |s| s.r }
		end

		# N(セクタ長) 不統一の場合は :mix
		def n
			return nil  if empty?
			val = @sector.first.n
			return @sector.all?{ |s| s.n == val } ? val : :mix
		end

		# 実際のセクタ長 不統一の場合は :mix
		def ssize
			return nil  if empty?
			val = @sector.first.ssize
			return @sector.all?{ |s| s.ssize == val } ? val : :mix
		end

		# 総データサイズ
		def total_size
			return @sector.sum{ |s| s.ssize }
		end

		# セクタのデータ(をCHR順に連結したもの)
		def data
			all_sectors = @sector.sort_by{ |s| [s.c, s.h, s.r] }
			return all_sectors.map{ |s| s.data }.join
		end

		# 全バイトが同一値であるか
		def is_uniform?(test_value=nil)
			return nil  if @sector.empty?
			test_value ||= @sector.first.data[0]
			return @sector.all?{ |s| s.is_uniform?(test_value) }
		end
	end

	class Sector
		attr_accessor(:data, :c, :h, :r, :n, :mfm, :ddam, :status, :st0, :st1, :st2, :pda)

		def initialize
			clear
		end

		def clear
			@data = ""
			@c = nil
			@h = nil
			@r = nil
			@n = nil
			@mfm = nil		# false:FM(S) true:MFM(D,H)
			@ddam = nil		# false:DAM true:DDAM
			@status = nil	# BIOS Read Data Status 0:Normal Terminate
			@st0 = nil		# ST0
			@st1 = nil		# ST1
			@st2 = nil		# ST2
			@pda = nil		# PDA 0x90:1.2M 0x30:1.44M 0x10:640K
			return self
		end

		def copy(another)
			@data = another.data.dup
			@c = another.c
			@h = another.h
			@r = another.r
			@n = another.n
			@mfm = another.mfm
			@ddam = another.ddam
			@status = another.status
			@st0 = another.st0
			@st1 = another.st1
			@st2 = another.st2
			@pda = another.pda
			return self
		end

		def to_h
			return {
				data: @data,
				c: @c,
				h: @h,
				r: @r,
				n: @n,
				mfm: @mfm,
				ddam: @ddam,
				status: @status,
				st0: @st0,
				st1: @st1,
				st2: @st2,
				pda: @pda,
			}
		end

		# セクタ長
		def ssize
			return @data.length
		end

		# 全バイトが同一値であるか
		def is_uniform?(test_value=nil)
			return nil  if @data.empty?
			test_value ||= @data[0]
			return @data == test_value * ssize
		end
	end

	def mediatype_s(mediatype=@mediatype)
		return self.class.mediatype_s(mediatype)
	end

	# 空か?
	def empty?
		return @mediatype.nil? && @writeprotect.nil? && @comment.nil? && @track.empty?
	end

	# メディアタイプを推測
	def guess_mediatype
		return nil  if @track.empty?

		if heads == 2
			if cyls > 100
				return :"2td"
			elsif cyls > 45
				track_length = nsectors_approx * ssize_approx
				if track_length > 10240
					return :"2ed"
				elsif track_length > 6250
					return :"2hd"
				else
					return :"2dd"
				end
			else
				return :"2d"
			end
		else
			if cyls > 45
				return :"1dd"
			else
				return :"1d"
			end
		end
	end

	# データのある最終トラック番号
	def ntracks
		return @track.length
	end

	# データのあるトラック数
	def xtracks
		return @track.count{ |t| !t.empty? }
	end

	# シリンダ数 (Cの最大値+1)
	def cyls
		max = sector.map{ |s| s.c }.max
		return max ? (max + 1) : nil
	end

	# ヘッド数 (Hの最大値+1)
	def heads
		max = sector.map{ |s| s.h }.max
		return max ? (max + 1) : nil
	end

	# 1トラックのセクタ数 不統一の場合は :mix
	def nsectors
		return nil  if @track.empty?
		val = @track.first.nsectors
		return @track.all?{ |t| t.nsectors == val } ? val : :mix
	end

	# 1トラックのセクタ数 不統一の場合、最多数の値
	def nsectors_approx
		return nil  if @track.empty?
		count = {}
		@track.each do |trk|
			val = trk.nsectors
			count[val] = (count[val] || 0) + 1
		end
		return count.to_a.sort_by{ |c| c[1] }.last[0]
	end

	# 1セクタのセクタ長 不統一の場合は :mix
	def ssize
		return nil  if (secs = sector).empty?
		val = secs.first.ssize
		return secs.all?{ |t| t.ssize == val } ? val : :mix
	end

	# 1トラックのセクタ数 不統一の場合、最多数の値
	def ssize_approx
		return nil  if (secs = sector).empty?
		count = {}
		secs.each do |s|
			val = s.ssize
			count[val] = (count[val] || 0) + 1
		end
		return count.to_a.sort_by{ |c| c[1] }.last[0]
	end

	# 全トラックのセクタの一次元配列
	def sector
		return @track.sum([]){ |t| t.sector }
	end

	# 全セクタ数
	def total_sectors
		return @track.sum{ |t| t.nsectors }
	end

	# 総データサイズ
	def total_size
		return @track.sum{ |t| t.total_size }
	end

	# セクタのデータ(をトラック順>CHR順に連結したもの)
	def data
		return @track.sum(""){ |t| t.data }
	end

	# (内部用)@track内のnil要素をは空のTrackで埋める
	def sweep_niltrack
		@track.map!{ |t| t || Track.new }
	end
	protected(:sweep_niltrack)

	# (内部用)ファイルサイズチェック
	def excess_data_check(expect, actual)
		excess = expect - actual
		if excess > 0
			$stdout.print("  末尾に不要なデータがあります(#{excess}バイト余剰)\n")
		elsif excess < 0
			$stdout.print("  読み込み中に末尾に達しました(#{-excess}バイト不足)\n")
		end
	end
	protected(:excess_data_check)

	# イメージファイルのデータをselfにロード
	def load(filedata)
		$stderr.print("#{ProgName}: #{self.class.name}.load not implemented\n")
		clear
	end

	# selfをイメージファイルのデータにシリアライズして返却
	def dump
		$stderr.print("#{ProgName}: #{self.class.name}.dump not implemented\n")
		return nil
	end

	# 他のDiskImageインスタンスのデータをselfにロード
	def copy(another)
		clear

		@mediatype = another.mediatype
		@track = another.track.map{ |t| Track.new.copy(t) }
		@writeprotect = another.writeprotect
		@comment = another.comment
		return self
	end

	# 一般的なフォーマットかどうか (厳密チェック)
	def common_geometry?
		COMMON_GEOMETRIES.each do |g|
			g_size, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = g[1 .. 7]

			if total_size == g_size && (mediatype.nil? || mediatype == g_media) && cyls == g_cyls && heads == g_heads && nsectors == g_nsecs
				return g  if g_ssize1 ? (ssize_approx == g_ssize && track[0].ssize == g_ssize1) : (ssize == g_ssize)
			end
		end

		return nil # ≒ false
	end

	# 一般的なフォーマットでいうと何が近いか (曖昧チェック)
	def common_geometry_approx?
		return nil  if @track.empty?

		r = common_geometry? # 厳密チェックで一致する分にはそれを返す
		return r  if r

		# セクタ数、セクタ長について代表値を使ってのチェック
		COMMON_GEOMETRIES.each.with_index do |g, i|
			g_size, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = g[1 .. 7]
			wk_media = @mediatype || g_media

			if total_size == g_size && wk_media == g_media && cyls == g_cyls && heads == g_heads && nsectors_approx == g_nsecs
				return g  if g_ssize1 ? (ssize_approx == g_ssize && track[0].ssize == g_ssize1) : (ssize_approx == g_ssize)
			end
		end

		# 総データサイズとシリンダ数も曖昧検索
		COMMON_GEOMETRIES.each.with_index do |g, i|
			g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = g[2 .. 7]
			wk_media = @mediatype || g_media
			cyls_ok = ((cyls <= 45 && g_cyls <= 45) || (cyls > 45 && g_cyls > 45)) ? true : false

			if wk_media == g_media && cyls_ok && heads == g_heads && nsectors_approx == g_nsecs
				return g  if g_ssize1 ? (ssize_approx == g_ssize && track[0].ssize == g_ssize1) : (ssize_approx == g_ssize)
			end
		end

		return nil # ≒ false
	end

	# 情報を表示
	def report_all
		if empty?
			$stdout.print("  データがありません(初期状態)\n")
			return
		end

		if @comment && !@comment.empty?
			$stdout.print("  コメント: #{@comment.inspect}\n")
		end

		if @mediatype
			$stdout.print("  メディア種別: #{mediatype_s}\n")
		end

		if !@writeprotect.nil?
			if @writeprotect
				$stdout.print("  ライトプロテクト: 書き込み禁止\n")
			else
				$stdout.print("  ライトプロテクト: 書き込み可\n")
			end
		end

		# セクタ情報の統計を算出
		skip_factor = nil
		mfm_count = {}
		ddam_count = 0
		status_count = {}
		st0_count = {}
		st1_count = {}
		st2_count = {}
		pda_count = {}
		wk_heads = heads
		@track.each.with_index do |trk, trkno|
			r_count = []
			trk.sector.each.with_index do |s, sec|
				if s.c > 90
					$stdout.print("  トラック#{trkno+1}のセクタのCの値が異常です: #{s.c}\n")
				end

				if s.c != trkno / wk_heads
					$stdout.print("  トラック#{trkno+1}のセクタのCの値が特殊です: C:#{s.c} (!=#{trkno / 2})\n")
				end

				if s.h >= wk_heads
					$stdout.print("  トラック#{trkno+1}のセクタのHの値が異常です: #{s.h}\n")
				end

				if s.h != trkno % wk_heads
					$stdout.print("  トラック#{trkno+1}のセクタのHの値が特殊です: H:#{s.h} (!=#{trkno % 2})\n")
				end

				if s.r < 1 || s.r > 32
					$stdout.print("  トラック#{trkno+1}のセクタのRの値が異常です: #{s.r}\n")
				end

				if !skip_factor && s.r == 2
					skip_factor = sec - 1
				end

				r_count[s.r] = (r_count[s.r] || 0) + 1

				if s.n > 6
					$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
				end

				ssize_n = 128 << s.n.clamp(0, 6) # Nから求まるセクタサイズ
				if ssize_n != s.ssize
					$stdout.print("  トラック#{trkno+1}のセクタのNの値と実際のサイズが異なります: N:#{ssize_n} != #{s.ssize}\n")
				end

				if !s.mfm.nil?
					mfm_count[s.mfm] = (mfm_count[s.mfm] || 0) + 1
				end

				if s.ddam == true # DDAMはtrueの数を数えるだけ
					ddam_count += 1
				end

				if s.status && s.status != 0
					status_count[s.status] = (status_count[s.status] || 0) + 1
				end

				if s.st0
					st0 = s.st0 & 0xf8 # Head Address, Unit Select は無視
					if st0 != 0
						st0_count[st0] = (st0_count[st0] || 0) + 1
					end
				end

				if s.st1 && s.st1 != 0
					st1_count[s.st1] = (st1_count[s.st1] || 0) + 1
				end

				if s.st2 && s.st2 != 0
					st2_count[s.st2] = (st2_count[s.st2] || 0) + 1
				end

				if s.pda
					pda_count[s.pda] = (pda_count[s.pda] || 0) + 1
				end
			end

			# セクタ番号のヌケ・重複のチェック
			r_count.each.with_index do |count, sec|
				count ||= 0
				if sec == 0
					if count > 0
						$stdout.print("  トラック#{trkno+1}にR=#{sec}のセクタが#{count}個あります\n")
					end
				else
					if count < 1
						$stdout.print("  トラック#{trkno+1}にR=#{sec}のセクタがありません\n")
					elsif count > 1
						$stdout.print("  トラック#{trkno+1}にR=#{sec}のセクタが#{count}個あります\n")
					end
				end
			end
		end

		# 出現頻度順の配列にする
		status_major = status_count.to_a.sort_by{ |e| e[1] }.reverse
		st0_major = st0_count.to_a.sort_by{ |e| e[1] }.reverse
		st1_major = st1_count.to_a.sort_by{ |e| e[1] }.reverse
		st2_major = st2_count.to_a.sort_by{ |e| e[1] }.reverse
		pda_major = pda_count.to_a.sort_by{ |e| e[1] }.reverse

		# ジオメトリ算出
		if (wk_ssize_approx = ssize_approx)
			ssize_s = "#{wk_ssize_approx}バイト"
			ssize_s += "(混在あり)"  if ssize == :mix
		else
			ssize_s = "0バイト"
		end

		if (wk_nsectors_approx = nsectors_approx)
			nsecs_s = "#{wk_nsectors_approx}セクタ"
			nsecs_s += "(混在あり)"  if nsectors == :mix
		else
			nsecs_s = "セクタなし"
		end

		wk_ntracks = ntracks
		if wk_ntracks == xtracks
			ntracks_s = "#{wk_ntracks}トラック"
		else
			ntracks_s = "#{wk_ntracks}(#{xtracks})トラック"
		end

		wk_total_size = total_size
		if wk_total_size / 1024 >= 1000
			total_size_kb = "%.2fMB" % ((wk_total_size / 1024) / 1000.0)
		else
			total_size_kb = "%dKB" % (wk_total_size / 1024)
		end

		wk_cyls = cyls
		wk_heads = heads
		$stdout.print("  #{wk_cyls}シリンダ x #{wk_heads}ヘッド = #{ntracks_s}\n")
		$stdout.print("  #{wk_cyls}シリンダ x #{wk_heads}ヘッド x #{nsecs_s} = #{total_sectors}セクタ\n")
		$stdout.print("  #{wk_cyls}シリンダ x #{wk_heads}ヘッド x #{nsecs_s} x #{ssize_s} = #{wk_total_size}バイト(#{total_size_kb})\n")

		# 推定フォーマット
		guess_format = common_geometry_approx?
		if guess_format
			g_desc, g_size, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = guess_format

			$stdout.print("  推定フォーマット: #{g_desc}\n")

			if @mediatype && @mediatype != g_media
				$stdout.print("  メディア種別と実際のフォーマットが異なります\n")
			end

			if wk_cyls != g_cyls
				$stdout.print("  シリンダ数が通常と異なります: 標準は#{g_cyls}(#{g_cyls * g_heads}トラック)\n")
			end
		else
			$stdout.print("  推定フォーマット: 不明 一般的でないフォーマットがされています\n")
		end

		# 推定メディアタイプ
		if guess_mediatype
			$stdout.print("  推定メディアタイプ: #{mediatype_s(guess_mediatype)}\n")
		else
			$stdout.print("  推定メディアタイプ: 不明 一般的でないメディアのようです\n")
		end

		if skip_factor && skip_factor > 0
			$stdout.print("  インターリーブフォーマットされています(スキップファクタ=#{skip_factor})\n")
		end

		if mfm_count.length >= 2
			$stdout.print("  FM/MFM混在: FM:#{mfm_count[false]}セクタ MFM:#{mfm_count[true]}セクタ\n")
		end

		if ddam_count > 0
			$stdout.print("  Deleted Data Address Markの立ったセクタが#{ddam_count}個あります\n")
		end

		if !status_major.empty?
			status_major_s = "#{status_major[0][0].to_hex}が#{status_major[0][1]}個"
			status_major_s += " 他"  if status_major.length >= 2
			$stdout.print("  FDC Statusが0でないセクタがあります(#{status_major_s})\n")
		end

		st0_major.each do |val, count|
			$stdout.print("  ST0が#{val.to_hex}のセクタが#{count}個あります\n")
		end

		st1_major.each do |val, count|
			$stdout.print("  ST1が#{val.to_hex}のセクタが#{count}個あります\n")
		end

		st2_major.each do |val, count|
			$stdout.print("  ST2が#{val.to_hex}のセクタが#{count}個あります\n")
		end

		pda_major.each do |val, count|
			mediatype_unmatch = false
			case val
			when 0x90
				val_s = "2HD 1.2MB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2hd"
			when 0x30
				val_s = "2HD 1.44MB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2hd"
			when 0x10
				val_s = "2DD 640KB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2dd"
			else
				val_s = "不明"
			end
			if mediatype_unmatch
				$stdout.print("  PDAが#{val.to_hex}: #{val_s}(メディア種別と不整合)のセクタが#{count}個あります#{mediatype_unmatch_s}\n")
			end
		end

		trkno = 1
		uniform_map = @track.map do |t|
			(t.is_uniform?) ? t.sector.first.data[0] : false
		end
		uniform_map.chunk{ |d| d }.each do |cval, cdata|
			ctracks = cdata.length

			if cval
				if ctracks == 1
					$stdout.print("  トラック#{trkno}は全て#{cval.ord.to_hex}です\n")
				else
					$stdout.print("  トラック#{trkno}～#{trkno+ctracks-1}は全て#{cval.ord.to_hex}です\n")
				end
			end

			trkno += ctracks
		end
	end
end

# DIFC.X ヘッダ(256バイト)+べたデータ https://stdkmd.net/xeij/source/FDMedia.htm https://www.pc98.org/project/doc/dim.html
class DIM < DiskImage
	IMAGE_FORMATNAME = "X68000 DIFC.X DIM形式"
	IMAGE_EXTNAMES = [".dim"]
	HEADER_SIZE = 0x100
	GEOMETRIES = {
		0x00 => COMMON_GEOMETRIES.find_desc("2HD 1.23MB PC-98"),
		0x01 => COMMON_GEOMETRIES.find_desc("2HS/2HDE 1.44MB"), # 2HS
		0x02 => COMMON_GEOMETRIES.find_desc("2HC 1.2MB PC/AT"),
		0x03 => COMMON_GEOMETRIES.find_desc("2HS/2HDE 1.44MB"), # 2HDE
		0x09 => COMMON_GEOMETRIES.find_desc("2HQ 1.44MB PC/AT"),
		0x11 => COMMON_GEOMETRIES.find_desc("2HD DISK BASIC"),
	}

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[171, 15] == "DIFC HEADER  \0\0" &&
			GEOMETRIES[filedata[0].to_byte]
	end

	def load(filedata)
		clear

		# DIFC.Xバージョン
		difc_version = filedata[0xfe].to_byte
		difc_version_s = "1.%02x" % difc_version
		$stdout.print("  DIFC.xバージョン: #{difc_version_s}\n")

		# メディアタイプ
		geom = GEOMETRIES[filedata[0].to_byte] # media byte
		@mediatype, cyls, heads, nsecs, ssize, ssize1 = geom[2 .. 7]

		# イメージ作成時刻
		create_time = filedata[0xba, 8]
		if create_time != "\0" * 8
			create_time = create_time.unpack("CH2H2H2CH2H2H2").map{ |e| e.to_i }
			create_time[0] = "日月火水木金土"[create_time[0]]
			create_time[1] = 1980 + create_time[1]
			$stdout.print("  イメージ作成時刻: " +
				"#{create_time[1]}/#{"%02d" % create_time[2]}/#{"%02d" % create_time[3]}(#{create_time[0]}) " +
				"#{create_time[5]}:#{"%02d" % create_time[6]}:#{"%02d" % create_time[7]}(#{(create_time[4]==0) ? "12" : "24"}時間計)\n")
		end

		# コメント
		@comment = filedata[0xc2, 60].force_encoding(Encoding::WINDOWS_31J).encode.sub(/\0+$/, "")

		# トラック数
		header_ntracks = filedata[0xff].to_byte
		$stdout.print("  ヘッダのトラック数: #{header_ntracks}トラック\n")  if header_ntracks > 0

		# データ本体
		offset = HEADER_SIZE
		track_flag = filedata[1, 170].to_bytes
		track_flag.each.with_index do |flag, trkno|
			case flag
			when 0 # なし
				# NOP
			when 1 # あり
				cyl = trkno / heads
				head = trkno % heads
				trk_ssize = (ssize1 && trkno == 0) ? ssize1 : ssize # 最初のトラックだけセクタ長が異なる場合
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (trk_ssize / 128).bit_length - 1
					s.data = filedata[offset, trk_ssize] || ""
					offset += trk_ssize
					trk.sector << s
				end
			else
				$stdout.print("  トラック#{trkno+1}のデータ有無フラグが不正: #{flag}\n")
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end
end

# T98Next r0 ヘッダ(68112バイト)+べたデータ https://www.pc98.org/project/doc/nfdr0.txt
class NFD_r0 < DiskImage
	IMAGE_FORMATNAME = "T98-Next NFD r0形式"
	IMAGE_EXTNAMES = [".nfd"]
	HEADER_SIZE = 0x10a10

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 15] == "T98FDDIMAGE.R0\0"
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0x100].force_encoding(Encoding::WINDOWS_31J).encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		known_headsize = 0x10 + 0x100 + 0x10 + 163*26*0x10 + 0x10
		if dwHeadSize != known_headsize
			$stdout.print("  ヘッダ部のヘッダサイズが不正: #{dwHeadSize.to_hex} != #{known_headsize.to_hex}\n")
		end
		@writeprotect = (filedata[0x10 + 0x100 + 4].to_byte != 0) ? true : false
		byHead = filedata[0x10 + 0x100 + 5].to_byte
		$stdout.print("  ヘッダ部のヘッド数: #{byHead}\n")

		id_offset = 0x120
		data_offset = dwHeadSize
		(0 ... 163).each do |trkno|
			(0 ... 26).each do |sec|
				s = Sector.new
				s.c, s.h, s.r, s.n, s.mfm, s.ddam, s.status, s.st0, s.st1, s.st2, s.pda =
					filedata[id_offset, 11].unpack("C11")
				id_offset += 0x10

				next  if s.c == 0xff

				if s.n > 6
					$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
					next # 致命的なのでこのセクタはスキップ
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのflMFMの値が不正: #{s.mfm}\n")
					s.mfm = nil
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのflDDAMの値が不正: #{s.ddam}\n")
					s.ddam = nil
				end

				ssize = 128 << s.n
				s.data = filedata[data_offset, ssize] || ""
				data_offset += ssize

				trk = (@track[trkno] ||= Track.new)
				trk.sector << s
			end
		end
		excess_data_check(filedata.length, data_offset)
		sweep_niltrack

		if byHead != heads
			$stdout.print("  ヘッダ部のヘッド数と実際に使われているヘッド数が一致しません\n")
		end
	end
end

# T98Next r1 ヘッダ(全体(960バイト)+セクタ+特殊読み込み)+データ https://www.pc98.org/project/doc/nfdr1.txt
class NFD_r1 < DiskImage
	IMAGE_FORMATNAME = "T98-Next NFD r1形式"
	IMAGE_EXTNAMES = [".nfd"]
	HEADER_SIZE = 0x3c0

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 15] == "T98FDDIMAGE.R1\0"
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0x100].force_encoding(Encoding::WINDOWS_31J).encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		@writeprotect = (filedata[0x10 + 0x100 + 4].to_byte != 0) ? true : false
		byHead = filedata[0x10 + 0x100 + 5].to_byte
		dwTrackHead = filedata[0x10 + 0x100 + 0x10, 4 * 164].to_dwords
		dwAddInfo = filedata[0x10 + 0x100 + 0x10 + 4 * 164, 4].to_dword

		$stdout.print("  ヘッダ部のヘッド数: #{byHead}\n")
		$stdout.print("  追加情報ヘッダのアドレスが0以外です: #{dwAddInfo.to_hex}\n")  if dwAddInfo != 0

		data_offset = dwHeadSize
		sp_read_count = {}
		dwTrackHead.each.with_index do |track_offset, trkno|
			next  if track_offset == 0

			nsecs, wDiag = filedata[track_offset, 2 * 2].to_words
			track_offset += 0x10

			trk = (@track[trkno] ||= Track.new)
			(0 ... nsecs).each do |sec|
				s = Sector.new
				s.c, s.h, s.r, s.n, s.mfm, s.ddam, s.status, s.st0, s.st1, s.st2, byRetry, s.pda =
					filedata[track_offset, 12].unpack("C12")
				track_offset += 0x10

				if s.n > 6
					$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
					next # 致命的なのでこのセクタはスキップ
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのflMFMの値が不正: #{s.mfm}\n")
					s.mfm = nil
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのflDDAMの値が不正: #{s.ddam}\n")
					s.ddam = nil
				end

				ssize = 128 << s.n
				if byRetry == 0
					s.data = filedata[data_offset, ssize] || ""
					data_offset += ssize
				else
					$stdout.print("  トラック#{trkno+1}にリトライデータが存在します: 1+#{byRetry}回\n")
					s.data = []
					(0 .. byRetry).each do
						s.data << (filedata[data_offset, ssize] || "")
						data_offset += ssize
					end
				end

				trk.sector << s
			end

			# 特殊読み込みデータ
			(0 ... wDiag).each do
				d_cmd, d_c, d_h, d_r, d_n, d_byStatus, d_bySTS0, d_bySTS1, d_bySTS2, d_byRetry, d_dwDataLen, d_byPDA =
					filedata[track_offset, 15].unpack("C10VC")
				track_offset += 0x10
				data_offset += d_dwDataLen
				sp_read_count[d_cmd] = (sp_read_count[d_cmd] || 0) + 1
			end
		end
		excess_data_check(filedata.length, data_offset)
		sweep_niltrack

		if byHead != heads
			$stdout.print("  ヘッダ部のヘッド数と実際に使われているヘッド数が一致しません\n")
		end

		sp_read_count = sp_read_count.to_a.sort_by{ |e| e[1] }.reverse
		sp_read_count.each do |cmd, count|
			case cmd
			when 0x0
				cmd_s = "Seek"
			when 0x1
				cmd_s = "Verify"
			when 0x2
				cmd_s = "Read Diagnostic"
			when 0x3
				cmd_s = "Initialize"
			when 0x4
				cmd_s = "Sense"
			when 0x5
				cmd_s = "Write Data"
			when 0x6
				cmd_s = "Read Data"
			when 0x7
				cmd_s = "Recalibrate"
			when 0x9
				cmd_s = "Write Deleted Data"
			when 0xa
				cmd_s = "Read ID"
			when 0xc
				cmd_s = "Read Deleted Data"
			when 0xd
				cmd_s = "Format Track"
			when 0xe
				cmd_s = "Set Operation Mode"
			else
				cmd_s = "不明なコマンド"
			end

			$stdout.print("  特殊読み込みデータが存在します: #{cmd_s}: #{count}個\n")
		end
	end
end

# SL9821 フォーマットヘッダ(16バイト)+トラックヘッダ(32*80*2=5120バイト)+データ https://www.satotomi.com/pifdc/pifdc_slf.html https://www.satotomi.com/sl9821/sl9821.html
class SLF < DiskImage
	IMAGE_FORMATNAME = "SL9821 SLF形式"
	IMAGE_EXTNAMES = [".slf"]
	HEADER_SIZE = 16 + 32 * 80 * 2

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 4] == "FDIM" &&
			filedata[4, 4].to_dword == 0x10000 &&
			filedata[8, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		version, filesize, flag = filedata[4, 12].to_dwords
		$stdout.print("  SLFバージョン: #{version.to_hex}\n")

		if filesize != filedata.length
			$stdout.print("  ヘッダのファイルサイズと実際のサイズが異なります: #{filesize} (!=#{filedata.length})\n")
		end

		if flag != 0
			$stdout.print("  フラグが設定されています: #{flag.to_hex}\n")
		end

		cyls, heads = 80, 2
		(0 ... cyls * heads).each do |trkno|
			tdata_offset, tdata_size, unformat_size, data_type, nsecs, gap4a_size, sync_size, gap1_size =
				filedata[0x10 + 0x20 * trkno, 28].unpack("V3v2V3")

			case data_type
			when 0xffff # -1:未フォーマット
				# NOP
			when 0 # 物理フォーマットデータ
				$stdout.print("  物理フォーマットのトラックデータには対応していません: #{trkno+1}トラック\n")
			when 1, 2 # 1:FM/2:MFMフォーマットデータ
				sheader_offset = tdata_offset
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					sdata_offset, status, isync_size, gap2_size, dsync_size, gap3_size,
						id_crc, data_crc, idam_pattern, s.c, s.h, s.r, s.n, dataam_pattern =
						filedata[sheader_offset, 32].unpack("V2v6VC4V")
					sheader_offset += 0x20

					if s.n > 6
						$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
						next # 致命的なのでこのセクタはスキップ
					end

					sdata_offset = tdata_offset + sdata_offset
					ssize = 128 << s.n
					s.mfm = (data_type == 2) ? true : false
					s.data = filedata[sdata_offset, ssize] || ""
					trk.sector << s

					chrn_s = "[#{s.c}/#{s.h}/#{s.r}/#{s.n}]"
					if (status & 0x1) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: IDAMパターンエラー\n")
					end
					if (status & 0x2) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: ID CRCエラー\n")
					end
					if (status & 0x4) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: DATAAMパターンエラー\n")
					end
					if (status & 0x8) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: DATA CRCエラー\n")
					end
					if (status & 0x10) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: セクタ構造のエラー\n")
					end
					if (status & 0x100) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: Deletedセクタ\n")
					end
					if (status & 0x200) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: 入れ子セクタ\n")
					end
					if (status | 0x31f) != 0x31f # 上記以外のビットが立っていたら
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: 不明な値(#{status.to_hex})\n")
					end
				end
			end
		end
		sweep_niltrack
	end
end

# Virtual98 固定長ヘッダ(50172バイト)+可変長データ https://www.pc98.org/project/doc/fdd.html
class V98FDD < DiskImage
	IMAGE_FORMATNAME = "Virtual98 FDD形式"
	IMAGE_EXTNAMES = [".fdd"]
	HEADER_SIZE = 0xc3fc

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 7] == "VFD1.00"
	end

	def load(filedata)
		clear

		@comment = filedata[0x8, 0x80].force_encoding(Encoding::WINDOWS_31J).encode.sub(/\0+$/, "")
		@writeprotect = (filedata[0x88, 2].to_word != 0) ? true : false
		special_read_drive = filedata[0x8a, 2].to_word

		cyls, heads = 80, 2
		offset = 0xdc
		(0 ... cyls * heads).each do |trkno|
			(0 ... 26).each do
				s = Sector.new
				s.c, s.h, s.r, s.n, fill_byte, s.ddam, s.mfm, hd, sector_offset =
					filedata[offset, 12].unpack("C4aC3V")
				offset += 12

				next  if s.c == 0xff

				if s.n > 6
					$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
					next # 致命的なのでこのセクタはスキップ
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのDDAMの値が不正: #{s.ddam}\n")
					s.ddam = nil
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのMFの値が不正: #{s.mfm}\n")
					s.mfm = nil
				end

				case hd
				when 0
					@mediatype ||= :"2dd"
					if @mediatype != :"2dd"
						$stdout.print("  トラック#{trkno+1}で2HDフラグの混在があります\n")
					end
				when 1
					@mediatype ||= :"2hd"
					if @mediatype != :"2hd"
						$stdout.print("  トラック#{trkno+1}で2HDフラグの混在があります\n")
					end
				else
					$stdout.print("  トラック#{trkno+1}に2HDフラグが0または1でないセクタがあります: #{hd}\n")
				end

				ssize = 128 << s.n
				s.data = (sector_offset == 0xffffffff) ? fill_byte * ssize : filedata[sector_offset, ssize]

				trk = (@track[trkno] ||= Track.new)
				trk.sector << s
			end
		end
		sweep_niltrack

		if special_read_drive != 0xffff
			$stdout.print("  特殊読み込みドライブ設定があります: #{special_read_drive.to_hex}\n")

			next_point = special_read_drive # 0xc3dc
			begin
				trkno, in_ax, in_bx, in_cx, in_dx, out_ax, out_bx, out_cx, out_dx, out_flag, data_point, next_point, count, neg_count =
					filedata[next_point, 32].unpack("v10V2v2")
			end while(next_point != 0xffffffff && next_point != 0)
		end
	end
end

# ERCVFD ヘッダ(64バイト)+セクタ毎に(ヘッダ(10バイト)+データ)
class ERCVFD < DiskImage
	IMAGE_FORMATNAME = "ERCACHE ERCVFD形式"
	IMAGE_EXTNAMES = [".vfd"]
	HEADER_SIZE = 0x40

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 8] == "ERCVFD01"
	end
end

# MAHALITO形式 フォーマットデータファイル + セクタデータファイル https://www.vector.co.jp/soft/dos/util/se000604.html
class MAHALITO < DiskImage
	IMAGE_FORMATNAME = "MAHALITO形式"
	IMAGE_EXTNAMES = [".dat", ".2hd", ".2dd", ".2d"]
	HEADER_SIZE = 11

	def self.image?(filedata)
		# Chek .2hd .2dd .2d file
		return false  if filedata.length < HEADER_SIZE

		id = filedata[0, 10]
		return (id == "ver 1.10  ") || (id == "2DD ver1.0") || (id == "2D  ver1.0")
	end
end

# HxC Floppy Emulator HFE形式 https://hxc2001.com/floppy_drive_emulator/HFE-file-format.html
class HFE < DiskImage
	IMAGE_FORMATNAME = "HxC Floppy Emulator HFE形式"
	IMAGE_EXTNAMES = [".hfe"]
	HEADER_SIZE = 512

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		id = filedata[0, 8]
		return id == "HXCPICFE" || id == "HXCHFEV3"
	end
end

# SuperCard Pro Flux Disk Image SCP形式 https://www.cbmstuff.com/downloads/scp/scp_image_specs.txt https://github.com/keirf/disk-utilities/tree/master/scp
class SCP < DiskImage
	IMAGE_FORMATNAME = "SuperCard Pro Flux Disk Image SCP形式"
	IMAGE_EXTNAMES = [".scp"]
	HEADER_SIZE = 688

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 3] == "SCP"
	end
end

# DIP ヘッダ(256バイト)+べたデータ(1261568バイト) https://www.pc98.org/project/doc/dip.html
class DIP < DiskImage
	IMAGE_FORMATNAME = "DIP形式"
	IMAGE_EXTNAMES = [".dip"]
	HEADER_SIZE = 256
	MAGICWORD = "\x01\x08\x00\x13\x41\x00\x01\x00"

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 8] == MAGICWORD &&
			filedata.length == HEADER_SIZE + (77 * 2 * 8 * 1024)
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0xf0].force_encoding(Encoding::WINDOWS_31J).encode.sub(/\0+$/, "")

		cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		offset = HEADER_SIZE
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		sweep_niltrack
	end

	def dump
		if total_size != 77 * 2 * 8 * 1024
			$stdout.print("  DIP形式は2HD 1.23MB専用です\n")
			return nil
		end

		header = [
			MAGICWORD,
			@comment.encode(Encoding::WINDOWS_31J),
		].pack("a16a240")

		return header + data
	end
end

# D88 ディスクヘッダ+セクタ毎にヘッダ+データ https://github.com/waitingmoon/quasi88/blob/develop/document/FORMAT.TXT https://www.pc98.org/project/doc/d88.html
class D88 < DiskImage
	IMAGE_FORMATNAME = "D88形式"
	IMAGE_EXTNAMES = [".d88", ".d98", ".d77", ".d68", ".88d", ".98d", ".77d", ".68d"]
	HEADER_SIZE = 0x2a0 # or 0x2b0
	MEDIA = {
		0x00 => :"2d",
		0x10 => :"2dd",
		0x20 => :"2hd",
		0x21 => :"2hd", # 2HD 1.44MB NP2kai
		0x30 => :"1d",
		0x40 => :"1dd",
	}

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0x10, 10] == "\0" * 10 &&
			MEDIA[filedata[0x1b].to_byte] &&
			filedata[0x1c, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		# Media flag
		media_flag = filedata[0x1b].to_byte
		if MEDIA[media_flag]
			if media_flag == 0x21
				$stdout.print("  ヘッダのメディアタイプ: 2HD 1.44MB NP2kai拡張\n")
			end
			@mediatype = MEDIA[media_flag]
		else
			$stdout.print("  ヘッダのメディアタイプ不明: #{media_flag.to_hex}\n")
			@mediatype = :unknown
		end

		# Write protect flag
		@writeprotect = (filedata[0x1a].to_byte == 0) ? false : true

		# Disk name / comment
		@comment = filedata[0, 16].force_encoding(Encoding::WINDOWS_31J).encode.sub(/\0+$/, "")

		# Track data
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find{ |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4 # 0x2b0(688byte:164entry) or 0x2a0(672byte:160entry)
		track_offsets = track_offsets.first(header_tracks)

		rpm_count = [0, 0]
		track_offsets.each.with_index do |offset, trkno|
			if offset != 0
				trk = (@track[trkno] ||= Track.new)
				track_nsectors = nil
				begin
					s = Sector.new
					s.c, s.h, s.r, s.n, nsecs, s.mfm, s.ddam, s.status, rpm, datasize =
						filedata[offset, 16].unpack("C4vC3x4Cv")
					offset += 0x10

					if s.n > 6
						$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
						break # 致命的なのでこのトラックはスキップ
					end

					if !track_nsectors
						track_nsectors = nsecs
					elsif track_nsectors != nsecs
						$stdout.print("  トラック#{trkno+1}の総セクタ数が統一されていません: #{nsecs} (!=#{track_nsectors})\n")
					end

					case s.mfm
					when 0x00 # double density
						s.mfm = true
					when 0x40 # single density
						s.mfm = false
					else
						$stdout.print("  トラック#{trkno+1}のDensity flag不正: #{s.mfm.to_hex}\n")
						s.mfm = nil
					end

					case s.ddam
					when 0x00 # normal
						s.ddam = false
					when 0x10 #deleted
						s.ddam = true
					else
						$stdout.print("  トラック#{trkno+1}のDDAM flag不正: #{s.ddam.to_hex}\n")
						s.ddam = nil
					end

					if rpm == 0 || rpm == 1
						rpm_count[rpm] += 1
					else
						$stdout.print("  トラック#{trkno+1}のNP2kai RPM不正: #{rpm}\n")
					end

					ssize = 128 << s.n
					if ssize != datasize
						$stdout.print("  トラック#{trkno+1}のセクタのNの値とデータサイズが異なります: N:#{datasize} (!=#{ssize})\n")
					end

					s.data = filedata[offset, ssize] || ""
					offset += ssize

					trk.sector << s
				end while trk.nsectors < nsecs

				next_track_start = (track_offsets[(trkno + 1) .. -1].find{ |o| o != 0 }) || filedata.length
				if offset != next_track_start
					if offset < next_track_start
						$stdout.print("  トラック#{trkno+1}のデータの後に不要なデータがあります\n")
					else
						$stdout.print("  トラック#{trkno+1}のデータが次のトラックに達しています\n")
					end
				end
			end
		end
		sweep_niltrack

		if media_flag == 0x21
			if rpm_count[0] > 0
				$stdout.print("  ディスクヘッダ上は2HD 1.44MBですが、#{rpm_count[0]}個のセクタのRPMが0です\n")
			end
		else
			if rpm_count[1] > 0
				$stdout.print("  #{rpm_count[1]}個のセクタのRPMが1です\n")
			end
		end
	end

	def dump
		max_tracks = 164 # 164 (or 160)
		np2kai_ext = true

		case @mediatype || guess_mediatype
		when :"2d"
			disk_type = 0x00 # 2D
		when :"2dd"
			disk_type = 0x10 # 2DD
		when :"2hd", :"2ed", :"2td"
			if np2kai_ext && nsectors_approx * ssize_approx > 8704
				disk_type = 0x21 # 2HD 1.44MB NP2kai
			else
				disk_type = 0x20 # 2HD
			end
		when :"1d"
			disk_type = 0x30 # 1D
		when :"1dd"
			disk_type = 0x40 # 1DD
		else
			$stdout.print("  ディスクタイプが不明です: 2HDを設定します\n")
			disk_type = 0x20 # 2HD
		end

		trackdata = []
		(0 ... ntracks.clamp(0, max_tracks)).each do |trkno|
			trackdata1 = "".force_encoding(Encoding::BINARY)
			trk = @track[trkno]
			trk.sector.each do |s|
				sector_header = [
					s.c,
					s.h,
					s.r,
					s.n,
					trk.nsectors,
					(s.mfm.nil? ? true : s.mfm) ? 0x00 : 0x40, # FM/MFM
					(s.ddam.nil? ? false : s.ddam) ? 0x10 : 0x00, # DDAM
					s.status || 0,
					(disk_type == 0x21) ? 1 : 0, # NP2kai RPM
					s.ssize,
				].pack("C4vC3x4Cv")

				trackdata1 += sector_header
				trackdata1 += s.data
			end
			trackdata << trackdata1
		end

		offset = 0x20 + 4 * max_tracks
		track_table = trackdata.map{ |t| r = offset; offset += t.length; r }
		track_table[max_tracks - 1] ||= nil
		track_table = track_table.map{ |t| t || 0 }.pack("V*")

		header = [
			(@comment || "").encode(Encoding::WINDOWS_31J), # disk name
			(@writeprotect.nil? ? false : @writeprotect) ? 0x10 : 0x00, # write protect
			disk_type,
			offset, # disk size
		].pack("a17x9C2V")

		return header + track_table + trackdata.join
	end
end

# Anex86 ヘッダ(通常4096バイト)+べたデータ https://www.pc98.org/project/doc/hdi.html
class FDI < DiskImage
	IMAGE_FORMATNAME = "Anex86 FDI形式"
	IMAGE_EXTNAMES = [".fdi"]
	HEADER_SIZE = 0x20 # コメント除く最小サイズ
	MEDIA = {
		0x90 => :"2hd", # 2HD 1.2MB
		0x30 => :"2hd", # 2HD 1.44MB
		0x10 => :"2dd", # 2DD 640KB or 720KB
	}

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 4].to_dword == 0 &&
			MEDIA[filedata[4, 4].to_dword] &&
			filedata[0x8, 4].to_dword + filedata[0xc, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		fddtype_id = filedata[4, 4].to_dword
		if MEDIA[fddtype_id]
			@mediatype = MEDIA[fddtype_id]
		else
			$stdout.print("  メディアタイプ不明: #{fddtype_id.to_hex}\n")
			@mediatype = :unknown
		end

		headersize = filedata[0x8, 4].to_dword
		datasize = filedata[0xc, 4].to_dword
		ssize, nsecs, heads, cyls = filedata[0x10, 4 * 4].to_dwords
		$stdout.print("  ヘッダ情報: #{cyls}シリンダ x #{heads}ヘッド x #{nsecs}セクタ x #{ssize}バイト\n")

		@comment = filedata[0x20, headersize - 0x20].force_encoding(Encoding::WINDOWS_31J).encode.sub(/\0+$/, "")

		calc_datasize = cyls * heads * nsecs * ssize
		if calc_datasize != datasize
			$stdout.print("  ヘッダ情報のデータサイズとヘッダのCHRNから算出したサイズが一致しません: #{datasize} (!=#{calc_datasize})\n")
		end

		if headersize + datasize != filedata.length
			$stdout.print("  ヘッダ情報のデータサイズと実際のファイルサイズが一致しません: #{headersize + datasize} (!=#{filedata.length})\n")
		end

		offset = headersize
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end
end

# DCP/DCU ヘッダ(162バイト)+べたデータ https://www.pc98.org/project/doc/dcp.html https://melog.info/archives/2004/09/30/94#comment-27
class DCU < DiskImage
	IMAGE_FORMATNAME = "DCP/DCU形式"
	IMAGE_EXTNAMES = [".dcu", ".dcp"]
	HEADER_SIZE = 1 + 161
	GEOMETRIES = {
		0x01 => COMMON_GEOMETRIES.find_desc("2HD 1.23MB PC-98"), # 1024byte x 8sector
		0x02 => COMMON_GEOMETRIES.find_desc("2HC 1.2MB PC/AT"),  # 512byte x 15sector
		0x03 => COMMON_GEOMETRIES.find_desc("2HQ 1.44MB PC/AT"), # 512byte x 18sector
		0x04 => COMMON_GEOMETRIES.find_desc("2DD 640KB"),        # 512byte x 8sector
		0x05 => COMMON_GEOMETRIES.find_desc("2DD 720KB MSX"),    # 512byte x 9sector
		0x08 => COMMON_GEOMETRIES.find_desc("2HS/2HDE 1.44MB"),  # 1024byte x 9sector
		0x11 => COMMON_GEOMETRIES.find_desc("2HD DISK BASIC"),
		0x19 => COMMON_GEOMETRIES.find_desc("2DD DISK BASIC"),
		0x21 => COMMON_GEOMETRIES.find_desc("2HD 1.04MB"),       # 256byte x 26sector
	}

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		geom = GEOMETRIES[filedata[0].to_byte] # media type
		return false  if !geom
		cyls, heads, nsecs, ssize, ssize1 = geom[3 .. 7]

		return false  if filedata[1, 161].to_bytes.any?{ |t| !(t == 0 || t == 1) }
		track_bound = filedata[1, 161].to_bytes.rindex(1)
		track_count = filedata[1, track_bound].to_bytes.count(1) # track_flag

		calc_datasize_s = HEADER_SIZE + track_count * nsecs * ssize
		calc_datasize_a = HEADER_SIZE + cyls * heads * nsecs * ssize
		if ssize1
			calc_datasize_s -= nsecs * (ssize - ssize1)
			calc_datasize_a -= nsecs * (ssize - ssize1)
		end

		return filedata.length == calc_datasize_s || filedata.length == calc_datasize_a
	end

	def load(filedata)
		clear

		geom = GEOMETRIES[filedata[0].to_byte] # media type
		cyls, heads, nsecs, ssize, ssize1 = geom[3 .. 7]

		track_bound = filedata[1, 161].to_bytes.rindex(1)
		track_flag = filedata[1, track_bound].to_bytes
		track_count = track_flag.count(1)

		calc_datasize_a = HEADER_SIZE + cyls * heads * nsecs * ssize
		calc_datasize_a -= nsecs * (ssize - ssize1)  if ssize1
		track_flag.fill(1)  if filedata.length == calc_datasize_a

		# データ本体
		offset = HEADER_SIZE
		track_flag.each.with_index do |flag, trkno|
			cyl = trkno / heads
			head = trkno % heads
			trk_ssize = (ssize1 && trkno == 0) ? ssize1 : ssize # 最初のトラックだけセクタ長が異なる場合
			trk = (@track[trkno] ||= Track.new)
			(1 .. nsecs).each do |sec|
				s = Sector.new
				s.c = cyl # シリンダは0オリジン
				s.h = head # ヘッドは0オリジン
				s.r = sec # レコードは1オリジン
				s.n = (trk_ssize / 128).bit_length - 1
				case flag
				when 0 # なし
					s.data = "\xe5".force_encoding(Encoding::BINARY) * trk_ssize
				when 1 # あり
					s.data = filedata[offset, trk_ssize] || ""
					offset += trk_ssize
				end
				trk.sector << s
			end
		end
		sweep_niltrack
	end
end

# XDF べたデータ
class XDF < DiskImage
	IMAGE_FORMATNAME = "べたイメージ"
	IMAGE_EXTNAMES = [".xdf", ".tfd", ".vfd", ".dsk", ".dup", ".flp", ".hdb", ".hdm", ".2hd", ".2dd", ".2d", ".1d"]
	HEADER_SIZE = 0
	GEOMETRIES = COMMON_GEOMETRIES

	def self.image?(filedata)
		return GEOMETRIES.find{ |g| g[1] == filedata.length } ? true : false
	end

	def load(filedata)
		clear

		geom = GEOMETRIES.find{ |g| g[1] == filedata.length }
		cyls, heads, nsecs, ssize, ssize1 = geom[3 .. 7]

		if GEOMETRIES.count{ |g| g[1] == filedata.length } >= 2
			$stdout.print("  ジオメトリの候補が複数あります: #{geom[0]}と仮定します\n")
		end

		offset = 0
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk_ssize = (ssize1 && trkno == 0) ? ssize1 : ssize # 最初のトラックだけセクタ長が異なる場合
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (trk_ssize / 128).bit_length - 1
					s.data = filedata[offset, trk_ssize] || ""
					offset += trk_ssize
					trk.sector << s
				end
			end
		end
		sweep_niltrack
	end

	def dump
		return data
	end
end

# セクタデータをランダムな値で塗り潰す
def image_randomize(image)
	image.sector.each do |s|
		s.data = Random.bytes(s.ssize)
	end
end

def identify(filename)
	$stdout.print("#{filename}:\n")
	filedata = IO.binread(filename)

	image_class = DiskImage.guess_image_format(data:filedata)
	if !image_class
		$stdout.print("  ❓ 形式不明(#{filedata.length}バイト)\n")
		return
	end

	$stdout.print("  💾 #{image_class.image_formatname} #{image_class.image_extnames_s}\n")
	image = image_class.new(data:filedata)
	image.report_all
end

def convert_to(outclass, filename)
	$stdout.print("#{filename} → #{outclass.name}:\n")
	filedata = IO.binread(filename)

	image_class = DiskImage.guess_image_format(data:filedata)
	if !image_class
		$stdout.print("  ❓ 形式不明(#{filedata.length}バイト)\n")
		return
	end

	$stdout.print("  💾 #{image_class.image_formatname}\n")
	image = image_class.new(data:filedata)

	if $truncate_overtrack
		g = image.common_geometry_approx?
		if g
			ntracks_limit = g[3] * g[4]
		elsif image.ntracks > 90
			ntracks_limit = 160
		elsif image.ntracks > 45
			ntracks_limit = 80
		else
			ntracks_limit = 40
		end
		image.track = image.track.first(ntracks_limit)
	end

	if !image.common_geometry?
		if $force
			$stdout.print("  一般的なフォーマットではありません: 強行します\n")
		else
			$stdout.print("  一般的なフォーマットではありません\n")
			return
		end
	end

	ofilename = filename + outclass.image_extnames.first
	oimage = outclass.new
	oimage.copy(image)
	IO.binwrite(ofilename, oimage.dump)
end

# 空のイメージファイルを作成する
def create_blank(ofilename)
	outclass = $format
	g_desc, g_size, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = $geometry

	$stdout.print("Create new file: #{ofilename}\n")
	image = outclass.new
	$stdout.print("  💾 #{outclass.image_formatname}\n")
	$stdout.print("  #{g_desc}\n")

	image.mediatype = g_media
	(0 ... g_cyls).each do |cyl|
		(0 ... g_heads).each do |head|
			trkno = cyl * g_heads + head
			trk_ssize = (g_ssize1 && trkno == 0) ? g_ssize1 : g_ssize # 最初のトラックだけセクタ長が異なる場合
			trk = (image.track[trkno] ||= DiskImage::Track.new)
			(1 .. g_nsecs).each do |sec|
				s = DiskImage::Sector.new
				s.c = cyl # シリンダは0オリジン
				s.h = head # ヘッドは0オリジン
				s.r = sec # レコードは1オリジン
				s.n = (trk_ssize / 128).bit_length - 1
				s.data = "\xe5".force_encoding(Encoding::BINARY) * trk_ssize
				trk.sector << s
			end
		end
	end

	image_randomize(image)  if $random

	IO.binwrite(ofilename, image.dump)
end

# 9セクタ/トラックのイメージの各トラックの9セクタ目を切り捨てて8セクタのイメージにする
def truncate_9(filename)
	$stdout.print("#{filename} → Truncate 9th sector:\n")
	filedata = IO.binread(filename)

	image_class = DiskImage.guess_image_format(data:filedata)
	if image_class == XDF || image_class == D88
		image = image_class.new(data:filedata)

		if image.nsectors != 9
			$stdout.print("  9セクタのディスクジオメトリではありません\n")
			return
		end

		image.track.each do |t|
			t.sector.delete_if{ |s| s.r >= 9 } # Rが9以上のセクタを削除
		end

		ofilename = filename + image_class.image_extnames.first
		$stdout.print("  → #{ofilename}:\n")
		IO.binwrite(ofilename, image.dump)
	else
		$stdout.print("  ❓ 形式不明(#{filedata.length}バイト)\n")
	end
end

def show_formats
	$stdout.print("サポートするイメージファイルフォーマット(I=識別のみ R=読み込みのみ):\n")
	DiskImage.image_formsts.sort_by{ |c| c.name }.each do |imageclass|
		$stdout.print("  %-10s" % imageclass.name)
		if !imageclass.method_defined?(:load, false)
			$stdout.print(" (I) ")
		elsif !imageclass.method_defined?(:dump, false)
			$stdout.print(" (R) ")
		else
			$stdout.print("     ")
		end
		$stdout.print("#{imageclass::IMAGE_FORMATNAME}\n")
	end
end

def show_geometries
	$stdout.print("一般的なディスクジオメトリの一覧:\n")
	DiskImage::COMMON_GEOMETRIES.each do |g|
		$stdout.print("  %-20s" % "\"#{g[0]}\"")

		$stdout.print(" %3d x %1d x %2d x %4d%s\n" % [g[3], g[4], g[5], g[6], (g[7] ? "/#{g[7]}" : "")])
	end
end

def main(args)
	$action = :identify
	$format = nil
	$geometry = nil
	$force = false
	$truncate_overtrack = false
	$random = false

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] file..."

		opt.on("--identify",
		"イメージファイルの情報を表示する") do
			$action = :identify
		end

		opt.on("--convert",
		"ファイルフォーマットを変換する") do
			$action = :convert
		end

		opt.on("--create-blank",
		"空のイメージファイルを作成する") do
			$action = :create_blank
		end

		# opt.on("--compare",
		# "イメージファイルのデータを比較する") do
		# 	$action = :compare
		# end

		opt.on("--format=xxx", String,
		"ファイルフォーマットを指定する") do |f|
			candidates = DiskImage.image_formsts.filter{ |ff| ff.name.upcase.include?(f.upcase) }
			if candidates.length == 1
				$format = candidates.first
			elsif candidates.length > 1
				candidates_s = candidates.map{ |f| "#{f.name}?" }.join(" ")
				$stderr.print("#{ProgName}: Ambiguous format: #{f} -> #{candidates_s}\n")
				return 1
			else
				$stderr.print("#{ProgName}: Unknown format: #{f}\n")
				return 1
			end
		end

		opt.on("--geometry=xxx", String,
		"ディスクジオメトリを指定する") do |g|
			candidates = DiskImage::COMMON_GEOMETRIES.filter{ |gg| gg[0].upcase.include?(g.upcase) }
			if candidates.length == 1
				$geometry = candidates.first
			elsif candidates.length > 1
				candidates_s = candidates.map{ |g| "\"#{g[0]}\"?" }.join(" ")
				$stderr.print("#{ProgName}: Ambiguous geometry: #{g} -> #{candidates_s}\n")
				return 1
			else
				$stderr.print("#{ProgName}: Unknown geometry: #{g}\n")
				return 1
			end
		end

		opt.on("--show-formats",
		"使用できるファイルフォーマットの一覧を表示する") do
			$action = :show_formats
		end

		opt.on("--show-geometries",
		"一般的なジオメトリの一覧を表示する") do
			$action = :show_geometries
		end

		opt.on("--force", TrueClass,
		"危険な操作を実行する") do |v|
			$force = v
		end

		opt.on("--truncate-overtrack", TrueClass,
		"オーバートラック部分を切り捨てる") do |v|
			$truncate_overtrack = v
		end

		opt.on("--random", TrueClass,
		"セクタデータをランダムな値で塗り潰す") do |v|
			$random = v
		end

		opt.on("--truncate-9",
		"9セクタ目を切り捨てる") do
			$action = :truncate_9
		end

		opt.parse!

		if $action == :identify && args.empty?
			print(opt.help)
			return 0
		end

		case $action
		when :show_formats
			show_formats
		when :show_geometries
			show_geometries
		when :create_blank
			if !$format
				$stderr.print("#{ProgName}: ファイルフォーマットが指定されていません(--format=)\n")
				return 1
			end

			if !$geometry
				$stderr.print("#{ProgName}: ディスクジオメトリが指定されていません(--geometry=)\n")
				return 1
			end

			args.each do |an_arg|
				if File.exist?(an_arg)
					$stderr.print("#{ProgName}: File already exist: #{an_arg}\n")
					next
				end

				create_blank(an_arg)
			end
		else
			args.each do |an_arg|
				if !File.exist?(an_arg)
					$stderr.print("#{ProgName}: File not found: #{an_arg}\n")
					next
				end

				if !File.file?(an_arg)
					$stderr.print("#{ProgName}: Not a file: #{an_arg}\n")
					next
				end

				case $action
				when :identify
					identify(an_arg)
				when :convert
					if !$format
						$stderr.print("#{ProgName}: 変換先フォーマットが指定されていません(--format=)\n")
						return 1
					end
					convert_to($format, an_arg)
				when :truncate_9
					truncate_9(an_arg)
				end
			end
		end
	end

	return 0
end

exit main(ARGV)
