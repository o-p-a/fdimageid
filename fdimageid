#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# ãƒ•ãƒ­ãƒƒãƒ”ãƒ¼ãƒ‡ã‚£ã‚¹ã‚¯ã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®è­˜åˆ¥
#
# 2024/09/14 opaâ ğŸ™‚
#----------------------------------------------------------------

require "optparse"
require "pp"

ProgName = "fdimageid"
Version = "0.01"
#=====dpk===== Copyright2024
Copyright = "Copyright (c) 2024 by opa"
#=====dpk=====

class String
	def to_byte;	unpack1("C");	end
	def to_word;	unpack1("v");	end
	def to_dword;	unpack1("V");	end

	def to_bytes;	unpack("C*");	end
	def to_words;	unpack("v*");	end
	def to_dwords;	unpack("V*");	end
end

class Integer
	def to_hex;	"#{to_s(16)}h";	end
end

def read_file(filename, offset=0, length=nil)
	return IO.binread(filename, length, offset)
end

def write_file(filename, data)
	return IO.binwrite(filename, data)
end

class DiskImage
	attr_accessor(:mediatype, :track, :writeprotect, :comment)

	def initialize(filename:nil, data:nil)
		clear

		if filename
			data = read_file(filename)
		end

		if data
			load(data)
		end
	end

	def clear
		@mediatype = nil # :"1d", :"1dd", :"2d", :"2dd", :"2hd", :unknown
		@track = []
		@writeprotect = nil # true:Write Protected false:Writeable
		@comment = nil
		return self
	end

	def to_h
		return {
			mediatype: @mediatype,
			track: @track.map{ |t| t && t.to_h },
			writeprotect: @writeprotect,
			comment: @comment,
		}
	end

	class Track
		attr_accessor(:sector)

		def initialize
			clear
		end

		def clear
			@sector = []
			return self
		end

		def to_h
			return {
				sector: @sector.map{ |r| r && r.to_h },
			}
		end

		# ãƒˆãƒ©ãƒƒã‚¯ã«å«ã¾ã‚Œã‚‹ã‚»ã‚¯ã‚¿æ•°
		def nsectors
			return @sector.length
		end

		# å…¨ãƒã‚¤ãƒˆãŒåŒä¸€å€¤ã§ã‚ã‚‹ã‹
		def is_uniform?(test_value=nil)
			return nil  if @sector.empty?
			test_value ||= @sector[0].data[0]
			return @sector.all?{ |s| s.is_uniform?(test_value) }
		end
	end

	class Sector
		attr_accessor(:data, :c, :h, :r, :n, :mfm, :ddam, :cmd, :status, :st0, :st1, :st2, :pda)

		def initialize
			clear
		end

		def clear
			@data = ""
			@c = nil
			@h = nil
			@r = nil
			@n = nil
			@mfm = nil		# false:FM(S) true:MFM(D,H)
			@ddam = nil		# false:DAM true:DDAM
			@cmd = nil		# BIOS Read Data Command
			@status = nil	# BIOS Read Data Status 0:Normal Terminate
			@st0 = nil		# ST0
			@st1 = nil		# ST1
			@st2 = nil		# ST2
			@pda = nil		# PDA 0x90:1.2M 0x30:1.44M 0x10:640K
			return self
		end

		def to_h
			return {
				data: @data,
				c: @c,
				h: @h,
				r: @r,
				n: @n,
				mfm: @mfm,
				ddam: @ddam,
				cmd: @cmd,
				status: @status,
				st0: @st0,
				st1: @st1,
				st2: @st2,
				pda: @pda,
			}
		end

		# å…¨ãƒã‚¤ãƒˆãŒåŒä¸€å€¤ã§ã‚ã‚‹ã‹
		def is_uniform?(test_value=nil)
			return nil  if @data.empty?
			test_value ||= @data[0]
			return @data == test_value * @data.length
		end
	end

	# ç©ºã‹?
	def empty?
		return @mediatype.nil? && @writeprotect.nil? && @comment.nil? && xtracks == 0
	end

	# ãƒ‡ãƒ¼ã‚¿ã®ã‚ã‚‹æœ€çµ‚ãƒˆãƒ©ãƒƒã‚¯ç•ªå·
	def ntracks
		last_empty_track_count = @track.reverse.find_index { |t| !t.nil? }
		if last_empty_track_count
			return @track.length - last_empty_track_count
		else
			return 0 # ãƒ‡ãƒ¼ã‚¿ã®æœ‰ã‚‹ãƒˆãƒ©ãƒƒã‚¯ãŒç„¡ã„
		end
	end

	# ãƒ‡ãƒ¼ã‚¿ã®ã‚ã‚‹ãƒˆãƒ©ãƒƒã‚¯æ•°
	def xtracks
		return @track.count { |t| !t.nil? }
	end

	# å…¨ãƒ‡ãƒ¼ã‚¿ã‚’CHRNé †ã«é€£çµã—ãŸã‚‚ã®
	def whole_data
	end

	# ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯(å†…éƒ¨ç”¨)
	def excess_data_check(expect, actual)
		excess_data_length = expect - actual
		if excess_data_length > 0
			$stdout.print("  æœ«å°¾ã«ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™(#{excess_data_length}ãƒã‚¤ãƒˆä½™å‰°)\n")
		elsif excess_data_length < 0
			$stdout.print("  èª­ã¿è¾¼ã¿ä¸­ã«æœ«å°¾ã«é”ã—ã¾ã—ãŸ(#{-excess_data_length}ãƒã‚¤ãƒˆä¸è¶³)\n")
		end
	end
	protected(:excess_data_check)

	# æƒ…å ±ã‚’è¡¨ç¤º
	def report_all
		if empty?
			$stdout.print("  ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“(åˆæœŸçŠ¶æ…‹)\n")
			return
		end

		if @comment && !@comment.empty?
			$stdout.print("  ã‚³ãƒ¡ãƒ³ãƒˆ: #{@comment.inspect}\n")
		end

		ntracks_std = nil
		if @mediatype
			case @mediatype
			when :"1d"
				mediatype_s = "1D"
				ntracks_std = 40
			when :"1dd"
				mediatype_s = "1DD"
				ntracks_std = 80
			when :"2d"
				mediatype_s = "2D"
				ntracks_std = 40 * 2
			when :"2dd"
				mediatype_s = "2DD"
				ntracks_std = 80 * 2
			when :"2hd"
				mediatype_s = "2HD"
				ntracks_std = 80 * 2 # or 77 * 2
			when :unknown
				mediatype_s = "ä¸æ˜"
			else
				mediatype_s = "ä¸æ­£ãªå€¤(#{@mediatype})"
			end
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ç¨®åˆ¥: #{mediatype_s}\n")
		end

		if !@writeprotect.nil?
			if @writeprotect
				$stdout.print("  æ›¸ãè¾¼ã¿ç¦æ­¢\n")
			else
				$stdout.print("  æ›¸ãè¾¼ã¿å¯\n")
			end
		end

		nsectors = {}
		sector_size = {}
		mfm_count = {}
		ddam_count = 0
		status_count = {}
		@track.each.with_index do |trk, trkno|
			next  if !trk

			nsec = trk.nsectors
			nsectors[nsec] ||= 0
			nsectors[nsec] += 1

			sector_count = []
			trk.sector.each.with_index do |s, sec|
				if s.c != trkno / 2
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Cå€¤ãŒç‰¹æ®Šã§ã™: #{s.c} != #{trkno / 2}\n")
				end

				if s.h != trkno % 2
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Hå€¤ãŒç‰¹æ®Šã§ã™: #{s.h} != #{trkno % 2}\n")
				end

				# ã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã—ã¦ã‚‹ã¨æ™®é€šã«ç•°ãªã‚‹ã®ã§ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
				# if s.r != sec + 1
				# 	$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Rå€¤ãŒç‰¹æ®Šã§ã™: #{s.r} != #{sec+1}\n")
				# end

				sector_count[s.r] ||= 0
				sector_count[s.r] += 1

				ssize = s.data.length
				sector_size[ssize] ||= 0
				sector_size[ssize] += 1

				if !s.mfm.nil?
					mfm_count[s.mfm] ||= 0
					mfm_count[s.mfm] += 1
				end

				if s.ddam == true
					ddam_count += 1
				end

				if !s.status.nil? && s.status != 0
					status_count[s.status] ||= 0
					status_count[s.status] += 1
				end
			end

			sector_count.each.with_index do |count, sec|
				count ||= 0
				if sec == 0
					if count > 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã«Rå€¤ãŒ#{sec}ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")
					end
				else
					if count < 1
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã«Rå€¤ãŒ#{sec}ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“\n")
					elsif count > 1
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã«Rå€¤ãŒ#{sec}ã®ã‚»ã‚¯ã‚¿ãŒè¤‡æ•°ã‚ã‚Šã¾ã™\n")
					end
				end
			end
		end

		sector_size = sector_size.to_a.sort_by{ |e| e[1] }.reverse
		if !sector_size.empty?
			sector_size_s = "#{sector_size[0][0]}ãƒã‚¤ãƒˆ"
			if sector_size.length >= 2
				sector_size_s += "(æ··åœ¨ã‚ã‚Š)"
			end
		else
			sector_size_s = "0ãƒã‚¤ãƒˆ"
		end

		nsectors = nsectors.to_a.sort_by{ |e| e[1] }.reverse
		if !nsectors.empty?
			nsectors_s = "#{nsectors[0][0]}ã‚»ã‚¯ã‚¿"
			if nsectors.length >= 2
				nsectors_s += "(æ··åœ¨ã‚ã‚Š)"
			end
		else
			nsectors_s = "0ã‚»ã‚¯ã‚¿"
		end

		if @mediatype == :"2hd" && !sector_size.empty? && !nsectors.empty?
			if (sector_size[0][0] == 1024 && nsectors[0][0] == 8) ||
				(sector_size.length >= 2 && sector_size[0][0] == 256 && sector_size[1][0] == 128 && nsectors[0][0] == 26)

				ntracks_std = 77 * 2
			end
		end

		if(ntracks == xtracks)
			tracks_s = "#{ntracks}ãƒˆãƒ©ãƒƒã‚¯"
		else
			tracks_s = "#{ntracks}(#{xtracks})ãƒˆãƒ©ãƒƒã‚¯"
		end

		if ntracks_std
			if ntracks == ntracks_std
				tracks_s += "(æ¨™æº–)"
			else
				tracks_s += "(æ¨™æº–ã¯#{ntracks_std})"
			end
		end

		$stdout.print("  #{sector_size_s} Ã— #{nsectors_s} Ã— #{tracks_s}\n")

		if mfm_count.length >= 2
			$stdout.print("  FM/MFMæ··åœ¨: FM:#{mfm_count[false]}ã‚»ã‚¯ã‚¿ MFM:#{mfm_count[true]}ã‚»ã‚¯ã‚¿\n")
		end

		if ddam_count > 0
			$stdout.print("  Deleted Data Address Markã®ç«‹ã£ãŸã‚»ã‚¯ã‚¿ãŒ#{ddam_count}å€‹ã‚ã‚Šã¾ã™\n")
		end

		status_count = status_count.to_a.sort_by{ |e| e[1] }.reverse
		if !status_count.empty?
			status_count_s = "#{status_count[0][0].to_hex}ãŒ#{status_count[0][1]}å€‹"
			status_count_s += " ä»–"  if status_count.length >= 2
			$stdout.print("  FDC StatusãŒ0ã§ãªã„ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™(#{status_count_s})\n")
		end

		uniform_map = @track.map do |t|
			if t&.is_uniform?
				t.sector[0].data[0]
			else
				false
			end
		end

		trkno = 1
		uniform_map.chunk{ |d| d }.each do |c|
			c_tracks = c[1].length

			if c[0]
				if c_tracks == 1
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno}ã¯å…¨ã¦#{c[0].ord.to_hex}ã§ã™\n")
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno}ï½#{trkno+c_tracks-1}ã¯å…¨ã¦#{c[0].ord.to_hex}ã§ã™\n")
				end
			end

			trkno += c_tracks
		end
	end
end

# DIFC.X(.dim) ãƒ˜ãƒƒãƒ€(256ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://stdkmd.net/xeij/source/FDMedia.htm https://www.pc98.org/project/doc/dim.html
class DIM < DiskImage
	HEADER_SIZE = 0x100

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[171, 15] == "DIFC HEADER  \0\0" &&
			[0x00, 0x01, 0x02, 0x03, 0x09, 0x11].include?(filedata[0].to_byte)
	end

	def load(filedata)
		clear

		# DIFC.Xãƒãƒ¼ã‚¸ãƒ§ãƒ³
		difc_version = filedata[0xfe].to_byte
		difc_version_s = "1.%02x" % difc_version
		$stdout.print("  DIFC.xãƒãƒ¼ã‚¸ãƒ§ãƒ³: #{difc_version_s}\n")

		# ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—
		media_byte = filedata[0].to_byte
		case media_byte
		when 0x00 # 2HD(1.23MB)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		when 0x01 # 2HS(1.44MB)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x02 # 2HC(1.2MB)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 15, 512
		when 0x03 # 2HDE(1.44MB)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x09 # 2HQ(1.44MB)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 18, 512
		else
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{media_byte.to_hex}\n")
			@mediatype = :unknown
			cyls, heads, nsecs, ssize = 0, 0, 0, 0
		end

		# ãƒˆãƒ©ãƒƒã‚¯ä¿å­˜çŠ¶æ…‹
		xtrack_map = filedata[1, 170].to_bytes
		xtrack_map.each.with_index do |flag, trkno|
			if flag == 0 || flag == 1
				# OK:NOP
			else
				$stdout.print("  #{trkno+1}ãƒˆãƒ©ãƒƒã‚¯ã®ãƒ‡ãƒ¼ã‚¿æœ‰ç„¡ãƒ•ãƒ©ã‚°ãŒä¸æ­£: #{flag}\n")
			end
		end

		# ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚åˆ»
		create_time = filedata[0xba, 8]
		if create_time != "\0" * 8
			create_time = create_time.unpack("CH2H2H2CH2H2H2").map{ |e| e.to_i }
			create_time[0] = "æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ"[create_time[0]]
			create_time[1] = 1980 + create_time[1]
			$stdout.print("  ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚åˆ»: " +
				"#{create_time[1]}/#{"%02d" % create_time[2]}/#{"%02d" % create_time[3]}(#{create_time[0]}) " +
				"#{create_time[5]}:#{"%02d" % create_time[6]}:#{"%02d" % create_time[7]}(#{(create_time[4]==0) ? "12" : "24"}æ™‚é–“è¨ˆ)\n")
		end

		# ã‚³ãƒ¡ãƒ³ãƒˆ
		@comment = filedata[0xc2, 60].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		# ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯
		header_ntracks = filedata[0xff].to_byte
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒˆãƒ©ãƒƒã‚¯æ•°: #{header_ntracks}ãƒˆãƒ©ãƒƒã‚¯\n")  if header_ntracks > 0

		# ãƒ‡ãƒ¼ã‚¿æœ¬ä½“
		offset = HEADER_SIZE
		xtrack_map.each.with_index do |flag, trkno|
			case flag
			when 0 # ãªã—
				@track[trkno] = nil
			when 1 # ã‚ã‚Š
				cyl = trkno / heads
				head = trkno % heads

				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end

		excess_data_check(filedata.length, offset)
	end

	def dump
		raise("Not implemented")
	end
end

# T98Next R0(.nfd) ãƒ˜ãƒƒãƒ€(68112ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/nfdr0.txt
class NFD_R0 < DiskImage
	HEADER_SIZE = 0x10a10

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 15] == "T98FDDIMAGE.R0\0"
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		@writeprotect = (filedata[0x10 + 0x100 + 4].to_byte != 0) ? true : false
		byHead = filedata[0x10 + 0x100 + 5].to_byte

		$stdout.print("  ãƒ˜ãƒƒãƒ€éƒ¨ã®ãƒ˜ãƒƒãƒ‰æ•°: #{byHead}\n")

		id_offset = 0x120
		data_offset = dwHeadSize
		(0 ... 163).each do |trkno|
			(0 ... 26).each do |sec|
				s = Sector.new
				s.c, s.h, s.r, s.n, s.mfm, s.ddam, s.status, s.st0, s.st1, s.st2, s.pda =
					filedata[id_offset, 11].unpack("C11")
				id_offset += 0x10

				next  if s.c == 0xff

				if s.c > 90 || s.h > 1 || s.r > 32 || s.n > 6
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®CHRNä¸æ­£: #{s.c}/#{s.h}/#{s.r}/#{s.n}\n")
					next  if s.n > 6 # è‡´å‘½çš„ãªã®ã§ã“ã®ã‚»ã‚¯ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  flMFMã®å€¤ãŒä¸æ­£: #{s.mfm}\n")
					s.mfm = nil
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  flDDAMã®å€¤ãŒä¸æ­£: #{s.ddam}\n")
					s.ddam = nil
				end

				ssize = 128 << s.n
				s.data = filedata[data_offset, ssize] || ""
				data_offset += ssize

				trk = (@track[trkno] ||= Track.new)
				trk.sector << s
			end
		end

		excess_data_check(filedata.length, data_offset)
	end

	def dump
		raise("Not implemented")
	end
end

# T98Next R1(.nfd) ãƒ˜ãƒƒãƒ€(å…¨ä½“(960ãƒã‚¤ãƒˆ)+ã‚»ã‚¯ã‚¿+ç‰¹æ®Šèª­ã¿è¾¼ã¿)+ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/nfdr1.txt
class NFD_R1 < DiskImage
	HEADER_SIZE = 0x3c0

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 15] == "T98FDDIMAGE.R1\0"
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		@writeprotect = (filedata[0x10 + 0x100 + 4].to_byte != 0) ? true : false
		byHead = filedata[0x10 + 0x100 + 5].to_byte
		dwTrackHead = filedata[0x10 + 0x100 + 0x10, 4 * 164].to_dwords
		dwAddInfo = filedata[0x10 + 0x100 + 0x10 + 4 * 164, 4].to_dword

		$stdout.print("  ãƒ˜ãƒƒãƒ€éƒ¨ã®ãƒ˜ãƒƒãƒ‰æ•°: #{byHead}\n")
		$stdout.print("  è¿½åŠ æƒ…å ±ãƒ˜ãƒƒãƒ€ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒ0ä»¥å¤–ã§ã™: #{dwAddInfo.to_hex}\n")  if dwAddInfo != 0

		data_offset = dwHeadSize
		sp_read_count = {}
		dwTrackHead.each.with_index do |track_offset, trkno|
			next  if track_offset == 0

			nsecs, wDiag = filedata[track_offset, 2 * 2].to_words
			track_offset += 0x10

			trk = (@track[trkno] ||= Track.new)
			(0 ... nsecs).each do |sec|
				s = Sector.new
				s.c, s.h, s.r, s.n, s.mfm, s.ddam, s.status, s.st0, s.st1, s.st2, byRetry, s.pda =
					filedata[track_offset, 12].unpack("C12")
				track_offset += 0x10

				if s.c > 90 || s.h > 1 || s.r > 32 || s.n > 6
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®CHRNä¸æ­£: #{s.c}/#{s.h}/#{s.r}/#{s.n}\n")
					next  if s.n > 6 # è‡´å‘½çš„ãªã®ã§ã“ã®ã‚»ã‚¯ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  flMFMã®å€¤ãŒä¸æ­£: #{s.mfm}\n")
					s.mfm = nil
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  flDDAMã®å€¤ãŒä¸æ­£: #{s.ddam}\n")
					s.ddam = nil
				end

				ssize = 128 << s.n
				if byRetry == 0
					s.data = filedata[data_offset, ssize] || ""
					data_offset += ssize
				else
					$stdout.print("  ãƒªãƒˆãƒ©ã‚¤ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã™: 1+#{byRetry}å›\n")
					s.data = []
					(0 .. byRetry).each do
						s.data << (filedata[data_offset, ssize] || "")
						data_offset += ssize
					end
				end

				trk.sector << s
			end

			(0 ... wDiag).each do
				d_cmd, d_c, d_h, d_r, d_n, d_byStatus, d_bySTS0, d_bySTS1, d_bySTS2, d_byRetry, d_dwDataLen, d_byPDA =
					filedata[track_offset, 15].unpack("C10VC")
				track_offset += 0x10
				data_offset += d_dwDataLen

				sp_read_count[d_cmd] ||= 0
				sp_read_count[d_cmd] += 1
			end
		end

		sp_read_count = sp_read_count.to_a.sort_by{ |e| e[1] }.reverse
		sp_read_count.each do |cmd, count|
			case cmd
			when 0x0
				cmd_s = "Seek"
			when 0x1
				cmd_s = "Verify"
			when 0x2
				cmd_s = "Read Diagnostic"
			when 0x3
				cmd_s = "Initialize"
			when 0x4
				cmd_s = "Sense"
			when 0x5
				cmd_s = "Write Data"
			when 0x6
				cmd_s = "Read Data"
			when 0x7
				cmd_s = "Recalibrate"
			when 0x9
				cmd_s = "Write Deleted Data"
			when 0xa
				cmd_s = "Read ID"
			when 0xc
				cmd_s = "Read Deleted Data"
			when 0xd
				cmd_s = "Format Track"
			when 0xe
				cmd_s = "Set Operation Mode"
			else
				cmd_s = "ä¸æ˜ãªã‚³ãƒãƒ³ãƒ‰"
			end

			$stdout.print("  ç‰¹æ®Šèª­ã¿è¾¼ã¿ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã™: #{cmd_s}: #{count}å€‹\n")
		end

		excess_data_check(filedata.length, data_offset)
	end

	def dump
		raise("Not implemented")
	end
end

# SL9821(.slf) ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ˜ãƒƒãƒ€(16ãƒã‚¤ãƒˆ)+ãƒˆãƒ©ãƒƒã‚¯ãƒ˜ãƒƒãƒ€(32*80*2=5120ãƒã‚¤ãƒˆ)+ãƒ‡ãƒ¼ã‚¿ https://www.satotomi.com/pifdc/pifdc_slf.html
class SLF < DiskImage
	HEADER_SIZE = 16 + 32 * 80 * 2

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 4] == "FDIM" &&
			filedata[4, 4].to_dword == 0x10000 &&
			filedata[8, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		version, filesize, flag = filedata[4, 12].to_dwords
		$stdout.print("  SLFãƒãƒ¼ã‚¸ãƒ§ãƒ³: #{version.to_hex}\n")

		if filesize != filedata.length
			$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã¨å®Ÿéš›ã®ã‚µã‚¤ã‚ºãŒç•°ãªã‚Šã¾ã™: #{filesize} != #{filedata.length}\n")
		end

		if flag != 0
			$stdout.print("  ãƒ•ãƒ©ã‚°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™: #{flag.to_hex}\n")
		end

		cyls, heads = 80, 2
		(0 ... cyls * heads).each do |trkno|
			tdata_offset, tdata_size, unformat_size, data_type, nsecs, gap4a_size, sync_size, gap1_size =
				filedata[0x10 + 0x20 * trkno, 28].unpack("V3v2V3")

			case data_type
			when 0xffff # -1:æœªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
				@track[trkno] = nil
			when 0 # ç‰©ç†ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ‡ãƒ¼ã‚¿
				$stdout.print("  ç‰©ç†ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒˆãƒ©ãƒƒã‚¯ã«ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“: #{trkno+1}ãƒˆãƒ©ãƒƒã‚¯\n")
				@track[trkno] = nil
			when 1, 2 # 1:FM/2:MFMãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ‡ãƒ¼ã‚¿
				sheader_offset = tdata_offset
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					sdata_offset, status, isync_size, gap2_size, dsync_size, gap3_size,
						id_crc, data_crc, idam_pattern, s.c, s.h, s.r, s.n, dataam_pattern =
						filedata[sheader_offset, 32].unpack("V2v6VC4V")
					sheader_offset += 0x20

					if s.c > 90 || s.h > 1 || s.r > 32 || s.n > 6
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®CHRNä¸æ­£: #{s.c} #{s.h} #{s.r} #{s.n}\n")
						next  if s.n > 6 # è‡´å‘½çš„ãªã®ã§ã“ã®ã‚»ã‚¯ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—
					end

					sdata_offset = tdata_offset + sdata_offset
					ssize = 128 << s.n
					s.mfm = (data_type == 2) ? true : false
					s.data = filedata[sdata_offset, ssize] || ""
					trk.sector << s

					if (status & 0x1) != 0
						$stdout.print("  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹(#{id_c}/#{id_h}/#{id_s}/#{id_n}): IDAMãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x2) != 0
						$stdout.print("  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹(#{id_c}/#{id_h}/#{id_s}/#{id_n}): ID CRCã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x4) != 0
						$stdout.print("  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹(#{id_c}/#{id_h}/#{id_s}/#{id_n}): DATAAMãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x8) != 0
						$stdout.print("  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹(#{id_c}/#{id_h}/#{id_s}/#{id_n}): DATA CRCã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x10) != 0
						$stdout.print("  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹(#{id_c}/#{id_h}/#{id_s}/#{id_n}): ã‚»ã‚¯ã‚¿æ§‹é€ ã®ã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x100) != 0
						$stdout.print("  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹(#{id_c}/#{id_h}/#{id_s}/#{id_n}): Deletedã‚»ã‚¯ã‚¿\n")
					end
					if (status & 0x200) != 0
						$stdout.print("  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹(#{id_c}/#{id_h}/#{id_s}/#{id_n}): å…¥ã‚Œå­ã‚»ã‚¯ã‚¿\n")
					end
					if (status | 0x31f) != 0x31f # ä¸Šè¨˜ä»¥å¤–ã®ãƒ“ãƒƒãƒˆãŒç«‹ã£ã¦ã„ãŸã‚‰
						$stdout.print("  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹(#{id_c}/#{id_h}/#{id_s}/#{id_n}): ä¸æ˜ãªå€¤(#{status.to_hex})\n")
					end
				end
			end
		end
	end

	def dump
		raise("Not implemented")
	end
end

# Virtual98(.fdd) ãƒ˜ãƒƒãƒ€+å¯å¤‰é•·ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/fdd.html
class V98FDD < DiskImage
	HEADER_SIZE = 0xc3fc

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 7] == "VFD1.00"
	end

	def load(filedata)
		clear

		@mediatype = :"2hd" # é•ã£ãŸã‚‰ã‚ã¨ã§ãƒªã‚»ãƒƒãƒˆ
		@comment = filedata[0x8, 0x80].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		@writeprotect = (filedata[0x88, 2].to_word != 0) ? true : false
		special_read_drive = filedata[0x8a, 2].to_word

		cyls, heads = 80, 2
		offset = 0xdc
		(0 ... cyls * heads).each do |trkno|
			(0 ... 26).each do
				s = Sector.new
				s.c, s.h, s.r, s.n, fill_byte, s.ddam, s.mfm, hd, sector_offset =
					filedata[offset, 12].unpack("C4aC3V")
				offset += 12

				next  if s.c == 0xff

				if s.c > 90 || s.h > 1 || s.r > 32 || s.n > 6
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®CHRNä¸æ­£: #{s.c} #{s.h} #{s.r} #{s.n}\n")
					next  if s.n > 6 # è‡´å‘½çš„ãªã®ã§ã“ã®ã‚»ã‚¯ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  DDAMã®å€¤ãŒä¸æ­£: #{s.ddam}\n")
					s.ddam = nil
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  MFã®å€¤ãŒä¸æ­£: #{s.mfm}\n")
					s.mfm = nil
				end

				if hd != 1
					$stdout.print("  2HDãƒ•ãƒ©ã‚°ãŒ1ã§ãªã„ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™: #{hd}\n")
					@mediatype = nil
				end

				ssize = 128 << s.n
				s.data = (sector_offset == 0xffffffff) ? fill_byte * ssize : filedata[sector_offset, ssize]

				trk = (@track[trkno] ||= Track.new)
				trk.sector << s
			end
		end

		if special_read_drive != 0xffff
			$stdout.print("  ç‰¹æ®Šèª­ã¿è¾¼ã¿ãƒ‰ãƒ©ã‚¤ãƒ–è¨­å®šãŒã‚ã‚Šã¾ã™: #{special_read_drive.to_hex}\n")

			next_point = special_read_drive # 0xc3dc
			begin
				trkno, in_ax, in_bx, in_cx, in_dx, out_ax, out_bx, out_cx, out_dx, out_flag, data_point, next_point, count, neg_count =
					filedata[next_point, 32].unpack("v10V2v2")
			end while(next_point != 0xffffffff && next_point != 0)
		end
	end

	def dump
		raise("Not implemented")
	end
end

# ERCVFD(.vfd) ãƒ˜ãƒƒãƒ€(64ãƒã‚¤ãƒˆ)+ã‚»ã‚¯ã‚¿æ¯ã«(ãƒ˜ãƒƒãƒ€(10ãƒã‚¤ãƒˆ)+ãƒ‡ãƒ¼ã‚¿)
class ERCVFD < DiskImage
	HEADER_SIZE = 0x40

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 8] == "ERCVFD01"
	end

	def load(filedata)
		raise("Not implemented")
	end

	def dump
		raise("Not implemented")
	end
end

# DIP(.dip) ãƒ˜ãƒƒãƒ€(256ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/dip.html
class DIP < DiskImage
	HEADER_SIZE = 256

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 8] == "\x01\x08\x00\x13\x41\x00\x01\x00" &&
			filedata.length == HEADER_SIZE + (77 * 2 * 8 * 1024)
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0xf0].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		offset = HEADER_SIZE
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end

		excess_data_check(filedata.length, offset)
	end

	def dump
		raise("Not implemented")
	end
end

# D88(.d88) ãƒ‡ã‚£ã‚¹ã‚¯ãƒ˜ãƒƒãƒ€+ã‚»ã‚¯ã‚¿æ¯ã«(ãƒ˜ãƒƒãƒ€+ãƒ‡ãƒ¼ã‚¿) https://www.pc98.org/project/doc/d88.html https://github.com/waitingmoon/quasi88/blob/develop/document/FORMAT.TXT
class D88 < DiskImage
	HEADER_SIZE = 0x2a0 # or 0x2b0

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0x10, 10] == "\0" * 10 &&
			[0x00, 0x10, 0x20, 0x21, 0x30, 0x40].include?(filedata[0x1b].to_byte) &&
			filedata.length == filedata[0x1c, 4].to_dword
	end

	def load(filedata)
		clear

		# Media flag
		media_flag = filedata[0x1b].to_byte
		case media_flag
		when 0x00 # 2D
			@mediatype = :"2d"
		when 0x10 # 2DD
			@mediatype = :"2dd"
		when 0x20 # 2HD
			@mediatype = :"2hd"
		when 0x21 # 2HD(1.44MB NP2kai)
			$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—: 2HD 1.44MB NP2kaiæ‹¡å¼µ\n")
			@mediatype = :"2hd"
		when 0x30 # 1D
			@mediatype = :"1d"
		when 0x40 # 1DD
			@mediatype = :"1dd"
		else
			$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{media_flag.to_hex}\n")
			@mediatype = :unknown
		end

		# Write protect flag
		@writeprotect = (filedata[0x1a].to_byte == 0) ? false : true

		# Disk name / comment
		@comment = filedata[0, 16].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		# Track data
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find { |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4 # 0x2b0(688byte:164entry) or 0x2a0(672byte:160entry)
		track_offsets = track_offsets.first(header_tracks)

		track_offsets.each.with_index do |offset, trkno|
			if offset == 0
				@track[trkno] = nil
			else
				trk = (@track[trkno] ||= Track.new)

				track_nsectors = nil
				begin
					s = Sector.new
					s.c, s.h, s.r, s.n, nsecs, s.mfm, s.ddam, s.status, rpm, datasize =
						filedata[offset, 16].unpack("C4vC3x4Cv")
					offset += 0x10

					if s.c > 90 || s.h > 1 || s.r > 32 || s.n > 6
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®CHRNä¸æ­£: #{s.c} #{s.h} #{s.r} #{s.n}\n")
						break  if s.n > 6 # è‡´å‘½çš„ãªã®ã§ã“ã®ãƒˆãƒ©ãƒƒã‚¯ã¯ã‚¹ã‚­ãƒƒãƒ—
					end

					if nsecs > 32
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿æ•°ä¸æ­£: #{nsecs}\n")
					end

					if !track_nsectors
						track_nsectors = nsecs
					elsif track_nsectors != nsecs
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ç·ã‚»ã‚¯ã‚¿æ•°ãŒçµ±ä¸€ã•ã‚Œã¦ã„ãªã„: #{track_nsectors} != #{nsecs}\n")
					end

					case s.mfm
					when 0x00 # double density
						s.mfm = true
					when 0x40 # single density
						s.mfm = false
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®Density flagä¸æ­£: #{s.mfm.to_hex}\n")
						s.mfm = nil
					end

					case s.ddam
					when 0x00 # normal
						s.ddam = false
					when 0x10 #deleted
						s.ddam = true
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®DDAM flagä¸æ­£: #{s.ddam.to_hex}\n")
						s.ddam = nil
					end

					if rpm == 0 || rpm == 1
						# OK:NOP
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®NP2kai RPMä¸æ­£: #{rpm}\n")
					end

					ssize = 128 << s.n
					if ssize != datasize
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nå€¤ã¨ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºãŒç•°ãªã‚‹: N:#{ssize} != #{datasize}\n")
					end

					s.data = filedata[offset, ssize] || ""
					offset += ssize

					trk.sector << s
				end while trk.sector.length < nsecs

				next_track_start = (track_offsets[(trkno + 1) .. -1].find { |o| o != 0 }) || filedata.length
				if offset != next_track_start
					if offset < next_track_start
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ãƒ‡ãƒ¼ã‚¿ã®å¾Œã«ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™\n")
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ãƒ‡ãƒ¼ã‚¿ãŒæ¬¡ã®ãƒˆãƒ©ãƒƒã‚¯ã«é”ã—ã¦ã„ã¾ã™\n")
					end
				end
			end
		end
	end

	def dump
		raise("Not implemented")
	end
end

# Anex86(.fdi) ãƒ˜ãƒƒãƒ€(é€šå¸¸4096ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/hdi.html
class FDI < DiskImage
	HEADER_SIZE = 0x20 # ã‚³ãƒ¡ãƒ³ãƒˆé™¤ãæœ€å°ã‚µã‚¤ã‚º

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 4].to_dword == 0 &&
			[0x90, 0x30, 0x10].include?(filedata[4, 4].to_dword) &&
			filedata[0x8, 4].to_dword + filedata[0xc, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		fddtype_id = filedata[4, 4].to_dword
		case fddtype_id
		when 0x90 # 2HD(1.2MB)
			@mediatype = :"2hd"
		when 0x30 # 2HD(1.44MB)
			@mediatype = :"2hd"
		when 0x10 # 2DD(640KB or 720KB)
			@mediatype = :"2dd"
		else
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{fddtype_id.to_hex}\n")
			@mediatype = :unknown
		end

		headersize = filedata[0x8, 4].to_dword
		datasize = filedata[0xc, 4].to_dword
		ssize, nsecs, heads, cyls = filedata[0x10, 4 * 4].to_dwords
		$stdout.print("  ãƒ˜ãƒƒãƒ€æƒ…å ±: #{ssize}ãƒã‚¤ãƒˆ Ã— #{nsecs}ã‚»ã‚¯ã‚¿ Ã— #{heads}ãƒ˜ãƒƒãƒ‰ Ã— #{cyls}ãƒˆãƒ©ãƒƒã‚¯\n")

		@comment = filedata[0x20, headersize - 0x20].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		calc_datasize = cyls * heads * nsecs * ssize
		if calc_datasize != datasize
			$stdout.print("  ãƒ˜ãƒƒãƒ€æƒ…å ±ã‹ã‚‰ç®—å‡ºã—ãŸãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã¨ãƒ˜ãƒƒãƒ€æƒ…å ±ã®ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºãŒä¸€è‡´ã—ã¾ã›ã‚“: #{calc_datasize} != #{datasize}\n")
		end

		if headersize + datasize != filedata.length
			$stdout.print("  ãƒ˜ãƒƒãƒ€æƒ…å ±ã®ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã¨å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒä¸€è‡´ã—ã¾ã›ã‚“: #{headersize + datasize} != #{filedata.length}\n")
		end

		offset = headersize
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end

		excess_data_check(filedata.length, offset)
	end

	def dump
		raise("Not implemented")
	end
end

# DCP/DCU(.dcu) ãƒ˜ãƒƒãƒ€(162ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/dcp.html https://melog.info/archives/2004/09/30/94#comment-27
class DCU < DiskImage
	HEADER_SIZE = 1 + 160 + 1

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		track_map = filedata[1, 160].to_bytes
		track_map.each do |t|
			if t != 0 && t != 1
				return false
			end
		end

		media_type = filedata[0].to_byte
		case [media_type, filedata.length]
		when [0x01, HEADER_SIZE + (77 * 2 * 8 * 1024)] # 2HD(1.25MB 2HS)
			return true
		when [0x02, HEADER_SIZE + (80 * 2 * 15 * 512)] # 2HD(1.21MB 2HC)
			return true
		when [0x03, HEADER_SIZE + (80 * 2 * 18 * 512)] # 2HQ(1.44MB 2HDE)
			return true
		when [0x04, HEADER_SIZE + (80 * 2 * 8 * 512)] # 2DD(640KB)
			return true
		when [0x05, HEADER_SIZE + (80 * 2 * 9 * 512)] # 2DD(720KB)
			return true
		when [0x08, HEADER_SIZE + (80 * 2 * 9 * 1024)] # 2HD(1.44MB)
			return true
		when [0x11, HEADER_SIZE + (1*26*128 + 153*26*256)] # 2HD(Disk BASIC)
			return true
		when [0x19, HEADER_SIZE + (80 * 2 * 16 * 256)] # 2DD(Disk BASIC)
			return true
		when [0x21, HEADER_SIZE + (80 * 2 * 26 * 256)] # 2HD(26sector)
			return true
		end

		return false
	end

	def load(filedata)
		clear

		media_type = filedata[0].to_byte
		case media_type
		when 0x01 # 2HD(1.25MB 2HS)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		when 0x02 # 2HD(1.21MB 2HC)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 15, 512
		when 0x03 # 2HQ(1.44MB 2HDE)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 18, 512
		when 0x04 # 2DD(640KB)
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 8, 512
		when 0x05 # 2DD(720KB)
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 512
		when 0x08 # 2HD(1.44MB)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x11 # 2HD(Disk BASIC)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize, ssize1 = 77, 2, 26, 256, 128
		when 0x19 # 2DD(Disk BASIC)
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 16, 256
		when 0x21 # 2HD(26sector)
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 26, 256
		else
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{media_type.to_hex}\n")
			@mediatype = :unknown
			cyls, heads, nsecs, ssize = 0, 0, 0, 0
		end

		# ãƒˆãƒ©ãƒƒã‚¯ä¿å­˜çŠ¶æ…‹
		xtrack_map = filedata[1, 160].to_bytes
		xtrack_map.each.with_index do |flag, trkno|
			if flag == 0 || flag == 1
				# OK:NOP
			else
				$stdout.print("  #{trkno+1}ãƒˆãƒ©ãƒƒã‚¯ã®ãƒ‡ãƒ¼ã‚¿æœ‰ç„¡ãƒ•ãƒ©ã‚°ãŒä¸æ­£: #{flag}\n")
			end
		end

		# å…¨ãƒˆãƒ©ãƒƒã‚¯æ ¼ç´ãƒ•ãƒ©ã‚°
		all_cylinders_stored = filedata[0xa1].to_byte
		case all_cylinders_stored
		when 0
			# OK:NOP
		when 1
			$stdout.print("  å…¨ãƒˆãƒ©ãƒƒã‚¯æ ¼ç´ãƒ•ãƒ©ã‚°: ON\n")
			(0 ... cyls * heads).each do |trkno|
				xtrack_map[trkno] = 1
			end
		else
			$stdout.print("  å…¨ãƒˆãƒ©ãƒƒã‚¯æ ¼ç´ãƒ•ãƒ©ã‚°ä¸æ­£: #{all_cylinders_stored}\n")
		end

		# ãƒ‡ãƒ¼ã‚¿æœ¬ä½“
		offset = HEADER_SIZE
		xtrack_map.each.with_index do |flag, trkno|
			case flag
			when 0 # ãªã—
				@track[trkno] = nil
			when 1 # ã‚ã‚Š
				cyl = trkno / heads
				head = trkno % heads

				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end

		excess_data_check(filedata.length, offset)
	end

	def dump
		raise("Not implemented")
	end
end

# XDF(.xdf) ã¹ãŸãƒ‡ãƒ¼ã‚¿
class XDF < DiskImage
	HEADER_SIZE = 0
	Geometries = [
		# length   media  cyls heads  nsec ssize ssize1
		[1474560, :"2hd",   80,    2,   18,  512],			# 1.44MB 2HD
		[1474560, :"2hd",   80,    2,    9, 1024],			# 1.44MB 2HD
		[1261568, :"2hd",   77,    2,    8, 1024],			# 1.23MB 2HD
		[1228800, :"2hd",   80,    2,   15,  512],			# 1.2MB 2HD
		[1064960, :"2hd",   80,    2,   26,  256],			# 1.04MB 2HD
		[1021696, :"2hd",   77,    2,   26,  256,  128],	# DISK BASIC 2HD
		[ 819200, :"2dd",   80,    2,   10,  512],			# 800KB 2DD
		[ 737280, :"2dd",   80,    2,    9,  512],			# 720KB 2DD
		[ 655360, :"2dd",   80,    2,    8,  512],			# 640KB 2DD
		[ 655360, :"2dd",   80,    2,   16,  256],			# DISK BASIC 2DD
		[ 327680, :"2d",    40,    2,    8,  512],			# 320KB 2D
		[ 327680, :"1dd",   80,    1,    8,  512],			# 320KB 1DD
		[ 163840, :"1d",    40,    1,    8,  512],			# 160KB 1D
	]

	def self.image?(filedata)
		return Geometries.find{ |g| g[0] == filedata.length } ? true : false
	end

	def load(filedata)
		clear

		geom = Geometries.find{ |g| g[0] == filedata.length }
		cyls, heads, nsecs, ssize = geom[2 .. 5]

		offset = 0
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end

		excess_data_check(filedata.length, offset)
	end

	def dump
		raise("Not implemented")
	end
end

def fdimageid(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze

	case
	# DIFC.X(.dim)
	when DIM.image?(filedata)
		$stdout.print("  ğŸ’¾ X68000 DIFC.Xå½¢å¼ [.dim]\n")
		image = DIM.new(data:filedata)
		image.report_all

	# T98Next R0(.nfd)
	when NFD_R0.image?(filedata)
		$stdout.print("  ğŸ’¾ T98-Next NFD r0å½¢å¼ [.nfd]\n")
		image = NFD_R0.new(data:filedata)
		image.report_all

	# T98Next R1(.nfd)
	when NFD_R1.image?(filedata)
		$stdout.print("  ğŸ’¾ T98-Next NFD r1å½¢å¼ [.nfd]\n")
		image = NFD_R1.new(data:filedata)
		image.report_all

	# SL9821(.slf)
	when SLF.image?(filedata)
		$stdout.print("  ğŸ’¾ SL9821å½¢å¼ [.slf]\n")
		image = SLF.new(data:filedata)
		image.report_all

	# Virtual98(.fdd)
	when V98FDD.image?(filedata)
		$stdout.print("  ğŸ’¾ Virtual98å½¢å¼ [.fdd]\n")
		image = V98FDD.new(data:filedata)
		image.report_all

	# ERCVFD(.vfd)
	when ERCVFD.image?(filedata)
		$stdout.print("  ğŸ’¾ ERCACHE ERCVFDå½¢å¼ [.vfd]\n")
		# image = ERCVFD.new(data:filedata)
		# image.report_all

	# DIP(.dip)
	when DIP.image?(filedata)
		$stdout.print("  ğŸ’¾ DIPå½¢å¼ [.dip]\n")
		image = DIP.new(data:filedata)
		image.report_all

	# D88(.d88)
	when D88.image?(filedata)
		$stdout.print("  ğŸ’¾ D88å½¢å¼ [.d88 .d98 .88d .98d]\n")
		image = D88.new(data:filedata)
		image.report_all

	# Anex86(.fdi)
	when FDI.image?(filedata)
		$stdout.print("  ğŸ’¾ Anex86å½¢å¼ [.fdi]\n")
		image = FDI.new(data:filedata)
		image.report_all

	# DCP/DCU(.dcu)
	when DCU.image?(filedata)
		$stdout.print("  ğŸ’¾ DCP/DCUå½¢å¼ [.dcu .dcp]\n")
		image = DCU.new(data:filedata)
		image.report_all

	# XDF(.xdf)
	when XDF.image?(filedata)
		case filedata.length
		when 80 * 2 * 18 * 512 # 1.44MB 2HD
			$stdout.print("  ğŸ’¾ ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.44MB PC/AT) [.2hd]\n")
		when 77 * 2 * 8 * 1024 # 1.23MB 2HD
			$stdout.print("  ğŸ’¾ ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.23MB PC98) [.xdf .2hd .dup .hdm .tfd]\n")
		when 80 * 2 * 15 * 512 # 1.2MB 2HD
			$stdout.print("  ğŸ’¾ ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.2MB PC/AT) [.2hd]\n")
		when 80 * 2 * 9 * 512 # 720KB 2DD
			$stdout.print("  ğŸ’¾ ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2DD(720KB MSX) [.dsk]\n")
		when 80 * 2 * 8 * 512 # 640KB 2DD
			$stdout.print("  ğŸ’¾ ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2DD(640KB) [.2dd]\n")
		when 40 * 2 * 8 * 512 # 320KB 2D
			$stdout.print("  ğŸ’¾ ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2D(320KB) [.2d]\n")
		when 40 * 1 * 8 * 512 # 160KB 1D
			$stdout.print("  ğŸ’¾ ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 1D(160KB) [.1d]\n")
		else
			$stdout.print("  ğŸ’¾ ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ [.xdf]\n")
		end

		image = XDF.new(data:filedata)
		image.report_all

	else
		$stdout.print("  â“ å½¢å¼ä¸æ˜(#{filedata.length}ãƒã‚¤ãƒˆ)\n")
	end
end

# .dim â†’ .xdf å¤‰æ›
def strip_dim(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze
	outfilename = filename + ".xdf"

	if !DIM.image?(filedata)
		$stderr.print("#{ProgName}: DIFC.Xå½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“: #{filename}\n")
		return
	end

	case filedata.length
	when 256 + 77 * 2 * 8 * 1024 # 1261824
		data = filedata[256, 77 * 2 * 8 * 1024]

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	when 256 + 80 * 2 * 8 * 1024 # 1310976
		data = filedata[256, 77 * 2 * 8 * 1024]
		data2 = filedata[256 + 77 * 2 * 8 * 1024, (80 - 77) * 2 * 8 * 1024]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™: #{filename}\n")
			return
		end

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	when 256 + 85 * 2 * 8 * 1024 # 1392896
		data = filedata[256, 77 * 2 * 8 * 1024]
		data2 = filedata[256 + 77 * 2 * 8 * 1024, (85 - 77) * 2 * 8 * 1024]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™: #{filename}\n")
			return
		end

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	else
		$stdout.print("  å½¢å¼ä¸æ˜(#{filedata.length}ãƒã‚¤ãƒˆ)\n")
	end
end

# 9ã‚»ã‚¯ã‚¿2DD(720KB)ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã®å„ãƒˆãƒ©ãƒƒã‚¯ã®9ã‚»ã‚¯ã‚¿ç›®ã‚’åˆ‡ã‚Šæ¨ã¦ã¦8ã‚»ã‚¯ã‚¿2DD(640KB)ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã«ã™ã‚‹
def truncate_9(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze

	if filedata.length == 80 * 2 * 9 * 512
		outdata = ""
		(0 ... 80 * 2).each do |track|
			outdata += filedata[track * 9 * 512, 8 * 512]
		end

		outfilename = filename + ".xdf"
		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, outdata)
	elsif D88.image?(filedata) && filedata[0x1b].to_byte == 0x10
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find { |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4
		track_offsets = track_offsets.first(header_tracks)

		outdata = filedata[0, header_size]
		(0 ... header_tracks).each do |track|
			track_offset = track_offsets[track]
			if track_offset != 0
				outdata[0x20 + 4 * track, 4] = [outdata.length].pack("V")

				(0 ... 8).each do |r|
					data = filedata[track_offset + 0x210 * r, 0x210]
					fail if data[4, 2].to_word != 9
					data[4, 2] = [8].pack("v")
					outdata += data
				end
			end
		end

		outdata[0x1c, 4] = [outdata.length].pack("V") # Disk size

		outfilename = filename + ".d88"
		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, outdata)
	else
		$stdout.print("  å½¢å¼ä¸æ˜(#{filedata.length}ãƒã‚¤ãƒˆ)\n")
	end
end

def main(args)
	action = :identify

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] file..."

		opt.on("--strip-dim",
		".dim â†’ .xdf å¤‰æ›") do
			action = :strip_dim
		end

		opt.on("--truncate_9",
		"9ã‚»ã‚¯ã‚¿ç›®ã‚’åˆ‡ã‚Šæ¨ã¦") do
			action = :truncate_9
		end

		opt.parse!
		print(opt.help)  if args.empty?
	end

	args.each do |an_arg|
		if !File.exist?(an_arg)
			$stderr.print("#{ProgName}: File not found: #{an_arg}\n")
			break
		end

		case action
		when :identify
			fdimageid(an_arg)
		when :strip_dim
			strip_dim(an_arg)
		when :truncate_9
			truncate_9(an_arg)
		end
	end

	return 0
end

exit main(ARGV)
