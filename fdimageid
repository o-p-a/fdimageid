#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# フロッピーディスクイメージファイルの識別
#
# 2024/09/14 opa⁠🙂
#----------------------------------------------------------------

require "optparse"
require "pp"

ProgName = "fdimageid"
Version = "0.01"
#=====dpk===== Copyright2024
Copyright = "Copyright (c) 2024 by opa"
#=====dpk=====

class String
	def to_byte;	unpack("C")[0];	end
	def to_word;	unpack("v")[0];	end
	def to_dword;	unpack("V")[0];	end

	def to_bytes;	unpack("C*");	end
	def to_words;	unpack("v*");	end
	def to_dwords;	unpack("V*");	end
end

class Integer
	def to_hex;	"#{to_s(16)}h";	end
end

def read_file(filename, offset=0, length=nil)
	return IO.binread(filename, length, offset)
end

def write_file(filename, data)
	return IO.binwrite(filename, data)
end

class DiskImage
	attr_accessor(:mediatype, :track, :writeprotect, :comment)

	def initialize(filename:nil, data:nil)
		clear

		if filename
			data = read_file(filename)
		end

		if data
			load(data)
		end
	end

	def clear
		@mediatype = nil # :"1d", :"1dd", :"2d", :"2dd", :"2hd", :unknown
		@track = []
		@writeprotect = nil # true:Write Protected false:Writeable
		@comment = nil
	end

	def to_h
		return {
			mediatype: @mediatype,
			track: @track.map{ |t| t && t.to_h },
			writeprotect: @writeprotect,
			comment: @comment,
		}
	end

	class Track
		attr_accessor(:sector)

		def initialize
			clear
		end

		def clear
			@sector = []
		end

		def to_h
			return {
				sector: @sector.map{ |r| r && r.to_h },
			}
		end

		# トラックに含まれるセクタ数
		def nsectors
			return @sector.length
		end
	end

	class Sector
		attr_accessor(:data, :c, :h, :r, :n, :mfm, :ddam, :cmd, :status, :st0, :st1, :st2, :pda)

		def initialize
			clear
		end

		def clear
			@data = nil
			@c = nil
			@h = nil
			@r = nil
			@n = nil
			@mfm = nil		# false:FM true:MFM
			@ddam = nil		# false:DAM true:DDAM
			@cmd = nil		# BIOS Read Data Command
			@status = nil	# BIOS Read Data Status 0:Normal Terminate
			@st0 = nil		# ST0
			@st1 = nil		# ST1
			@st2 = nil		# ST2
			@pda = nil		# PDA 0x90:1.2M 0x30:1.44M 0x10:640K
		end

		def to_h
			return {
				data: @data,
				c: @c,
				h: @h,
				r: @r,
				n: @n,
				mfm: @mfm,
				ddam: @ddam,
				cmd: @cmd,
				status: @status,
				st0: @st0,
				st1: @st1,
				st2: @st2,
				pda: @pda,
			}
		end
	end

	# データのある最終トラック番号
	def ntracks
		last_empty_track_count = @track.reverse.find_index { |t| !t.nil? }
		if last_empty_track_count
			return @track.length - last_empty_track_count
		else
			return 0 # データの有るトラックが無い
		end
	end

	# データのあるトラック数
	def xtracks
		return @track.count { |t| !t.nil? }
	end

	# 全データをCHRN順に連結したもの
	def whole_data
	end

	def report_all
		if @comment && !@comment.empty?
			$stdout.print("  コメント: #{@comment.inspect}\n")
		end

		ntracks_std = 0
		if @mediatype
			case @mediatype
			when :"1d"
				mediatype_s = "1D"
				ntracks_std = 40
			when :"1dd"
				mediatype_s = "1DD"
				ntracks_std = 80
			when :"2d"
				mediatype_s = "2D"
				ntracks_std = 40 * 2
			when :"2dd"
				mediatype_s = "2DD"
				ntracks_std = 80 * 2
			when :"2hd"
				mediatype_s = "2HD"
				ntracks_std = 80 * 2 # or 77 * 2
			when :unknown
				mediatype_s = "不明なメディア"
			else
				mediatype_s = "メディアタイプ不正(#{@mediatype})"
			end
			$stdout.print("  メディア種別: #{mediatype_s}\n")
		end

		if !@writeprotect.nil?
			if @writeprotect
				$stdout.print("  書き込み禁止\n")
			else
				$stdout.print("  書き込み可\n")
			end
		end

		nsectors = {}
		sector_size = {}
		mfm_count = {}
		ddam_count = 0
		status_count = {}
		@track.each do |trk|
			next  if !trk

			nsec = trk.nsectors
			nsectors[nsec] ||= 0
			nsectors[nsec] += 1

			trk.sector.each do |sec|
				ssize = sec.data.length
				sector_size[ssize] ||= 0
				sector_size[ssize] += 1

				if !sec.mfm.nil?
					mfm_count[sec.mfm] ||= 0
					mfm_count[sec.mfm] += 1
				end

				if sec.ddam == true
					ddam_count += 1
				end

				if !sec.status.nil? && sec.status != 0
					status_count[sec.status] ||= 0
					status_count[sec.status] += 1
				end
			end
		end

		sector_size = sector_size.to_a.sort_by{ |e| e[1] }.reverse
		if !sector_size.empty?
			sector_size_s = "#{sector_size[0][0]}バイト"
			if sector_size.length >= 2
				sector_size_s += "(混在あり)"
			end
		else
			sector_size_s = "0バイト"
		end

		nsectors = nsectors.to_a.sort_by{ |e| e[1] }.reverse
		if !nsectors.empty?
			nsectors_s = "#{nsectors[0][0]}セクタ"
			if nsectors.length >= 2
				nsectors_s += "(混在あり)"
			end
		else
			nsectors_s = "0セクタ"
		end

		if @mediatype == :"2hd" && !sector_size.empty? && !nsectors.empty?
			if (sector_size[0][0] == 1024 && nsectors[0][0] == 8) ||
				(sector_size.length >= 2 && sector_size[0][0] == 256 && sector_size[1][0] == 128 && nsectors[0][0] == 26)

				ntracks_std = 77 * 2
			end
		end

		if(ntracks == xtracks)
			tracks_s = "#{ntracks}トラック"
		else
			tracks_s = "#{ntracks}(#{xtracks})トラック"
		end

		if ntracks == ntracks_std
			tracks_s += "(標準)"
		else
			tracks_s += "(標準は#{ntracks_std})"
		end

		$stdout.print("  #{sector_size_s} × #{nsectors_s} × #{tracks_s}\n")

		if mfm_count.length >= 2
			$stdout.print("  FM/MFM混在: FM:#{mfm_count[false]}セクタ MFM:#{mfm_count[true]}セクタ\n")
		end

		if ddam_count > 0
			$stdout.print("  Deleted Data Address Markの立ったセクタが#{ddam_count}個あります\n")
		end

		status_count = status_count.to_a.sort_by{ |e| e[1] }.reverse
		if !status_count.empty?
			status_count_s = "#{status_count[0][0].to_hex}が#{status_count[0][1]}個"
			status_count_s += " 他"  if status_count.length >= 2
			$stdout.print("  FDC Statusが0でないセクタがあります(#{status_count_s})\n")
		end
	end
end

# Virtual98(.fdd) ヘッダ+可変長データ https://www.pc98.org/project/doc/fdd.html
class V98FDD < DiskImage
	def self.image?(filedata)
		return filedata[0, 7] == "VFD1.00"
	end

	def load(filedata)
		clear
	end

	def dump
	end
end

# DIFC.X(.dim) ヘッダ(256バイト)+べたデータ https://stdkmd.net/xeij/source/FDMedia.htm
class DIM < DiskImage
	def self.image?(filedata)
		return filedata[171, 15] == "DIFC HEADER  \0\0"
	end

	def load(filedata)
		clear
	end

	def dump
	end
end

# T98Next R0(.nfd) ヘッダ(68112バイト)+べたデータ https://www.pc98.org/project/doc/nfdr0.txt
class NFD_R0 < DiskImage
	def self.image?(filedata)
		return filedata[0, 15] == "T98FDDIMAGE.R0\0"
	end

	def load(filedata)
		clear
	end

	def dump
	end
end

# T98Next R1(.nfd) ヘッダ(全体+セクタ+特殊読み込み)+データ https://www.pc98.org/project/doc/nfdr1.txt
class NFD_R1 < DiskImage
	def self.image?(filedata)
		return filedata[0, 15] == "T98FDDIMAGE.R1\0"
	end

	def load(filedata)
		clear
	end

	def dump
	end
end

# D88(.d88) ディスクヘッダ+セクタ毎に(ヘッダ+データ) https://www.pc98.org/project/doc/d88.html
class D88 < DiskImage
	def self.image?(filedata)
		return filedata[0x10, 10] == "\0" * 10 &&
			[0x00, 0x10, 0x20, 0x21, 0x30, 0x40].include?(filedata[0x1b].to_byte) &&
			filedata.length == filedata[0x1c, 4].to_dword
	end

	def load(filedata)
		clear

		# Media flag
		case filedata[0x1b].to_byte
		when 0x00 # 2D
			@mediatype = :"2d"
		when 0x10 # 2DD
			@mediatype = :"2dd"
		when 0x20 # 2HD
			@mediatype = :"2hd"
		when 0x21 # 2HD(1.44MB NP2kai)
			@mediatype = :"2hd"
		when 0x30 # 1D
			@mediatype = :"1d"
		when 0x40 # 1DD
			@mediatype = :"1dd"
		else
			$stdout.print("  メディアタイプ不明: #{filedata[0x1b].to_byte.to_hex}\n")
			@mediatype = :unknown
		end

		# Write protect flag
		@writeprotect = (filedata[0x1a].to_byte == 0) ? false : true

		# Disk name / comment
		@comment = filedata[0, 16].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		# Track data
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find { |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4 # 0x2b0(688byte:164entry) or 0x2a0(672byte:160entry)
		track_offsets = track_offsets.first(header_tracks)

		track_offsets.each.with_index do |track_offset, trkno|
			if track_offset == 0
				@track[trkno] = nil
			else
				trk = Track.new
				@track[trkno] = trk

				sector_offset = track_offset
				track_nsectors = nil
				begin
					w = Sector.new
					w.c, w.h, w.r, w.n, nsectors, w.mfm, w.ddam, w.status, rpm, datasize =
						filedata[sector_offset, 16].unpack("C4vC3x4Cv")
					sector_offset += 0x10

					if w.c > 90 || w.h > 1 || w.r > 32 || w.n > 6
						$stdout.print("  トラック#{trkno+1}のCHRN不正: #{w.c} #{w.h} #{w.r} #{w.n}\n")
						break  if w.n > 6 # 致命的なので後続処理中止
					end

					if nsectors > 32
						$stdout.print("  トラック#{trkno+1}のセクタ数不正: #{nsectors}\n")
					end

					if !track_nsectors
						track_nsectors = nsectors
					elsif track_nsectors != nsectors
						$stdout.print("  トラック#{trkno+1}の総セクタ数が統一されていない: #{track_nsectors} != #{nsectors}\n")
					end

					case w.mfm
					when 0x00 # double density
						w.mfm = true
					when 0x40 # single density
						w.mfm = false
					else
						$stdout.print("  トラック#{trkno+1}のDensity flag不正: #{w.mfm.to_hex}\n")
						w.mfm = nil
					end

					case w.ddam
					when 0x00 # normal
						w.ddam = false
					when 0x10 #deleted
						w.ddam = true
					else
						$stdout.print("  トラック#{trkno+1}のDDAM flag不正: #{w.ddam.to_hex}\n")
						w.ddam = nil
					end

					if rpm == 0 || rpm == 1
						# OK:NOP
					else
						$stdout.print("  トラック#{trkno+1}のNP2kai RPM不正: #{rpm}\n")
					end

					nsize = 128 << w.n
					if nsize != datasize
						$stdout.print("  トラック#{trkno+1}のセクタのN値とデータサイズが異なる: N:#{nsize} != #{datasize}\n")
					end

					w.data = filedata[sector_offset, nsize]
					sector_offset += nsize

					trk.sector << w
				end while trk.sector.length < nsectors

				next_track_start = (track_offsets[(trkno + 1) .. -1].find { |o| o != 0 }) || filedata.length
				if sector_offset != next_track_start
					if sector_offset < next_track_start
						$stdout.print("  トラック#{trkno+1}のデータの後に不要なデータがあります\n")
					else
						$stdout.print("  トラック#{trkno+1}のデータが次のトラックに達しています\n")
					end
				end
			end
		end
	end

	def dump
	end
end

# DCP/DCU(.dcu) ヘッダ(162バイト)+データ https://www.pc98.org/project/doc/dcp.html
class DCU < DiskImage
	HEADER_SIZE = 162

	def self.image?(filedata)
		track_map = filedata[1, 160].to_bytes
		track_map.each do |t|
			if t != 0 && t != 1
				return false
			end
		end

		media_type = filedata[0].to_byte
		if media_type == 0x01 && filedata.length == HEADER_SIZE + (1024 * 8 * 2 * 77) # 2HD(1.25MB 2HS)
			return true
		elsif media_type == 0x02 && filedata.length == HEADER_SIZE + (512 * 15 * 2 * 80) # 2HD(1.21MB 2HC)
			return true
		elsif media_type == 0x03 && filedata.length == HEADER_SIZE + (512 * 18 * 2 * 80) # 2HQ(1.44MB 2HDE)
			return true
		elsif media_type == 0x04 && filedata.length == HEADER_SIZE + (512 * 8 * 2 * 80) # 2DD(640KB)
			return true
		elsif media_type == 0x05 && filedata.length == HEADER_SIZE + (512 * 9 * 2 * 80) # 2DD(720KB)
			return true
		elsif media_type == 0x08 && filedata.length == HEADER_SIZE + (1024 * 9 * 2 * 80) # 2HD(1.44MB)
			return true
		elsif media_type == 0x11 && filedata.length == HEADER_SIZE + (128*26 + 256*26*153) # 2HD(Disk BASIC)
			return true
		elsif media_type == 0x19 && filedata.length == HEADER_SIZE + (256 * 16 * 2 * 80) # 2DD(Disk BASIC)
			return true
		elsif media_type == 0x21 && filedata.length == HEADER_SIZE + (256 * 26 * 2 * 80) # 2HD(26sector)
			return true
		end

		return false
	end

	def load(filedata)
		clear
	end

	def dump
	end
end

# Anex86(.fdi) ヘッダ(4096バイト)+べたデータ https://www.pc98.org/project/doc/hdi.html
class FDI < DiskImage
	def self.image?(filedata)
		return filedata[0, 4].to_dword == 0 &&
			[0x90, 0x30, 0x10].include?(filedata[4, 4].to_dword) &&
			filedata[0x8, 4].to_dword + filedata[0xc, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear
	end

	def dump
	end
end

# DIP(.dip) ヘッダ(256バイト)+べたデータ https://www.pc98.org/project/doc/dip.html
class DIP < DiskImage
	def self.image?(filedata)
		return filedata[0, 8] == "\x01\x08\x00\x13\x41\x00\x01\x00" &&
			filedata.length == 256 + (1024 * 8 * 2 * 77)
	end

	def load(filedata)
		clear
	end

	def dump
	end
end

# SL9821(.slf) フォーマットヘッダ(16バイト)+トラックヘッダ(80*2*32=5120バイト)+データ https://www.satotomi.com/pifdc/pifdc_slf.html
class SLF < DiskImage
	def self.image?(filedata)
		return filedata[0, 4] == "FDIM" &&
			filedata[4, 4].to_dword == 0x10000 &&
			filedata[8, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear
	end

	def dump
	end
end

# XDF(.xdf) べたデータ
class XDF < DiskImage
	Geometries = [
		#   siz    media  cyls heads  nsec ssize  ssize  nsec  head   cyl
		[1474560, :"2hd",   80,    2,   18,  512],	# 1.44MB 2HD
		[1474560, :"2hd",   80,    2,    9, 1024],	# 1.44MB 2HD
		[1261568, :"2hd",   77,    2,    8, 1024],	# 1.23MB 2HD
		[1228800, :"2hd",   80,    2,   15,  512],	# 1.2MB 2HD
		[1064960, :"2hd",   80,    2,   26,  256],	# 1.04MB 2HD
		[1021696, :"2hd",   77,    2,   26,  256],	# DISK BASIC 2HD
		[ 819200, :"2dd",   80,    2,   10,  512],	# 800KB 2DD
		[ 737280, :"2dd",   80,    2,    9,  512],	# 720KB 2DD
		[ 655360, :"2dd",   80,    2,    8,  512],	# 640KB 2DD
		[ 655360, :"2dd",   80,    2,   16,  256],	# DISK BASIC 2DD
		[ 327680, :"2d",    40,    2,    8,  512],	# 320KB 2D
		[ 327680, :"1dd",   80,    1,    8,  512],	# 320KB 1DD
		[ 163840, :"1d",    40,    1,    8,  512],	# 160KB 1D
	]

	def self.image?(filedata)
		return Geometries.find{ |g| g[0] == filedata.length } ? true : false
	end

	def load(filedata)
		clear

		geom = Geometries.find{ |g| g[0] == filedata.length }
		@mediatype, cyls, heads, nsecs, ssize = geom[1 .. 5]

		offset = 0
		(1 .. cyls).each do |cyl|
			(1 .. heads).each do |head|
				trkno = (cyl - 1) * heads + (head - 1)
				trk = Track.new
				@track[trkno] = trk
				(1 .. nsecs).each do |sec|
					w = Sector.new
					w.c = cyl - 1 # シリンダは0オリジン
					w.h = head - 1 # ヘッドは0オリジン
					w.r = sec # レコードは1オリジン
					w.n = (ssize / 128).bit_length - 1
					w.data = filedata[offset, ssize]
					offset += ssize
					trk.sector << w
				end
			end
		end
	end

	def dump
	end
end

def same_data_msg(from_track, to_track, value)
	if from_track == to_track
		$stdout.print("  トラック#{from_track}は全て#{value.ord.to_hex}です\n")
	else
		$stdout.print("  トラック#{from_track}～#{to_track}は全て#{value.ord.to_hex}です\n")
	end
end

# トラックのデータの状況
def track_report(filedata, sector_byte = 1024, nsectors = 8, ntracks = 2 * 77)
	track_length = sector_byte * nsectors
	$stdout.print("  #{sector_byte}バイト × #{nsectors}セクタ × #{ntracks}トラック\n")

	filled_data_value = nil
	filled_data_from = nil
	(0 ... ntracks).each do |track|
		track_data = filedata[track * track_length, track_length]
		if track_data == track_data[0] * track_data.length
			if track_data[0] == filled_data_value
				# NOP (同データが継続)
			else
				if filled_data_value
					same_data_msg(filled_data_from + 1, track, filled_data_value)
				end
				filled_data_value = track_data[0]
				filled_data_from = track
			end
		elsif filled_data_value
			same_data_msg(filled_data_from + 1, track, filled_data_value)
			filled_data_value = nil
		end
	end
	if filled_data_value
		same_data_msg(filled_data_from + 1, ntracks, filled_data_value)
	end
end

def fdimageid(filename)
	filedata = read_file(filename).freeze
	filesize = filedata.length

	case
	# Virtual98(.fdd)
	when V98FDD.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  Virtual98形式 [.fdd]\n")

	# DIFC.X(.dim)
	when DIM.image?(filedata)
		$stdout.print("#{filename}:\n")

		# DIFC.X version
		difc_ver = filedata[0xfe].to_byte

		$stdout.print("  X68000 DIFC.X形式(v#{difc_ver}) [.dim]\n")

		# フォーマット種別
		format_flag = filedata[0].to_byte
		case format_flag
		when 0x00
			format_flag_s = "00h: 2HD(1.23MB)"
			ntracks_std = 154
			track_length = 1024 * 8
		when 0x01
			format_flag_s = "01h: 2HS(1.44MB)"
			ntracks_std = 160
			track_length = 1024 * 9
		when 0x02
			format_flag_s = "02h: 2HC(1.2MB)"
			ntracks_std = 160
			track_length = 512 * 15
		when 0x03
			format_flag_s = "03h: 2HDE(1.44MB)"
			ntracks_std = 160
			track_length = 1024 * 9
		when 0x09
			format_flag_s = "09h: 2HQ(1.44MB)"
			ntracks_std = 160
			track_length = 512 * 18
		else
			format_flag_s = "不明(#{format_flag.to_hex})"
			ntracks_std = 0
			track_length = 0
		end

		$stdout.print("  フォーマット種別: #{format_flag_s}\n")
		$stdout.print("  #{track_length}バイト/トラック\n")

		# 総トラック数 (0の場合もある)
		ntracks = filedata[0xff].to_byte
		$stdout.print("  ヘッダのトラック数: #{ntracks}トラック\n")  if ntracks > 0

		# トラックの保存状態
		xtracks = 0
		filled_data_value = nil
		filled_data_from = nil
		filedata[1, 170].to_bytes.each.with_index(1) do |flag, track|
			case flag
			when 0 # なし
				if filled_data_value
					same_data_msg(filled_data_from, track-1, filled_data_value)
					filled_data_value = nil
				end
			when 1 # あり
				track_data = filedata[256 + xtracks * track_length, track_length]
				xtracks += 1
				if track_data == track_data[0] * track_data.length
					if track_data[0] == filled_data_value
						# NOP (同データが継続)
					else
						if filled_data_value
							same_data_msg(filled_data_from, track-1, filled_data_value)
						end
						filled_data_value = track_data[0]
						filled_data_from = track
					end
				elsif filled_data_value
					same_data_msg(filled_data_from, track-1, filled_data_value)
					filled_data_value = nil
				end
			else
				$stderr.print("#{ProgName}: トラック保存状態が不正: #{flag}\n")
			end
		end
		if filled_data_value
			same_data_msg(filled_data_from, 170, filled_data_value)
		end

		if xtracks == ntracks_std
			$stdout.print("  #{xtracks}トラック(標準)のデータが格納されています\n")
		else
			$stdout.print("  #{xtracks}トラック分のデータが格納されています(標準は#{ntracks_std})\n")
		end

		if filesize != 256 + xtracks * track_length
			$stdout.print("  ファイルサイズが不正(#{filesize}バイト)\n")
		end

	# T98Next R0(.nfd)
	when NFD_R0.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  T98-Next NFD r0形式 [.nfd]\n")

		szComment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		flProtect = filedata[0x10 + 0x100 + 4].to_byte

		$stdout.print("  コメント: #{szComment.inspect}\n")  if !szComment.empty?
		$stdout.print("  ヘッダサイズ: #{dwHeadSize}バイト\n")
		$stdout.print("  読み取り専用\n")  if flProtect != 0

		trackInfo = []
		(0 ... 163).each do |track|
			trackInfo[track] = { sectorInfo:[] }
			(0 ... 26).each do |sector|
				w = {}
				w[:c], w[:h], w[:r], w[:n], w[:flMFM], w[:flDDAM], w[:byStatus], w[:byST0], w[:byST1], w[:byST2], w[:byPDA] =
					filedata[0x10 + 0x100 + 0x10 + (track * 26 + sector) * 0x10, 11].unpack("C11")
				w[:byST0] &= 0xfb # Head Address は無視
				trackInfo[track][:sectorInfo] << w  if w[:c] != 0xff
			end
		end

		minval = {}
		maxval = {}
		minnsec = nil
		maxnsec = nil
		trackInfo.each do |ti|
			next  if ti[:sectorInfo].empty?

			ti[:sectorInfo].each do |si|
				[:c, :h, :r, :n, :flMFM, :flDDAM, :byStatus, :byST0, :byST1, :byST2, :byPDA].each do |member|
					minval[member] = si[member]  if !minval[member] || minval[member] > si[member]
					maxval[member] = si[member]  if !maxval[member] || maxval[member] < si[member]
				end
			end
			minnsec = ti[:sectorInfo].length  if !minnsec || minnsec > ti[:sectorInfo].length
			maxnsec = ti[:sectorInfo].length  if !maxnsec || maxnsec < ti[:sectorInfo].length
		end

		ntracks = trackInfo.count { |ti| !ti[:sectorInfo].empty? }
		ntracks_s = "#{ntracks}トラック"

		sector_size = 128 << maxval[:n]
		if maxval[:n] == minval[:n]
			sector_size_s = "#{sector_size}バイト"
		else
			sector_size_s = "#{sector_size}バイト(混在あり)"
		end

		nsectors = maxnsec
		if maxnsec == minnsec
			nsectors_s = "#{nsectors}セクタ"
		else
			nsectors_s = "#{nsectors}セクタ(混在あり)"
		end

		byPDA = maxval[:byPDA]
		case byPDA
		when 0x90
			byPDA_s = "90h: 2HD(1.2MB)"
		when 0x30
			byPDA_s = "30h: 2HD(1.44MB)"
		when 0x10
			byPDA_s = "10h: 2DD(640KB)"
		else
			byPDA_s = "#{byPDA.to_hex}"
		end
		if maxval[:byPDA] != minval[:byPDA]
			byPDA_s += "(混在)"
		end

		$stdout.print("  #{sector_size_s} × #{nsectors_s} × #{ntracks_s}\n")
		$stdout.print("  FM/MFM混在\n")  if maxval[:flMFM] != minval[:flMFM]
		$stdout.print("  Deleted Data Address Markの立ったセクタがあります\n")  if maxval[:flDDAM] != 0
		$stdout.print("  BIOS Resultが0以外のセクタがあります\n")  if maxval[:byStatus] != 0
		$stdout.print("  FDC Store Status 0が0以外のセクタがあります\n")  if maxval[:byST0] != 0
		$stdout.print("  FDC Store Status 1が0以外のセクタがあります\n")  if maxval[:byST1] != 0
		$stdout.print("  FDC Store Status 2が0以外のセクタがあります\n")  if maxval[:byST2] != 0
		$stdout.print("  PDAデバイスアドレス: #{byPDA_s}\n")

	# T98Next R1(.nfd)
	when NFD_R1.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  T98-Next NFD r1形式 [.nfd]\n")

		szComment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		flProtect = filedata[0x10 + 0x100 + 4].to_byte

		$stdout.print("  コメント: #{szComment.inspect}\n")  if !szComment.empty?
		$stdout.print("  ヘッダサイズ: #{dwHeadSize}バイト\n")
		$stdout.print("  読み取り専用\n")  if flProtect != 0

		trackInfo = []
		dwTrackHead = filedata[0x10 + 0x100 + 0x10, 4 * 164].to_dwords
		(0 ... dwTrackHead.length).each do |track|
			track_offset = dwTrackHead[track]
			next  if track_offset == 0

			wSector, wDiag = filedata[track_offset, 2 * 2].to_words
			trackInfo[track] = { sectorInfo:[], diagInfo:[] }

			(0 ... wSector).each do |sector|
				w = {}
				w[:c], w[:h], w[:r], w[:n], w[:flMFM], w[:flDDAM], w[:byStatus], w[:bySTS0], w[:bySTS1], w[:bySTS2], w[:byRetry], w[:byPDA] =
					filedata[track_offset + 0x10 + sector * 0x10, 12].unpack("C12")
				w[:bySTS0] &= 0xfb # Head Address は無視
				trackInfo[track][:sectorInfo] << w
			end

			(0 ... wDiag).each do |diag|
				w = {}
				w[:cmd], w[:c], w[:h], w[:r], w[:n], w[:byStatus], w[:bySTS0], w[:bySTS1], w[:bySTS2], w[:byRetry], w[:dwDataLen], w[:byPDA] =
					filedata[track_offset + 0x10 + wSector * 0x10 + diag * 0x10, 15].unpack("C10VC")
				trackInfo[track][:diagInfo] << w
			end
		end

		minval = {}
		maxval = {}
		minnsec = nil
		maxnsec = nil
		trackInfo.each do |ti|
			ti[:sectorInfo].each do |si|
				[:c, :h, :r, :n, :flMFM, :flDDAM, :byStatus, :bySTS0, :bySTS1, :bySTS2, :byRetry, :byPDA].each do |member|
					minval[member] = si[member]  if !minval[member] || minval[member] > si[member]
					maxval[member] = si[member]  if !maxval[member] || maxval[member] < si[member]
				end
			end
			minnsec = ti[:sectorInfo].length  if !minnsec || minnsec > ti[:sectorInfo].length
			maxnsec = ti[:sectorInfo].length  if !maxnsec || maxnsec < ti[:sectorInfo].length

			ti[:diagInfo].each do |di|
				$stdout.print("  特殊読み込みセクタ: Cmd:#{di[:cmd]} C:#{di[:c]} H:#{di[:h]} R:#{di[:r]} N:#{di[:n]} STS:#{di[:bySTS0]},#{di[:bySTS1]},#{di[:bySTS2]} Status:#{di[:byStatus]} Retry:#{di[:byRetry]} DataLen:#{di[:dwDataLen]}\n")
			end
		end

		ntracks = trackInfo.length
		ntracks_s = "#{ntracks}トラック"

		sector_size = 128 << maxval[:n]
		if maxval[:n] == minval[:n]
			sector_size_s = "#{sector_size}バイト"
		else
			sector_size_s = "#{sector_size}バイト(混在あり)"
		end

		nsectors = maxnsec
		if maxnsec == minnsec
			nsectors_s = "#{nsectors}セクタ"
		else
			nsectors_s = "#{nsectors}セクタ(混在あり)"
		end

		$stdout.print("  #{sector_size_s} × #{nsectors_s} × #{ntracks_s}\n")
		$stdout.print("  FM/MFM混在\n")  if maxval[:flMFM] != minval[:flMFM]
		$stdout.print("  Deleted Data Address Markの立ったセクタがあります\n")  if maxval[:flDDAM] != 0
		$stdout.print("  BIOS Resultが0以外のセクタがあります\n")  if maxval[:byStatus] != 0
		$stdout.print("  FDC Store Status 0が0以外のセクタがあります\n")  if maxval[:bySTS0] != 0
		$stdout.print("  FDC Store Status 1が0以外のセクタがあります\n")  if maxval[:bySTS1] != 0
		$stdout.print("  FDC Store Status 2が0以外のセクタがあります\n")  if maxval[:bySTS2] != 0
		$stdout.print("  不安定データセクタがあります\n")  if maxval[:byRetry] != 0
		$stdout.print("  PDAデバイスアドレスが0以外のセクタがあります\n")  if maxval[:byPDA] != 0

	# D88(.d88)
	when D88.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  D88形式 [.d88 .d98 .88d .98d]\n")

		image = D88.new(data:filedata)
		image.report_all

	# DCP/DCU(.dcu)
	when DCU.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  DCP/DCU形式 [.dcu .dcp]\n")

		media_type = filedata[0].to_byte
		case media_type
		when 0x01
			media_type_s = "01h: 2HD(1.25MB 2HS)"
		when 0x02
			media_type_s = "02h: 2HD(1.21MB 2HC)"
		when 0x03
			media_type_s = "03h: 2HQ(1.44MB 2HDE)"
		when 0x04
			media_type_s = "04h: 2DD(640KB)"
		when 0x05
			media_type_s = "05h: 2DD(720KB)"
		when 0x08
			media_type_s = "08h: 2HD(1.44MB)"
		when 0x11
			media_type_s = "11h: 2HD(Disk BASIC)"
		when 0x19
			media_type_s = "19h: 2DD(Disk BASIC)"
		when 0x21
			media_type_s = "21h: 2HD(26sector)"
		else
			media_type_s = "不明(#{media_type.to_hex})"
		end

		$stdout.print("  メディアタイプ: #{media_type_s}\n")

		track_map = filedata[1, 160].to_bytes
		all_cylinders_stored = filedata[0xa1].to_byte

	# Anex86(.fdi)
	when FDI.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  Anex86形式 [.fdi]\n")

		fddtype_id = filedata[4, 4].to_dword
		case fddtype_id
		when 0x90
			fddtype_id_s = "90h: 2HD(1.2MB)"
		when 0x30
			fddtype_id_s = "30h: 2HD(1.44MB)"
		when 0x10
			fddtype_id_s = "10h: 2DD"
		else
			fddtype_id_s = "#{fddtype_id.to_hex}"
		end

		headersize = filedata[0x8, 4].to_dword

		datasize = filedata[0xc, 4].to_dword
		case datasize
		when 1474560
			datasize_s = " 2HD(1.44MB)"
		when 1261568
			datasize_s = " 2HD(1.23MB)"
		when 1228800
			datasize_s = " 2HD(1.2MB)"
		when 737280
			datasize_s = " 2DD(720KB)"
		when 655360
			datasize_s = " 2DD(640KB)"
		else
			datasize_s = ""
		end

		$stdout.print("  FDD Type: #{fddtype_id_s}\n")
		$stdout.print("  ヘッダサイズ: #{headersize}バイト\n")
		$stdout.print("  データサイズ: #{datasize}バイト#{datasize_s}\n")

	# DIP(.dip)
	when DIP.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  DIP形式 [.dip]\n")

	# SL9821(.slf)
	when SLF.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  SL9821形式 [.slf]\n")

	# XDF(.xdf)
	when XDF.image?(filedata)
		$stdout.print("#{filename}:\n")

		case filesize
		when 512 * 18 * 2 * 80 # 1.44MB 2HD
			$stdout.print("  べたイメージ 2HD(1.44MB PC/AT) [.2hd]\n")
		when 1024 * 8 * 2 * 77 # 1.23MB 2HD
			$stdout.print("  べたイメージ 2HD(1.23MB PC98) [.xdf .2hd .dup .hdm .tfd]\n")
		when 512 * 15 * 2 * 80 # 1.2MB 2HD
			$stdout.print("  べたイメージ 2HD(1.2MB PC/AT) [.2hd]\n")
		when 512 * 9 * 2 * 80 # 720KB 2DD
			$stdout.print("  べたイメージ 2DD(720KB MSX) [.dsk]\n")
		when 512 * 8 * 2 * 80 # 640KB 2DD
			$stdout.print("  べたイメージ 2DD(640KB) [.2dd]\n")
		when 512 * 8 * 2 * 40 # 320KB 2D
			$stdout.print("  べたイメージ 2D(320KB) [.2d]\n")
		when 512 * 8 * 1 * 40 # 160KB 1D
			$stdout.print("  べたイメージ 1D(160KB) [.1d]\n")
		else
			$stdout.print("  べたイメージ [.xdf]\n")
		end

		image = XDF.new(data:filedata)
		image.report_all

	else
		$stdout.print("#{filename}:\n  不明な形式 (#{filesize}バイト)\n")
	end
end

# .dim → .xdf 変換
def strip_dim(filename)
	if !DIM.image?(filedata)
		$stderr.print("#{ProgName}: DIFC.X形式ではありません: #{filename}\n")
		return
	end

	$stdout.print("#{filename}:\n")

	filedata = read_file(filename)
	filesize = filedata.length
	outfilename = filename + ".xdf"

	if filesize == 256 + 1024 * 8 * 2 * 77 # 1261824
		data = filedata[256, 1024 * 8 * 2 * 77]

		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, data)
	elsif filesize == 256 + 1024 * 8 * 2 * 80 # 1310976
		data = filedata[256, 1024 * 8 * 2 * 77]
		data2 = filedata[256 + 1024 * 8 * 2 * 77, 1024 * 8 * 2 * (80 - 77)]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: オーバートラックデータがあります: #{filename}\n")
			return
		end

		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, data)
	elsif filesize == 256 + 1024 * 8 * 2 * 85 # 1392896
		data = filedata[256, 1024 * 8 * 2 * 77]
		data2 = filedata[256 + 1024 * 8 * 2 * 77, 1024 * 8 * 2 * (85 - 77)]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: オーバートラックデータがあります: #{filename}\n")
			return
		end

		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, data)
	else
		$stdout.print("  不明な形式 (#{filesize}バイト)\n")
	end
end

# 9セクタ2DD(720KB)のイメージの各トラックの9セクタ目を切り捨てて8セクタ2DD(640KB)のイメージにする
def truncate_9(filename)
	filedata = read_file(filename)
	filesize = filedata.length

	$stdout.print("#{filename}:\n")

	if filesize == 512 * 9 * 2 * 80
		outdata = ""
		(0 ... 2 * 80).each do |track|
			outdata += filedata[512 * 9 * track, 512 * 8]
		end

		outfilename = filename + ".xdf"
		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, outdata)
	elsif D88.image?(filedata) && filedata[0x1b].to_byte == 0x10
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find { |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4
		track_offsets = track_offsets.first(header_tracks)

		outdata = filedata[0, header_size]
		(0 ... header_tracks).each do |track|
			track_offset = track_offsets[track]
			if track_offset != 0
				outdata[0x20 + 4 * track, 4] = [outdata.length].pack("V")

				(0 ... 8).each do |r|
					data = filedata[track_offset + 0x210 * r, 0x210]
					fail if data[4, 2].to_word != 9
					data[4, 2] = [8].pack("v")
					outdata += data
				end
			end
		end

		outdata[0x1c, 4] = [outdata.length].pack("V") # Disk size

		outfilename = filename + ".d88"
		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, outdata)
	else
		$stdout.print("  不明な形式 (#{filesize}バイト)\n")
	end
end

def main(args)
	action = :identify

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] file..."

		opt.on("--strip-dim",
		".dim → .xdf 変換") do
			action = :strip_dim
		end

		opt.on("--truncate_9",
		"9セクタ目を切り捨て") do
			action = :truncate_9
		end

		opt.parse!
		print(opt.help)  if args.empty?
	end

	args.each do |an_arg|
		if !File.exist?(an_arg)
			$stderr.print("#{ProgName}: File not found: #{an_arg}\n")
			break
		end

		case action
		when :identify
			fdimageid(an_arg)
		when :strip_dim
			strip_dim(an_arg)
		when :truncate_9
			truncate_9(an_arg)
		end
	end

	return 0
end

exit main(ARGV)
