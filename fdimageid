#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# ãƒ•ãƒ­ãƒƒãƒ”ãƒ¼ãƒ‡ã‚£ã‚¹ã‚¯ã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®è­˜åˆ¥
#
# 2024/09/14 opaâ ğŸ™‚
#----------------------------------------------------------------

require "optparse"
require "pp"

ProgName = "fdimageid"
Version = "0.01"
#=====dpk===== Copyright2024
Copyright = "Copyright (c) 2024 by opa"
#=====dpk=====

class String
	def to_byte;	unpack("C")[0];	end
	def to_word;	unpack("v")[0];	end
	def to_dword;	unpack("V")[0];	end

	def to_bytes;	unpack("C*");	end
	def to_words;	unpack("v*");	end
	def to_dwords;	unpack("V*");	end
end

class Integer
	def to_hex;	"#{to_s(16)}h";	end
end

def read_file(filename, offset=0, length=nil)
	return IO.binread(filename, length, offset)
end

def write_file(filename, data)
	return IO.binwrite(filename, data)
end

class DiskImage
	def initialize
		@mediatype = nil # :"1d", :"1dd", :"2d", :"2dd", :"2hd", :unknown
		@track = []
		@writeprotect = nil # true:Write Protected false:Writeable
		@comment = nil
	end

	attr_accessor(:mediatype, :track, :writeprotect, :comment)

	def to_h
		return {
			mediatype: mediatype,
			track: track.map{ |t| t && t.to_h },
			writeprotect: writeprotect,
			comment: comment,
		}
	end

	class Track
		def initialize
			@sector = []
		end

		attr_accessor(:sector)

		def to_h
			return {
				sector: sector.map{ |r| r && r.to_h },
			}
		end

		# ãƒˆãƒ©ãƒƒã‚¯ã«å«ã¾ã‚Œã‚‹ã‚»ã‚¯ã‚¿æ•°
		def nsectors
			return sector.length
		end
	end

	class Sector
		def initialize
			@data = nil
			@c = nil
			@h = nil
			@r = nil
			@n = nil
			@mfm = nil		# false:FM true:MFM
			@ddam = nil		# false:DAM true:DDAM
			@cmd = nil		# BIOS Read Data Command
			@status = nil	# BIOS Read Data Status 0:Normal Terminate
			@st0 = nil		# ST0
			@st1 = nil		# ST1
			@st2 = nil		# ST2
			@pda = nil		# PDA 0x90:1.2M 0x30:1.44M 0x10:640K
		end

		attr_accessor(:data, :c, :h, :r, :n, :mfm, :ddam, :cmd, :status, :st0, :st1, :st2, :pda)

		def to_h
			return {
				data: data,
				c: c,
				h: h,
				r: r,
				n: n,
				mfm: mfm,
				ddam: ddam,
				cmd: cmd,
				status: status,
				st0: st0,
				st1: st1,
				st2: st2,
				pda: pda,
			}
		end
	end

	# ãƒ‡ãƒ¼ã‚¿ã®ã‚ã‚‹æœ€çµ‚ãƒˆãƒ©ãƒƒã‚¯ç•ªå·
	def ntracks
		last_empty_tracks = track.reverse.find_index { |t| !t.nil? }
		if last_empty_tracks
			return track.length - last_empty_tracks
		else
			return 0 # ãƒ‡ãƒ¼ã‚¿ã®æœ‰ã‚‹ãƒˆãƒ©ãƒƒã‚¯ãŒç„¡ã„
		end
	end

	# ãƒ‡ãƒ¼ã‚¿ã®ã‚ã‚‹ãƒˆãƒ©ãƒƒã‚¯æ•°
	def xtracks
		return track.count { |t| !t.nil? }
	end

	def report_all
		if comment && !comment.empty?
			$stdout.print("  ã‚³ãƒ¡ãƒ³ãƒˆ: #{comment.inspect}\n")
		end

		if mediatype
			case mediatype
			when :"1d"
				mediatype_s = "1D"
				ntracks_std = 40
			when :"1dd"
				mediatype_s = "1DD"
				ntracks_std = 80
			when :"2d"
				mediatype_s = "2D"
				ntracks_std = 80
			when :"2dd"
				mediatype_s = "2DD"
				ntracks_std = 160
			when :"2hd"
				mediatype_s = "2HD"
				ntracks_std = 154
			when :unknown
				mediatype_s = "ä¸æ˜ãªãƒ¡ãƒ‡ã‚£ã‚¢"
				ntracks_std = 0
			else
				mediatype_s = "ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ­£(#{mediatype})"
				ntracks_std = 0
			end
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ç¨®åˆ¥: #{mediatype_s}\n")
		end

		if !writeprotect.nil?
			if writeprotect
				$stdout.print("  æ›¸ãè¾¼ã¿ç¦æ­¢\n")
			else
				$stdout.print("  æ›¸ãè¾¼ã¿å¯\n")
			end
		end

		if(ntracks == xtracks)
			tracks_s = "#{ntracks}ãƒˆãƒ©ãƒƒã‚¯"
		else
			tracks_s = "#{ntracks}(#{xtracks})ãƒˆãƒ©ãƒƒã‚¯"
		end

		if ntracks == ntracks_std
			tracks_s += "(æ¨™æº–)"
		else
			tracks_s += "(æ¨™æº–ã¯#{ntracks_std})"
		end

		nsectors = {}
		sector_size = {}
		mfm_count = {}
		ddam_count = 0
		status_count = {}
		track.each do |trk|
			next  if !trk

			nsec = trk.nsectors
			nsectors[nsec] ||= 0
			nsectors[nsec] += 1

			trk.sector.each do |sec|
				ssize = sec.data.length
				sector_size[ssize] ||= 0
				sector_size[ssize] += 1

				if !sec.mfm.nil?
					mfm_count[sec.mfm] ||= 0
					mfm_count[sec.mfm] += 1
				end

				if sec.ddam == true
					ddam_count += 1
				end

				if !sec.status.nil? && sec.status != 0
					status_count[sec.status] ||= 0
					status_count[sec.status] += 1
				end
			end
		end

		sector_size = sector_size.to_a.sort_by{ |e| e[1] }.reverse
		sector_size_s = "#{sector_size[0][0]}ãƒã‚¤ãƒˆ"
		if sector_size.length >= 2
			sector_size_s += "(æ··åœ¨ã‚ã‚Š)"
		end

		nsectors = nsectors.to_a.sort_by{ |e| e[1] }.reverse
		nsectors_s = "#{nsectors[0][0]}ã‚»ã‚¯ã‚¿"
		if nsectors.length >= 2
			nsectors_s += "(æ··åœ¨ã‚ã‚Š)"
		end

		$stdout.print("  #{sector_size_s} Ã— #{nsectors_s} Ã— #{tracks_s}\n")

		if mfm_count.length >= 2
			$stdout.print("  FM/MFMæ··åœ¨: FM:#{mfm_count[false]}ã‚»ã‚¯ã‚¿ MFM:#{mfm_count[true]}ã‚»ã‚¯ã‚¿\n")
		end

		if ddam_count > 0
			$stdout.print("  Deleted Data Address Markã®ç«‹ã£ãŸã‚»ã‚¯ã‚¿ãŒ#{ddam_count}å€‹ã‚ã‚Šã¾ã™\n")
		end

		status_count = status_count.to_a.sort_by{ |e| e[1] }.reverse
		if status_count.length > 0
			status_count_s = "#{status_count[0][0].to_hex}ãŒ#{status_count[0][1]}å€‹"
			status_count_s += " ä»–"  if status_count.length >= 2
			$stdout.print("  FDC StatusãŒ0ã§ãªã„ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™(#{status_count_s})\n")
		end
	end
end

# DCP/DCU(.dcu) ãƒ˜ãƒƒãƒ€(162ãƒã‚¤ãƒˆ)+ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/dcp.html
class DCU < DiskImage
	HEADER_SIZE = 162

	def self.image?(filedata)
		track_map = filedata[1, 160].to_bytes
		track_map.each do |t|
			if t != 0 && t != 1
				return false
			end
		end

		media_type = filedata[0].to_byte
		if media_type == 0x01 && filedata.length == HEADER_SIZE + (1024 * 8 * 2 * 77)
			return true
		elsif media_type == 0x02 && filedata.length == HEADER_SIZE + (512 * 15 * 2 * 80)
			return true
		elsif media_type == 0x03 && filedata.length == HEADER_SIZE + (512 * 18 * 2 * 80)
			return true
		elsif media_type == 0x04 && filedata.length == HEADER_SIZE + (512 * 8 * 2 * 80)
			return true
		elsif media_type == 0x05 && filedata.length == HEADER_SIZE + (512 * 9 * 2 * 80)
			return true
		elsif media_type == 0x08 && filedata.length == HEADER_SIZE + (1024 * 9 * 2 * 80)
			return true
		elsif media_type == 0x11 && filedata.length == HEADER_SIZE + (128*26 + 256*26*153)
			return true
		elsif media_type == 0x19 && filedata.length == HEADER_SIZE + (256 * 16 * 2 * 80)
			return true
		elsif media_type == 0x21 && filedata.length == HEADER_SIZE + (256 * 26 * 2 * 80)
			return true
		end

		return false
	end
end

# DIFC.X(.dim) ãƒ˜ãƒƒãƒ€(256ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://stdkmd.net/xeij/source/FDMedia.htm
class DIM < DiskImage
	def self.image?(filedata)
		return filedata[171, 15] == "DIFC HEADER  \0\0"
	end
end

# D88(.d88) ãƒ‡ã‚£ã‚¹ã‚¯ãƒ˜ãƒƒãƒ€+ã‚»ã‚¯ã‚¿æ¯ã«(ãƒ˜ãƒƒãƒ€+ãƒ‡ãƒ¼ã‚¿) https://www.pc98.org/project/doc/d88.html
class D88 < DiskImage
	def self.image?(filedata)
		return filedata[0x10, 10] == "\0" * 10 &&
			[0x00, 0x10, 0x20, 0x21, 0x30, 0x40].include?(filedata[0x1b].to_byte) &&
			filedata.length == filedata[0x1c, 4].to_dword
	end

	def self.load(filedata)
		r = DiskImage.new

		# Media flag
		case filedata[0x1b].to_byte
		when 0x00 # 2D
			r.mediatype = :"2d"
		when 0x10 # 2DD
			r.mediatype = :"2dd"
		when 0x20 # 2HD
			r.mediatype = :"2hd"
		when 0x21 # 2HD(1.44MB NP2kai)
			r.mediatype = :"2hd"
		when 0x30 # 1D
			r.mediatype = :"1d"
		when 0x40 # 1DD
			r.mediatype = :"1dd"
		else
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{filedata[0x1b].to_byte.to_hex}\n")
			r.mediatype = :unknown
		end

		# Write protect flag
		r.writeprotect = (filedata[0x1a].to_byte == 0) ? false : true

		# Disk name / comment
		r.comment = filedata[0, 16].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		# Track data
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find { |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4 # 0x2b0(688byte:164entry) or 0x2a0(672byte:160entry)
		track_offsets = track_offsets.first(header_tracks)

		track_offsets.each.with_index do |track_offset, track|
			if track_offset == 0
				r.track[track] = nil
			else
				r.track[track] = Track.new

				sector_offset = track_offset
				track_nsectors = nil
				begin
					w = Sector.new
					w.c, w.h, w.r, w.n, nsectors, w.mfm, w.ddam, w.status, rpm, datasize =
						filedata[sector_offset, 16].unpack("C4vC3x4Cv")
					sector_offset += 0x10

					if w.c > 90 || w.h > 1 || w.r > 32 || w.n > 6
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®CHRNä¸æ­£: #{w.c} #{w.h} #{w.r} #{w.n}\n")
						break  if w.n > 6 # è‡´å‘½çš„ãªã®ã§å¾Œç¶šå‡¦ç†ä¸­æ­¢
					end

					if nsectors > 32
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®ã‚»ã‚¯ã‚¿æ•°ä¸æ­£: #{nsectors}\n")
					end

					if !track_nsectors
						track_nsectors = nsectors
					elsif track_nsectors != nsectors
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®ç·ã‚»ã‚¯ã‚¿æ•°ãŒçµ±ä¸€ã•ã‚Œã¦ã„ãªã„: #{track_nsectors} != #{nsectors}\n")
					end

					case w.mfm
					when 0x00 # double density
						w.mfm = true
					when 0x40 # single density
						w.mfm = false
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®Density flagä¸æ­£: #{w.mfm.to_hex}\n")
						w.mfm = nil
					end

					case w.ddam
					when 0x00 # normal
						w.ddam = false
					when 0x10 #deleted
						w.ddam = true
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®DDAM flagä¸æ­£: #{w.ddam.to_hex}\n")
						w.ddam = nil
					end

					if rpm == 0 || rpm == 1
						# OK:NOP
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®NP2kai RPMä¸æ­£: #{rpm}\n")
					end

					nsize = 128 << w.n
					if nsize != datasize
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®ã‚»ã‚¯ã‚¿ã®Nå€¤ã¨ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºãŒç•°ãªã‚‹: N:#{nsize} != #{datasize}\n")
					end

					w.data = filedata[sector_offset, nsize]
					sector_offset += nsize

					r.track[track].sector << w
				end while r.track[track].sector.length < nsectors

				next_track_start = (track_offsets[(track + 1) .. -1].find { |o| o != 0 }) || filedata.length
				if sector_offset != next_track_start
					if sector_offset < next_track_start
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®ãƒ‡ãƒ¼ã‚¿ã®å¾Œã«ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™\n")
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®ãƒ‡ãƒ¼ã‚¿ãŒæ¬¡ã®ãƒˆãƒ©ãƒƒã‚¯ã«é”ã—ã¦ã„ã¾ã™\n")
					end
				end
			end
		end

		return r
	end
end

def same_data_msg(from_track, to_track, value)
	if from_track == to_track
		$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{from_track}ã¯å…¨ã¦#{value.ord.to_hex}ã§ã™\n")
	else
		$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{from_track}ï½#{to_track}ã¯å…¨ã¦#{value.ord.to_hex}ã§ã™\n")
	end
end

# ãƒˆãƒ©ãƒƒã‚¯ã®ãƒ‡ãƒ¼ã‚¿ã®çŠ¶æ³
def track_report(filedata, sector_byte = 1024, nsectors = 8, ntracks = 2 * 77)
	track_length = sector_byte * nsectors
	$stdout.print("  #{sector_byte}ãƒã‚¤ãƒˆ Ã— #{nsectors}ã‚»ã‚¯ã‚¿ Ã— #{ntracks}ãƒˆãƒ©ãƒƒã‚¯\n")

	filled_data_value = nil
	filled_data_from = nil
	(0 ... ntracks).each do |track|
		track_data = filedata[track * track_length, track_length]
		if track_data == track_data[0] * track_data.length
			if track_data[0] == filled_data_value
				# NOP (åŒãƒ‡ãƒ¼ã‚¿ãŒç¶™ç¶š)
			else
				if filled_data_value
					same_data_msg(filled_data_from + 1, track, filled_data_value)
				end
				filled_data_value = track_data[0]
				filled_data_from = track
			end
		elsif filled_data_value
			same_data_msg(filled_data_from + 1, track, filled_data_value)
			filled_data_value = nil
		end
	end
	if filled_data_value
		same_data_msg(filled_data_from + 1, ntracks, filled_data_value)
	end
end

def fdimageid(filename)
	filedata = read_file(filename)
	filesize = filedata.length

	case
	# Virtual98(.fdd) ãƒ˜ãƒƒãƒ€+å¯å¤‰é•·ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/fdd.html
	when filedata[0, 7] == "VFD1.00"
		$stdout.print("#{filename}:\n")
		$stdout.print("  Virtual98å½¢å¼ [.fdd]\n")

	# DIFC.X(.dim)
	when DIM.image?(filedata)
		$stdout.print("#{filename}:\n")

		# DIFC.X version
		difc_ver = filedata[0xfe].to_byte

		$stdout.print("  X68000 DIFC.Xå½¢å¼(v#{difc_ver}) [.dim]\n")

		# ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆç¨®åˆ¥
		format_flag = filedata[0].to_byte
		case format_flag
		when 0x00
			format_flag_s = "00h: 2HD(1.23MB)"
			ntracks_std = 154
			track_length = 1024 * 8
		when 0x01
			format_flag_s = "01h: 2HS(1.44MB)"
			ntracks_std = 160
			track_length = 1024 * 9
		when 0x02
			format_flag_s = "02h: 2HC(1.2MB)"
			ntracks_std = 160
			track_length = 512 * 15
		when 0x03
			format_flag_s = "03h: 2HDE(1.44MB)"
			ntracks_std = 160
			track_length = 1024 * 9
		when 0x09
			format_flag_s = "09h: 2HQ(1.44MB)"
			ntracks_std = 160
			track_length = 512 * 18
		else
			format_flag_s = "ä¸æ˜(#{format_flag.to_hex})"
			ntracks_std = 0
			track_length = 0
		end

		$stdout.print("  ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆç¨®åˆ¥: #{format_flag_s}\n")
		$stdout.print("  #{track_length}ãƒã‚¤ãƒˆ/ãƒˆãƒ©ãƒƒã‚¯\n")

		# ç·ãƒˆãƒ©ãƒƒã‚¯æ•° (0ã®å ´åˆã‚‚ã‚ã‚‹)
		ntracks = filedata[0xff].to_byte
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒˆãƒ©ãƒƒã‚¯æ•°: #{ntracks}ãƒˆãƒ©ãƒƒã‚¯\n")  if ntracks > 0

		# ãƒˆãƒ©ãƒƒã‚¯ã®ä¿å­˜çŠ¶æ…‹
		xtracks = 0
		filled_data_value = nil
		filled_data_from = nil
		filedata[1, 170].to_bytes.each.with_index(1) do |flag, track|
			case flag
			when 0 # ãªã—
				if filled_data_value
					same_data_msg(filled_data_from, track-1, filled_data_value)
					filled_data_value = nil
				end
			when 1 # ã‚ã‚Š
				track_data = filedata[256 + xtracks * track_length, track_length]
				xtracks += 1
				if track_data == track_data[0] * track_data.length
					if track_data[0] == filled_data_value
						# NOP (åŒãƒ‡ãƒ¼ã‚¿ãŒç¶™ç¶š)
					else
						if filled_data_value
							same_data_msg(filled_data_from, track-1, filled_data_value)
						end
						filled_data_value = track_data[0]
						filled_data_from = track
					end
				elsif filled_data_value
					same_data_msg(filled_data_from, track-1, filled_data_value)
					filled_data_value = nil
				end
			else
				$stderr.print("#{ProgName}: ãƒˆãƒ©ãƒƒã‚¯ä¿å­˜çŠ¶æ…‹ãŒä¸æ­£: #{flag}\n")
			end
		end
		if filled_data_value
			same_data_msg(filled_data_from, 170, filled_data_value)
		end

		if xtracks == ntracks_std
			$stdout.print("  #{xtracks}ãƒˆãƒ©ãƒƒã‚¯(æ¨™æº–)ã®ãƒ‡ãƒ¼ã‚¿ãŒæ ¼ç´ã•ã‚Œã¦ã„ã¾ã™\n")
		else
			$stdout.print("  #{xtracks}ãƒˆãƒ©ãƒƒã‚¯åˆ†ã®ãƒ‡ãƒ¼ã‚¿ãŒæ ¼ç´ã•ã‚Œã¦ã„ã¾ã™(æ¨™æº–ã¯#{ntracks_std})\n")
		end

		if filesize != 256 + xtracks * track_length
			$stdout.print("  ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒä¸æ­£(#{filesize}ãƒã‚¤ãƒˆ)\n")
		end

	# T98Next R0(.nfd) ãƒ˜ãƒƒãƒ€(68112ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/nfdr0.txt
	when filedata[0, 15] == "T98FDDIMAGE.R0\0"
		$stdout.print("#{filename}:\n")
		$stdout.print("  T98-Next NFD r0å½¢å¼ [.nfd]\n")

		szComment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		flProtect = filedata[0x10 + 0x100 + 4].to_byte

		$stdout.print("  ã‚³ãƒ¡ãƒ³ãƒˆ: #{szComment.inspect}\n")  if !szComment.empty?
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã‚µã‚¤ã‚º: #{dwHeadSize}ãƒã‚¤ãƒˆ\n")
		$stdout.print("  èª­ã¿å–ã‚Šå°‚ç”¨\n")  if flProtect != 0

		trackInfo = []
		(0 ... 163).each do |track|
			trackInfo[track] = { sectorInfo:[] }
			(0 ... 26).each do |sector|
				w = {}
				w[:c], w[:h], w[:r], w[:n], w[:flMFM], w[:flDDAM], w[:byStatus], w[:byST0], w[:byST1], w[:byST2], w[:byPDA] =
					filedata[0x10 + 0x100 + 0x10 + (track * 26 + sector) * 0x10, 11].unpack("C11")
				w[:byST0] &= 0xfb # Head Address ã¯ç„¡è¦–
				trackInfo[track][:sectorInfo] << w  if w[:c] != 0xff
			end
		end

		minval = {}
		maxval = {}
		minnsec = nil
		maxnsec = nil
		trackInfo.each do |ti|
			next  if ti[:sectorInfo].empty?

			ti[:sectorInfo].each do |si|
				[:c, :h, :r, :n, :flMFM, :flDDAM, :byStatus, :byST0, :byST1, :byST2, :byPDA].each do |member|
					minval[member] = si[member]  if !minval[member] || minval[member] > si[member]
					maxval[member] = si[member]  if !maxval[member] || maxval[member] < si[member]
				end
			end
			minnsec = ti[:sectorInfo].length  if !minnsec || minnsec > ti[:sectorInfo].length
			maxnsec = ti[:sectorInfo].length  if !maxnsec || maxnsec < ti[:sectorInfo].length
		end

		ntracks = trackInfo.count { |ti| !ti[:sectorInfo].empty? }
		ntracks_s = "#{ntracks}ãƒˆãƒ©ãƒƒã‚¯"

		sector_size = 128 << maxval[:n]
		if maxval[:n] == minval[:n]
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ"
		else
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ(æ··åœ¨ã‚ã‚Š)"
		end

		nsectors = maxnsec
		if maxnsec == minnsec
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿"
		else
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿(æ··åœ¨ã‚ã‚Š)"
		end

		byPDA = maxval[:byPDA]
		case byPDA
		when 0x90
			byPDA_s = "90h: 2HD(1.2MB)"
		when 0x30
			byPDA_s = "30h: 2HD(1.44MB)"
		when 0x10
			byPDA_s = "10h: 2DD(640KB)"
		else
			byPDA_s = "#{byPDA.to_hex}"
		end
		if maxval[:byPDA] != minval[:byPDA]
			byPDA_s += "(æ··åœ¨)"
		end

		$stdout.print("  #{sector_size_s} Ã— #{nsectors_s} Ã— #{ntracks_s}\n")
		$stdout.print("  FM/MFMæ··åœ¨\n")  if maxval[:flMFM] != minval[:flMFM]
		$stdout.print("  Deleted Data Address Markã®ç«‹ã£ãŸã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:flDDAM] != 0
		$stdout.print("  BIOS ResultãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byStatus] != 0
		$stdout.print("  FDC Store Status 0ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byST0] != 0
		$stdout.print("  FDC Store Status 1ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byST1] != 0
		$stdout.print("  FDC Store Status 2ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byST2] != 0
		$stdout.print("  PDAãƒ‡ãƒã‚¤ã‚¹ã‚¢ãƒ‰ãƒ¬ã‚¹: #{byPDA_s}\n")

	# T98Next R1(.nfd) ãƒ˜ãƒƒãƒ€(å…¨ä½“+ã‚»ã‚¯ã‚¿+ç‰¹æ®Šèª­ã¿è¾¼ã¿)+ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/nfdr1.txt
	when filedata[0, 15] == "T98FDDIMAGE.R1\0"
		$stdout.print("#{filename}:\n")
		$stdout.print("  T98-Next NFD r1å½¢å¼ [.nfd]\n")

		szComment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		flProtect = filedata[0x10 + 0x100 + 4].to_byte

		$stdout.print("  ã‚³ãƒ¡ãƒ³ãƒˆ: #{szComment.inspect}\n")  if !szComment.empty?
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã‚µã‚¤ã‚º: #{dwHeadSize}ãƒã‚¤ãƒˆ\n")
		$stdout.print("  èª­ã¿å–ã‚Šå°‚ç”¨\n")  if flProtect != 0

		trackInfo = []
		dwTrackHead = filedata[0x10 + 0x100 + 0x10, 4 * 164].to_dwords
		(0 ... dwTrackHead.length).each do |track|
			track_offset = dwTrackHead[track]
			next  if track_offset == 0

			wSector, wDiag = filedata[track_offset, 2 * 2].to_words
			trackInfo[track] = { sectorInfo:[], diagInfo:[] }

			(0 ... wSector).each do |sector|
				w = {}
				w[:c], w[:h], w[:r], w[:n], w[:flMFM], w[:flDDAM], w[:byStatus], w[:bySTS0], w[:bySTS1], w[:bySTS2], w[:byRetry], w[:byPDA] =
					filedata[track_offset + 0x10 + sector * 0x10, 12].unpack("C12")
				w[:bySTS0] &= 0xfb # Head Address ã¯ç„¡è¦–
				trackInfo[track][:sectorInfo] << w
			end

			(0 ... wDiag).each do |diag|
				w = {}
				w[:cmd], w[:c], w[:h], w[:r], w[:n], w[:byStatus], w[:bySTS0], w[:bySTS1], w[:bySTS2], w[:byRetry], w[:dwDataLen], w[:byPDA] =
					filedata[track_offset + 0x10 + wSector * 0x10 + diag * 0x10, 15].unpack("C10VC")
				trackInfo[track][:diagInfo] << w
			end
		end

		minval = {}
		maxval = {}
		minnsec = nil
		maxnsec = nil
		trackInfo.each do |ti|
			ti[:sectorInfo].each do |si|
				[:c, :h, :r, :n, :flMFM, :flDDAM, :byStatus, :bySTS0, :bySTS1, :bySTS2, :byRetry, :byPDA].each do |member|
					minval[member] = si[member]  if !minval[member] || minval[member] > si[member]
					maxval[member] = si[member]  if !maxval[member] || maxval[member] < si[member]
				end
			end
			minnsec = ti[:sectorInfo].length  if !minnsec || minnsec > ti[:sectorInfo].length
			maxnsec = ti[:sectorInfo].length  if !maxnsec || maxnsec < ti[:sectorInfo].length

			ti[:diagInfo].each do |di|
				$stdout.print("  ç‰¹æ®Šèª­ã¿è¾¼ã¿ã‚»ã‚¯ã‚¿: Cmd:#{di[:cmd]} C:#{di[:c]} H:#{di[:h]} R:#{di[:r]} N:#{di[:n]} STS:#{di[:bySTS0]},#{di[:bySTS1]},#{di[:bySTS2]} Status:#{di[:byStatus]} Retry:#{di[:byRetry]} DataLen:#{di[:dwDataLen]}\n")
			end
		end

		ntracks = trackInfo.length
		ntracks_s = "#{ntracks}ãƒˆãƒ©ãƒƒã‚¯"

		sector_size = 128 << maxval[:n]
		if maxval[:n] == minval[:n]
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ"
		else
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ(æ··åœ¨ã‚ã‚Š)"
		end

		nsectors = maxnsec
		if maxnsec == minnsec
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿"
		else
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿(æ··åœ¨ã‚ã‚Š)"
		end

		$stdout.print("  #{sector_size_s} Ã— #{nsectors_s} Ã— #{ntracks_s}\n")
		$stdout.print("  FM/MFMæ··åœ¨\n")  if maxval[:flMFM] != minval[:flMFM]
		$stdout.print("  Deleted Data Address Markã®ç«‹ã£ãŸã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:flDDAM] != 0
		$stdout.print("  BIOS ResultãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byStatus] != 0
		$stdout.print("  FDC Store Status 0ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:bySTS0] != 0
		$stdout.print("  FDC Store Status 1ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:bySTS1] != 0
		$stdout.print("  FDC Store Status 2ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:bySTS2] != 0
		$stdout.print("  ä¸å®‰å®šãƒ‡ãƒ¼ã‚¿ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byRetry] != 0
		$stdout.print("  PDAãƒ‡ãƒã‚¤ã‚¹ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byPDA] != 0

	# D88(.d88)
	when D88.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  D88å½¢å¼ [.d88 .d98 .88d .98d]\n")

		image = D88.load(filedata)
		image.report_all


	# DCP/DCU(.dcu)
	when DCU.image?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  DCP/DCUå½¢å¼ [.dcu .dcp]\n")

		media_type = filedata[0].to_byte
		case media_type
		when 0x01
			media_type_s = "01h: 2HD(1.23MB)"
		when 0x02
			media_type_s = "02h: 2HD(1.2MB 2HC)"
		when 0x03
			media_type_s = "03h: 2HQ(1.44MB 2HDE)"
		when 0x04
			media_type_s = "04h: 2DD(640KB)"
		when 0x05
			media_type_s = "05h: 2DD(720KB)"
		when 0x08
			media_type_s = "08h: 2HD(1.44MB)"
		when 0x11
			media_type_s = "11h: 2HD(Disk BASIC)"
		when 0x19
			media_type_s = "19h: 2DD(Disk BASIC)"
		when 0x21
			media_type_s = "21h: 2HD(26sector)"
		else
			media_type_s = "ä¸æ˜(#{media_type.to_hex})"
		end

		$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—: #{media_type_s}\n")

		track_map = filedata[1, 160].to_bytes
		all_cylinders_stored = filedata[0xa1].to_byte

	# Anex86(.fdi) ãƒ˜ãƒƒãƒ€(4096ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/hdi.html
	when filedata[0, 4].to_dword == 0 &&
		[0x90, 0x30, 0x10].include?(filedata[4, 4].to_dword) &&
		filedata[0x8, 4].to_dword + filedata[0xc, 4].to_dword == filesize

		$stdout.print("#{filename}:\n")
		$stdout.print("  Anex86å½¢å¼ [.fdi]\n")

		fddtype_id = filedata[4, 4].to_dword
		case fddtype_id
		when 0x90
			fddtype_id_s = "90h: 2HD(1.2MB)"
		when 0x30
			fddtype_id_s = "30h: 2HD(1.44MB)"
		when 0x10
			fddtype_id_s = "10h: 2DD"
		else
			fddtype_id_s = "#{fddtype_id.to_hex}"
		end

		headersize = filedata[0x8, 4].to_dword

		datasize = filedata[0xc, 4].to_dword
		case datasize
		when 1474560
			datasize_s = " 2HD(1.44MB)"
		when 1261568
			datasize_s = " 2HD(1.23MB)"
		when 1228800
			datasize_s = " 2HD(1.2MB)"
		when 737280
			datasize_s = " 2DD(720KB)"
		when 655360
			datasize_s = " 2DD(640KB)"
		else
			datasize_s = ""
		end

		$stdout.print("  FDD Type: #{fddtype_id_s}\n")
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã‚µã‚¤ã‚º: #{headersize}ãƒã‚¤ãƒˆ\n")
		$stdout.print("  ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: #{datasize}ãƒã‚¤ãƒˆ#{datasize_s}\n")

	# DIP(.dip) ãƒ˜ãƒƒãƒ€(256ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/dip.html
	when filedata[0, 8] == "\x01\x08\x00\x13\x41\x00\x01\x00" &&
		filesize == 256 + 1261568

		$stdout.print("#{filename}:\n")
		$stdout.print("  DIPå½¢å¼ [.dip]\n")

	# SL9821(.slf) ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ˜ãƒƒãƒ€(16ãƒã‚¤ãƒˆ)+ãƒˆãƒ©ãƒƒã‚¯ãƒ˜ãƒƒãƒ€(80*2*32=5120ãƒã‚¤ãƒˆ)+ãƒ‡ãƒ¼ã‚¿ https://www.satotomi.com/pifdc/pifdc_slf.html
	when filedata[0, 4] == "FDIM" &&
		filedata[4, 4].to_dword == 0x10000 &&
		filedata[8, 4].to_dword == filesize

		$stdout.print("#{filename}:\n")
		$stdout.print("  SL9821å½¢å¼ [.slf]\n")

	# 1.44MB 2HD ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—18ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—80ã‚·ãƒªãƒ³ãƒ€ = 1474560ãƒã‚¤ãƒˆ)
	when filesize == 512 * 18 * 2 * 80
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.44MB PC/AT) [.2hd]\n")

		track_report(filedata, 512, 18, 2 * 80)

	# 1.23MB 2HD ã¹ãŸ (1024ãƒã‚¤ãƒˆÃ—8ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—77ã‚·ãƒªãƒ³ãƒ€ = 1261568ãƒã‚¤ãƒˆ)
	when filesize == 1024 * 8 * 2 * 77
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.23MB PC98) [.xdf .2hd .dup .hdm .tfd]\n")

		track_report(filedata, 1024, 8, 2 * 77)

	# 1.2MB 2HD ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—15ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—80ã‚·ãƒªãƒ³ãƒ€ = 1228800ãƒã‚¤ãƒˆ)
	when filesize == 512 * 15 * 2 * 80
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.2MB PC/AT) [.2hd]\n")

		track_report(filedata, 512, 15, 2 * 80)

	# 720KB 2DD ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—9ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—80ã‚·ãƒªãƒ³ãƒ€ = 737280ãƒã‚¤ãƒˆ)
	when filesize == 512 * 9 * 2 * 80
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2DD(720KB MSX) [.dsk]\n")

		track_report(filedata, 512, 9, 2 * 80)

	# 640KB 2DD ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—8ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—80ã‚·ãƒªãƒ³ãƒ€ = 655360ãƒã‚¤ãƒˆ)
	when filesize == 512 * 8 * 2 * 80
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2DD(640KB) [.2dd]\n")

		track_report(filedata, 512, 8, 2 * 80)

	# 320KB 2D ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—8ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—40ã‚·ãƒªãƒ³ãƒ€ = 327680ãƒã‚¤ãƒˆ)
	when filesize == 512 * 8 * 2 * 40
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2D(320KB) [.2d]\n")

		track_report(filedata, 512, 8, 2 * 40)

	else
		$stdout.print("#{filename}:\n  ä¸æ˜ãªå½¢å¼ (#{filesize}ãƒã‚¤ãƒˆ)\n")
	end
end

# .dim â†’ .xdf å¤‰æ›
def strip_dim(filename)
	if !DIM.image?(filedata)
		$stderr.print("#{ProgName}: DIFC.Xå½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“: #{filename}\n")
		return
	end

	$stdout.print("#{filename}:\n")

	filedata = read_file(filename)
	filesize = filedata.length
	outfilename = filename + ".xdf"

	if filesize == 256 + 1024 * 8 * 2 * 77 # 1261824
		data = filedata[256, 1024 * 8 * 2 * 77]

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	elsif filesize == 256 + 1024 * 8 * 2 * 80 # 1310976
		data = filedata[256, 1024 * 8 * 2 * 77]
		data2 = filedata[256 + 1024 * 8 * 2 * 77, 1024 * 8 * 2 * (80 - 77)]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™: #{filename}\n")
			return
		end

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	elsif filesize == 256 + 1024 * 8 * 2 * 85 # 1392896
		data = filedata[256, 1024 * 8 * 2 * 77]
		data2 = filedata[256 + 1024 * 8 * 2 * 77, 1024 * 8 * 2 * (85 - 77)]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™: #{filename}\n")
			return
		end

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	else
		$stdout.print("  ä¸æ˜ãªå½¢å¼ (#{filesize}ãƒã‚¤ãƒˆ)\n")
	end
end

# 9ã‚»ã‚¯ã‚¿2DD(720KB)ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã®å„ãƒˆãƒ©ãƒƒã‚¯ã®9ã‚»ã‚¯ã‚¿ç›®ã‚’åˆ‡ã‚Šæ¨ã¦ã¦8ã‚»ã‚¯ã‚¿2DD(640KB)ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã«ã™ã‚‹
def truncate_9(filename)
	filedata = read_file(filename)
	filesize = filedata.length

	$stdout.print("#{filename}:\n")

	if filesize == 512 * 9 * 2 * 80
		outdata = ""
		(0 ... 2 * 80).each do |track|
			outdata += filedata[512 * 9 * track, 512 * 8]
		end

		outfilename = filename + ".xdf"
		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, outdata)
	elsif D88.image?(filedata) && filedata[0x1b].to_byte == 0x10
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find { |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4
		track_offsets = track_offsets.first(header_tracks)

		outdata = filedata[0, header_size]
		(0 ... header_tracks).each do |track|
			track_offset = track_offsets[track]
			if track_offset != 0
				outdata[0x20 + 4 * track, 4] = [outdata.length].pack("V")

				(0 ... 8).each do |r|
					data = filedata[track_offset + 0x210 * r, 0x210]
					fail if data[4, 2].to_word != 9
					data[4, 2] = [8].pack("v")
					outdata += data
				end
			end
		end

		outdata[0x1c, 4] = [outdata.length].pack("V") # Disk size

		outfilename = filename + ".d88"
		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, outdata)
	else
		$stdout.print("  ä¸æ˜ãªå½¢å¼ (#{filesize}ãƒã‚¤ãƒˆ)\n")
	end
end

def main(args)
	action = :identify

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] file..."

		opt.on("--strip-dim",
		".dim â†’ .xdf å¤‰æ›") do
			action = :strip_dim
		end

		opt.on("--truncate_9",
		"9ã‚»ã‚¯ã‚¿ç›®ã‚’åˆ‡ã‚Šæ¨ã¦") do
			action = :truncate_9
		end

		opt.parse!
		print(opt.help)  if args.empty?
	end

	args.each do |an_arg|
		if !File.exist?(an_arg)
			$stderr.print("#{ProgName}: File not found: #{an_arg}\n")
			break
		end

		case action
		when :identify
			fdimageid(an_arg)
		when :strip_dim
			strip_dim(an_arg)
		when :truncate_9
			truncate_9(an_arg)
		end
	end

	return 0
end

exit main(ARGV)
