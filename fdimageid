#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# ãƒ•ãƒ­ãƒƒãƒ”ãƒ¼ãƒ‡ã‚£ã‚¹ã‚¯ã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®è­˜åˆ¥
#
# 2024/09/14 opaâ ğŸ™‚
#----------------------------------------------------------------

require "optparse"
require "pp"

ProgName = "fdimageid"
Version = "0.01"
#=====dpk===== Copyright2024
Copyright = "Copyright (c) 2024 by opa"
#=====dpk=====

class String
	def to_byte;	unpack1("C");	end
	def to_word;	unpack1("v");	end
	def to_dword;	unpack1("V");	end

	def to_bytes;	unpack("C*");	end
	def to_words;	unpack("v*");	end
	def to_dwords;	unpack("V*");	end
end

class Integer
	def to_hex;	"#{to_s(16)}h";	end
end

def read_file(filename, offset=0, length=nil)
	return IO.binread(filename, length, offset)
end

def write_file(filename, data)
	return IO.binwrite(filename, data)
end

class DiskImage
	IMAGE_FORMATNAME = "Abstruct floppy disk image"
	IMAGE_EXTNAMES = []
	COMMON_GEOMETRIES = [
		# 0                   1        2      3    4     5     6     7
		# description         length   media  cyls heads nsecs ssize ssize1
		["2ED 2.88MB",       2949120, :"2hd",   80,    2,   36,  512],
		["2HD 1.44MB PC/AT", 1474560, :"2hd",   80,    2,   18,  512],
		["2HD 1.44MB",       1474560, :"2hd",   80,    2,    9, 1024],
		["2HD 1.23MB PC98",  1261568, :"2hd",   77,    2,    8, 1024],
		["2HC 1.2MB PC/AT",  1228800, :"2hd",   80,    2,   15,  512],
		["2HD 1.04MB",       1064960, :"2hd",   80,    2,   26,  256],
		["2HD 1.00MB",       1025024, :"2hd",   77,    2,   26,  256],
		["2HD DISK BASIC",   1021696, :"2hd",   77,    2,   26,  256,  128],
		["2DD 800KB",         819200, :"2dd",   80,    2,   10,  512],
		["2DD 720KB MSX",     737280, :"2dd",   80,    2,    9,  512],
		["2DD 640KB",         655360, :"2dd",   80,    2,    8,  512],
		["2DD DISK BASIC",    655360, :"2dd",   80,    2,   16,  256],
		["2D 360KB",          368640, :"2d",    40,    2,    9,  512],
		["2D 320KB",          327680, :"2d",    40,    2,   16,  256],
		["1DD 320KB",         327680, :"1dd",   80,    1,   16,  256],
		["1D 160KB",          163840, :"1d",    40,    1,   16,  256],
	]

	attr_accessor(:mediatype, :track, :writeprotect, :comment)

	def self.image_formatname
		return self::IMAGE_FORMATNAME
	end

	def self.image_extnames
		return self::IMAGE_EXTNAMES
	end

	def self.image_extnames_s
		return "[#{image_extnames.join(" ")}]"
	end

	def self.guess_image_format(filename:nil, data:nil)
		if filename
			data = read_file(filename)
		end

		[DIM, NFD_R0, NFD_R1, SLF, V98FDD, ERCVFD, DIP, D88, FDI, DCU, XDF].each do |c|
			if c.image?(data)
				return c
			end
		end

		return nil
	end

	def self.mediatype_s(mediatype)
		case mediatype
		when nil
			return ""
		when :"1d"
			return "1D"
		when :"1dd"
			return "1DD"
		when :"2d"
			return "2D"
		when :"2dd"
			return "2DD"
		when :"2hd"
			return "2HD"
		when :unknown
			return "ä¸æ˜"
		else
			return "ä¸æ­£ãªå€¤(#{mediatype})"
		end
	end

	def initialize(filename:nil, data:nil)
		clear

		if filename
			data = read_file(filename)
		end

		if data
			load(data)
		end
	end

	def clear
		@mediatype = nil # :"1d", :"1dd", :"2d", :"2dd", :"2hd", :unknown
		@track = [] # è¦ç´ ã¯Track(è¦ç´ ãŒnilã®ã“ã¨ã¯ãªã„)
		@writeprotect = nil # true:Write Protected false:Writeable
		@comment = nil
		return self
	end

	def to_h
		return {
			mediatype: @mediatype,
			track: @track.map{ |t| t.to_h },
			writeprotect: @writeprotect,
			comment: @comment,
		}
	end

	class Track
		attr_accessor(:sector)

		def initialize
			clear
		end

		def clear
			@sector = [] # è¦ç´ ã¯Sector(è¦ç´ ãŒnilã®ã“ã¨ã¯ãªã„)
			return self
		end

		def to_h
			return {
				sector: @sector.map{ |r| r.to_h },
			}
		end

		# ç©ºã‹?
		def empty?
			return @sector.empty?
		end

		# ãƒˆãƒ©ãƒƒã‚¯ã«å«ã¾ã‚Œã‚‹ã‚»ã‚¯ã‚¿æ•°
		def nsectors
			return @sector.length
		end

		# C(ã‚·ãƒªãƒ³ãƒ€)ç•ªå· ä¸çµ±ä¸€ã®å ´åˆã¯ :mix
		def c
			return nil  if empty?
			val = @sector.first.c
			return @sector.all?{ |s| s.c == val } ? val : :mix
		end

		# H(ãƒ˜ãƒƒãƒ‰)ç•ªå· ä¸çµ±ä¸€ã®å ´åˆã¯ :mix
		def h
			return nil  if empty?
			val = @sector.first.h
			return @sector.all?{ |s| s.h == val } ? val : :mix
		end

		# R(ãƒ¬ã‚³ãƒ¼ãƒ‰)ç•ªå·ã®é…åˆ—
		def r
			return @sector.map{ |s| s.r }
		end

		# N(ã‚»ã‚¯ã‚¿é•·)ç•ªå· ä¸çµ±ä¸€ã®å ´åˆã¯ :mix
		def n
			return nil  if empty?
			val = @sector.first.n
			return @sector.all?{ |s| s.n == val } ? val : :mix
		end

		# ã‚»ã‚¯ã‚¿é•· ä¸çµ±ä¸€ã®å ´åˆã¯ :mix
		def ssize
			return nil  if empty?
			val = @sector.first.ssize
			return @sector.all?{ |s| s.ssize == val } ? val : :mix
		end

		# ç·ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º
		def total_size
			return @sector.sum{ |s| s.ssize }
		end

		# å…¨ãƒã‚¤ãƒˆãŒåŒä¸€å€¤ã§ã‚ã‚‹ã‹
		def is_uniform?(test_value=nil)
			return nil  if @sector.empty?
			test_value ||= @sector.first.data[0]
			return @sector.all?{ |s| s.is_uniform?(test_value) }
		end
	end

	class Sector
		attr_accessor(:data, :c, :h, :r, :n, :mfm, :ddam, :status, :st0, :st1, :st2, :pda)

		def initialize
			clear
		end

		def clear
			@data = ""
			@c = nil
			@h = nil
			@r = nil
			@n = nil
			@mfm = nil		# false:FM(S) true:MFM(D,H)
			@ddam = nil		# false:DAM true:DDAM
			@status = nil	# BIOS Read Data Status 0:Normal Terminate
			@st0 = nil		# ST0
			@st1 = nil		# ST1
			@st2 = nil		# ST2
			@pda = nil		# PDA 0x90:1.2M 0x30:1.44M 0x10:640K
			return self
		end

		def to_h
			return {
				data: @data,
				c: @c,
				h: @h,
				r: @r,
				n: @n,
				mfm: @mfm,
				ddam: @ddam,
				status: @status,
				st0: @st0,
				st1: @st1,
				st2: @st2,
				pda: @pda,
			}
		end

		# ã‚»ã‚¯ã‚¿é•·
		def ssize
			return @data.length
		end

		# å…¨ãƒã‚¤ãƒˆãŒåŒä¸€å€¤ã§ã‚ã‚‹ã‹
		def is_uniform?(test_value=nil)
			return nil  if @data.empty?
			test_value ||= @data[0]
			return @data == test_value * ssize
		end
	end

	def mediatype_s(mediatype=@mediatype)
		return self.class.mediatype_s(mediatype)
	end

	# ç©ºã‹?
	def empty?
		return @mediatype.nil? && @writeprotect.nil? && @comment.nil? && @track.empty?
	end

	# ãƒ‡ãƒ¼ã‚¿ã®ã‚ã‚‹æœ€çµ‚ãƒˆãƒ©ãƒƒã‚¯ç•ªå·
	def ntracks
		return @track.length
	end

	# ãƒ‡ãƒ¼ã‚¿ã®ã‚ã‚‹ãƒˆãƒ©ãƒƒã‚¯æ•°
	def xtracks
		return @track.count{ |t| !t.empty? }
	end

	# ã‚·ãƒªãƒ³ãƒ€æ•° (Cã®æœ€å¤§å€¤+1)
	def cyls
		maxc = nil
		@track.each do |t|
			c = t.c
			next  if !c.is_a?(Integer)
			maxc = c  if !maxc || c > maxc
		end
		return maxc ? (maxc + 1) : nil
	end

	# ãƒ˜ãƒƒãƒ‰æ•° (Hã®æœ€å¤§å€¤+1)
	def heads
		maxh = nil
		@track.each do |t|
			h = t.h
			next  if !h.is_a?(Integer)
			maxh = h  if !maxh || h > maxh
		end
		return maxh ? (maxh + 1) : nil
	end

	# 1ãƒˆãƒ©ãƒƒã‚¯ã®ã‚»ã‚¯ã‚¿æ•° ä¸çµ±ä¸€ã®å ´åˆã¯ :mix
	def nsectors
		return nil  if @track.empty?
		nsectors = @track.first.nsectors
		return @track.all?{ |t| t.nsectors == nsectors } ? nsectors : :mix
	end

	# 1ã‚»ã‚¯ã‚¿ã®ã‚»ã‚¯ã‚¿é•· ä¸çµ±ä¸€ã®å ´åˆã¯ :mix
	def ssize
		return nil  if @track.empty?
		ssize = @track.first.ssize
		return @track.all?{ |t| t.ssize == ssize } ? ssize : :mix
	end

	# å…¨ã‚»ã‚¯ã‚¿æ•°
	def total_sectors
		return @track.sum{ |t| t.nsectors }
	end

	# ç·ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º
	def total_size
		return @track.sum{ |t| t.total_size }
	end

	# å…¨ãƒ‡ãƒ¼ã‚¿ã‚’CHRNé †ã«é€£çµã—ãŸã‚‚ã®
	def whole_data
	end

	# (å†…éƒ¨ç”¨)@trackå†…ã®nilè¦ç´ ã‚’ã¯ç©ºã®Trackã§åŸ‹ã‚ã‚‹
	def sweep_niltrack
		@track.map!{ |t| t || Track.new }
	end
	protected(:sweep_niltrack)

	# (å†…éƒ¨ç”¨)ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
	def excess_data_check(expect, actual)
		excess_data_length = expect - actual
		if excess_data_length > 0
			$stdout.print("  æœ«å°¾ã«ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™(#{excess_data_length}ãƒã‚¤ãƒˆä½™å‰°)\n")
		elsif excess_data_length < 0
			$stdout.print("  èª­ã¿è¾¼ã¿ä¸­ã«æœ«å°¾ã«é”ã—ã¾ã—ãŸ(#{-excess_data_length}ãƒã‚¤ãƒˆä¸è¶³)\n")
		end
	end
	protected(:excess_data_check)

	# æƒ…å ±ã‚’è¡¨ç¤º
	def report_all
		if empty?
			$stdout.print("  ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“(åˆæœŸçŠ¶æ…‹)\n")
			return
		end

		if @comment && !@comment.empty?
			$stdout.print("  ã‚³ãƒ¡ãƒ³ãƒˆ: #{@comment.inspect}\n")
		end

		if @mediatype
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ç¨®åˆ¥: #{mediatype_s}\n")
		end

		if !@writeprotect.nil?
			if @writeprotect
				$stdout.print("  ãƒ©ã‚¤ãƒˆãƒ—ãƒ­ãƒ†ã‚¯ãƒˆ: æ›¸ãè¾¼ã¿ç¦æ­¢\n")
			else
				$stdout.print("  ãƒ©ã‚¤ãƒˆãƒ—ãƒ­ãƒ†ã‚¯ãƒˆ: æ›¸ãè¾¼ã¿å¯\n")
			end
		end

		# ã‚»ã‚¯ã‚¿æƒ…å ±ã®çµ±è¨ˆã‚’ç®—å‡º
		nsecs_count = {}
		ssize_count = {}
		mfm_count = {}
		ddam_count = 0
		status_count = {}
		st0_count = {}
		st1_count = {}
		st2_count = {}
		pda_count = {}
		@track.each.with_index do |trk, trkno|
			nsecs = trk.nsectors
			nsecs_count[nsecs] ||= 0
			nsecs_count[nsecs] += 1

			sector_count = []
			trk.sector.each.with_index do |s, sec|
				if s.c > 90
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Cã®å€¤ãŒç•°å¸¸ã§ã™: #{s.c}\n")
				end

				if s.c != trkno / 2
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Cã®å€¤ãŒç‰¹æ®Šã§ã™: C:#{s.c} (!=#{trkno / 2})\n")
				end

				if s.h > 1
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Hã®å€¤ãŒç•°å¸¸ã§ã™: #{s.h}\n")
				end

				if s.h != trkno % 2
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Hã®å€¤ãŒç‰¹æ®Šã§ã™: H:#{s.h} (!=#{trkno % 2})\n")
				end

				if s.r < 1 || s.r > 32
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Rã®å€¤ãŒç•°å¸¸ã§ã™: #{s.r}\n")
				end

				# ã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã—ã¦ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ã§ã¯æ™®é€šã«ç•°ãªã‚‹ã®ã§ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
				# if s.r != sec + 1
				# 	$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Rã®å€¤ãŒç‰¹æ®Šã§ã™: R:#{s.r} (!=#{sec+1})\n")
				# end

				if s.n > 6
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nã®å€¤ãŒç•°å¸¸ã§ã™: #{s.n}\n")
				end

				ssize_n = 128 << s.n.clamp(..6)
				ssize = s.ssize
				if ssize_n != ssize
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nã®å€¤ã¨å®Ÿéš›ã®ã‚µã‚¤ã‚ºãŒç•°ãªã‚Šã¾ã™: N:#{ssize_n} != #{ssize}\n")
				end

				sector_count[s.r] ||= 0
				sector_count[s.r] += 1

				ssize_count[ssize] ||= 0
				ssize_count[ssize] += 1

				if !s.mfm.nil?
					mfm_count[s.mfm] ||= 0
					mfm_count[s.mfm] += 1
				end

				if s.ddam == true # DDAMã¯trueã®æ•°ã‚’æ•°ãˆã‚‹ã ã‘
					ddam_count += 1
				end

				if s.status && s.status != 0
					status_count[s.status] ||= 0
					status_count[s.status] += 1
				end

				if s.st0
					st0 = s.st0 & 0xf8 # Head Address, Unit Select ã¯ç„¡è¦–
					if st0 != 0
						st0_count[st0] ||= 0
						st0_count[st0] += 1
					end
				end

				if s.st1 && s.st1 != 0
					st1_count[s.st1] ||= 0
					st1_count[s.st1] += 1
				end

				if s.st2 && s.st2 != 0
					st2_count[s.st2] ||= 0
					st2_count[s.st2] += 1
				end

				if s.pda
					pda_count[s.pda] ||= 0
					pda_count[s.pda] += 1
				end
			end

			# ã‚»ã‚¯ã‚¿ç•ªå·ã®ãƒŒã‚±ãƒ»é‡è¤‡ã®ãƒã‚§ãƒƒã‚¯
			sector_count.each.with_index do |count, sec|
				count ||= 0
				if sec == 0
					if count > 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã«R=#{sec}ã®ã‚»ã‚¯ã‚¿ãŒ#{count}å€‹ã‚ã‚Šã¾ã™\n")
					end
				else
					if count < 1
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã«R=#{sec}ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“\n")
					elsif count > 1
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã«R=#{sec}ã®ã‚»ã‚¯ã‚¿ãŒ#{count}å€‹ã‚ã‚Šã¾ã™\n")
					end
				end
			end
		end

		# å‡ºç¾é »åº¦é †ã®é…åˆ—ã«ã™ã‚‹
		nsecs_major = nsecs_count.to_a.sort_by{ |e| e[1] }.reverse
		ssize_major = ssize_count.to_a.sort_by{ |e| e[1] }.reverse
		mfm_major = mfm_count.to_a.sort_by{ |e| e[1] }.reverse
		status_major = status_count.to_a.sort_by{ |e| e[1] }.reverse
		st0_major = st0_count.to_a.sort_by{ |e| e[1] }.reverse
		st1_major = st1_count.to_a.sort_by{ |e| e[1] }.reverse
		st2_major = st2_count.to_a.sort_by{ |e| e[1] }.reverse
		pda_major = pda_count.to_a.sort_by{ |e| e[1] }.reverse

		# ã‚¸ã‚ªãƒ¡ãƒˆãƒªç®—å‡º
		wk_ssize2 = wk_ssize = ssize
		if wk_ssize
			if wk_ssize == :mix
				wk_ssize2 = ssize_major[0][0]
				ssize_s = "#{wk_ssize2}ãƒã‚¤ãƒˆ(æ··åœ¨ã‚ã‚Š)"
			else
				ssize_s = "#{wk_ssize}ãƒã‚¤ãƒˆ"
			end
		else
			ssize_s = "0ãƒã‚¤ãƒˆ"
		end

		wk_nsectors2 = wk_nsectors = nsectors
		if wk_nsectors
			if wk_nsectors == :mix
				wk_nsectors2 = nsecs_major[0][0]
				nsecs_s = "#{wk_nsectors2}ã‚»ã‚¯ã‚¿(æ··åœ¨ã‚ã‚Š)"
			else
				nsecs_s = "#{wk_nsectors}ã‚»ã‚¯ã‚¿"
			end
		else
			nsecs_s = "ã‚»ã‚¯ã‚¿ãªã—"
		end

		wk_ntracks = ntracks
		if(wk_ntracks == xtracks)
			ntracks_s = "#{wk_ntracks}ãƒˆãƒ©ãƒƒã‚¯"
		else
			ntracks_s = "#{wk_ntracks}(#{xtracks})ãƒˆãƒ©ãƒƒã‚¯"
		end

		wk_total_size = total_size
		if wk_total_size / 1024 >= 1000
			total_size_kb = "%.2fMB" % ((wk_total_size / 1024) / 1000.0)
		else
			total_size_kb = "%dKB" % (wk_total_size / 1024)
		end

		wk_cyls = cyls
		wk_heads = heads
		$stdout.print("  #{wk_cyls}ã‚·ãƒªãƒ³ãƒ€ x #{wk_heads}ãƒ˜ãƒƒãƒ‰ = #{ntracks_s}\n")
		$stdout.print("  #{wk_cyls}ã‚·ãƒªãƒ³ãƒ€ x #{wk_heads}ãƒ˜ãƒƒãƒ‰ x #{nsecs_s} = #{total_sectors}ã‚»ã‚¯ã‚¿\n")
		$stdout.print("  #{wk_cyls}ã‚·ãƒªãƒ³ãƒ€ x #{wk_heads}ãƒ˜ãƒƒãƒ‰ x #{nsecs_s} x #{ssize_s} = #{wk_total_size}ãƒã‚¤ãƒˆ(#{total_size_kb})\n")

		# æ¨å®šãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
		guess_format = nil
		if !guess_format # æ™®é€šã«å…¨è¦ç´ ã‚’ãƒã‚§ãƒƒã‚¯
			COMMON_GEOMETRIES.each.with_index do |g, i|
				g_desc, g_len, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = g
				wk_media = @mediatype || g_media
				if g_ssize1
					if wk_total_size == g_len && wk_media == g_media && wk_cyls == g_cyls && wk_heads == g_heads && wk_nsectors2 == g_nsecs && wk_ssize2 == g_ssize && track[0].ssize == g_ssize1
						guess_format = i
						break
					end
				else
					if wk_total_size == g_len && wk_media == g_media && wk_cyls == g_cyls && wk_heads == g_heads && wk_nsectors2 == g_nsecs && wk_ssize2 == g_ssize
						guess_format = i
						break
					end
				end
			end
		end
		if !guess_format # ç·ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã¨ã‚·ãƒªãƒ³ãƒ€æ•°ã‚’æ›–æ˜§æ¤œç´¢
			COMMON_GEOMETRIES.each.with_index do |g, i|
				g_desc, g_len, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = g
				wk_media = @mediatype || g_media
				cyls_ok = ((wk_cyls <= 45 && g_cyls <= 45) || (wk_cyls > 45 && g_cyls > 45)) ? true : false
				if g_ssize1
					if wk_media == g_media && cyls_ok && wk_heads == g_heads && wk_nsectors2 == g_nsecs && wk_ssize2 == g_ssize && track[0].ssize == g_ssize1
						guess_format = i
						break
					end
				else
					if wk_media == g_media && cyls_ok && wk_heads == g_heads && wk_nsectors2 == g_nsecs && wk_ssize2 == g_ssize
						guess_format = i
						break
					end
				end
			end
		end

		if guess_format
			g_desc, g_len, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = COMMON_GEOMETRIES[guess_format]

			$stdout.print("  æ¨å®šãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: #{g_desc}\n")

			if @mediatype && @mediatype != g_media
				$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ç¨®åˆ¥ã¨å®Ÿéš›ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒç•°ãªã‚Šã¾ã™\n")
			end

			if wk_cyls != g_cyls
				$stdout.print("  ã‚·ãƒªãƒ³ãƒ€æ•°ãŒé€šå¸¸ã¨ç•°ãªã‚Šã¾ã™: æ¨™æº–ã¯#{g_cyls}(#{g_cyls * g_heads}ãƒˆãƒ©ãƒƒã‚¯)\n")
			end
		else
			$stdout.print("  ä¸€èˆ¬çš„ã§ãªã„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒã•ã‚Œã¦ã„ã¾ã™\n")
		end

		if mfm_count.length >= 2
			$stdout.print("  FM/MFMæ··åœ¨: FM:#{mfm_count[false]}ã‚»ã‚¯ã‚¿ MFM:#{mfm_count[true]}ã‚»ã‚¯ã‚¿\n")
		end

		if ddam_count > 0
			$stdout.print("  Deleted Data Address Markã®ç«‹ã£ãŸã‚»ã‚¯ã‚¿ãŒ#{ddam_count}å€‹ã‚ã‚Šã¾ã™\n")
		end

		if !status_major.empty?
			status_major_s = "#{status_major[0][0].to_hex}ãŒ#{status_major[0][1]}å€‹"
			status_major_s += " ä»–"  if status_major.length >= 2
			$stdout.print("  FDC StatusãŒ0ã§ãªã„ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™(#{status_major_s})\n")
		end

		st0_major.each do |val, count|
			$stdout.print("  ST0ãŒ#{val.to_hex}ã®ã‚»ã‚¯ã‚¿ãŒ#{count}å€‹ã‚ã‚Šã¾ã™\n")
		end

		st1_major.each do |val, count|
			$stdout.print("  ST1ãŒ#{val.to_hex}ã®ã‚»ã‚¯ã‚¿ãŒ#{count}å€‹ã‚ã‚Šã¾ã™\n")
		end

		st2_major.each do |val, count|
			$stdout.print("  ST2ãŒ#{val.to_hex}ã®ã‚»ã‚¯ã‚¿ãŒ#{count}å€‹ã‚ã‚Šã¾ã™\n")
		end

		pda_major.each do |val, count|
			mediatype_unmatch = false
			case val
			when 0x90
				val_s = "2HD 1.2MB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2hd"
			when 0x30
				val_s = "2HD 1.44MB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2hd"
			when 0x10
				val_s = "2DD 640KB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2dd"
			else
				val_s = "ä¸æ˜"
			end
			if mediatype_unmatch
				$stdout.print("  PDAãŒ#{val.to_hex}: #{val_s}(ãƒ¡ãƒ‡ã‚£ã‚¢ç¨®åˆ¥ã¨ä¸æ•´åˆ)ã®ã‚»ã‚¯ã‚¿ãŒ#{count}å€‹ã‚ã‚Šã¾ã™#{mediatype_unmatch_s}\n")
			end
		end

		trkno = 1
		uniform_map = @track.map do |t|
			(t.is_uniform?) ? t.sector.first.data[0] : false
		end
		uniform_map.chunk{ |d| d }.each do |cval, cdata|
			ctracks = cdata.length

			if cval
				if ctracks == 1
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno}ã¯å…¨ã¦#{cval.ord.to_hex}ã§ã™\n")
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno}ï½#{trkno+ctracks-1}ã¯å…¨ã¦#{cval.ord.to_hex}ã§ã™\n")
				end
			end

			trkno += ctracks
		end
	end
end

# DIFC.X ãƒ˜ãƒƒãƒ€(256ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://stdkmd.net/xeij/source/FDMedia.htm https://www.pc98.org/project/doc/dim.html
class DIM < DiskImage
	IMAGE_FORMATNAME = "X68000 DIFC.Xå½¢å¼"
	IMAGE_EXTNAMES = [".dim"]
	HEADER_SIZE = 0x100

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[171, 15] == "DIFC HEADER  \0\0" &&
			[0x00, 0x01, 0x02, 0x03, 0x09, 0x11].include?(filedata[0].to_byte)
	end

	def load(filedata)
		clear

		# DIFC.Xãƒãƒ¼ã‚¸ãƒ§ãƒ³
		difc_version = filedata[0xfe].to_byte
		difc_version_s = "1.%02x" % difc_version
		$stdout.print("  DIFC.xãƒãƒ¼ã‚¸ãƒ§ãƒ³: #{difc_version_s}\n")

		# ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—
		media_byte = filedata[0].to_byte
		case media_byte
		when 0x00 # 2HD 1.23MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		when 0x01 # 2HS 1.44MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x02 # 2HC 1.2MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 15, 512
		when 0x03 # 2HDE 1.44MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x09 # 2HQ 1.44MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 18, 512
		else
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{media_byte.to_hex}\n")
			@mediatype = :unknown
			cyls, heads, nsecs, ssize = 0, 0, 0, 0
		end

		# ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚åˆ»
		create_time = filedata[0xba, 8]
		if create_time != "\0" * 8
			create_time = create_time.unpack("CH2H2H2CH2H2H2").map{ |e| e.to_i }
			create_time[0] = "æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ"[create_time[0]]
			create_time[1] = 1980 + create_time[1]
			$stdout.print("  ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚åˆ»: " +
				"#{create_time[1]}/#{"%02d" % create_time[2]}/#{"%02d" % create_time[3]}(#{create_time[0]}) " +
				"#{create_time[5]}:#{"%02d" % create_time[6]}:#{"%02d" % create_time[7]}(#{(create_time[4]==0) ? "12" : "24"}æ™‚é–“è¨ˆ)\n")
		end

		# ã‚³ãƒ¡ãƒ³ãƒˆ
		@comment = filedata[0xc2, 60].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		# ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯
		header_ntracks = filedata[0xff].to_byte
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒˆãƒ©ãƒƒã‚¯æ•°: #{header_ntracks}ãƒˆãƒ©ãƒƒã‚¯\n")  if header_ntracks > 0

		# ãƒ‡ãƒ¼ã‚¿æœ¬ä½“
		offset = HEADER_SIZE
		track_flag = filedata[1, 170].to_bytes
		track_flag.each.with_index do |flag, trkno|
			case flag
			when 0 # ãªã—
				# NOP
			when 1 # ã‚ã‚Š
				cyl = trkno / heads
				head = trkno % heads

				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			else
				$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ãƒ‡ãƒ¼ã‚¿æœ‰ç„¡ãƒ•ãƒ©ã‚°ãŒä¸æ­£: #{flag}\n")
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# T98Next R0 ãƒ˜ãƒƒãƒ€(68112ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/nfdr0.txt
class NFD_R0 < DiskImage
	IMAGE_FORMATNAME = "T98-Next NFD r0å½¢å¼"
	IMAGE_EXTNAMES = [".nfd"]
	HEADER_SIZE = 0x10a10

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 15] == "T98FDDIMAGE.R0\0"
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		@writeprotect = (filedata[0x10 + 0x100 + 4].to_byte != 0) ? true : false
		byHead = filedata[0x10 + 0x100 + 5].to_byte
		$stdout.print("  ãƒ˜ãƒƒãƒ€éƒ¨ã®ãƒ˜ãƒƒãƒ‰æ•°: #{byHead}\n")

		id_offset = 0x120
		data_offset = dwHeadSize
		(0 ... 163).each do |trkno|
			(0 ... 26).each do |sec|
				s = Sector.new
				s.c, s.h, s.r, s.n, s.mfm, s.ddam, s.status, s.st0, s.st1, s.st2, s.pda =
					filedata[id_offset, 11].unpack("C11")
				id_offset += 0x10

				next  if s.c == 0xff

				if s.n > 6
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nã®å€¤ãŒç•°å¸¸ã§ã™: #{s.n}\n")
					next # è‡´å‘½çš„ãªã®ã§ã“ã®ã‚»ã‚¯ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®flMFMã®å€¤ãŒä¸æ­£: #{s.mfm}\n")
					s.mfm = nil
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®flDDAMã®å€¤ãŒä¸æ­£: #{s.ddam}\n")
					s.ddam = nil
				end

				ssize = 128 << s.n
				s.data = filedata[data_offset, ssize] || ""
				data_offset += ssize

				trk = (@track[trkno] ||= Track.new)
				trk.sector << s
			end
		end
		excess_data_check(filedata.length, data_offset)
		sweep_niltrack

		if byHead != heads
			$stdout.print("  ãƒ˜ãƒƒãƒ€éƒ¨ã®ãƒ˜ãƒƒãƒ‰æ•°ã¨å®Ÿéš›ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒ˜ãƒƒãƒ‰æ•°ãŒä¸€è‡´ã—ã¾ã›ã‚“\n")
		end
	end

	def dump
		raise("Not implemented")
	end
end

# T98Next R1 ãƒ˜ãƒƒãƒ€(å…¨ä½“(960ãƒã‚¤ãƒˆ)+ã‚»ã‚¯ã‚¿+ç‰¹æ®Šèª­ã¿è¾¼ã¿)+ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/nfdr1.txt
class NFD_R1 < DiskImage
	IMAGE_FORMATNAME = "T98-Next NFD r1å½¢å¼"
	IMAGE_EXTNAMES = [".nfd"]
	HEADER_SIZE = 0x3c0

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 15] == "T98FDDIMAGE.R1\0"
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		@writeprotect = (filedata[0x10 + 0x100 + 4].to_byte != 0) ? true : false
		byHead = filedata[0x10 + 0x100 + 5].to_byte
		dwTrackHead = filedata[0x10 + 0x100 + 0x10, 4 * 164].to_dwords
		dwAddInfo = filedata[0x10 + 0x100 + 0x10 + 4 * 164, 4].to_dword

		$stdout.print("  ãƒ˜ãƒƒãƒ€éƒ¨ã®ãƒ˜ãƒƒãƒ‰æ•°: #{byHead}\n")
		$stdout.print("  è¿½åŠ æƒ…å ±ãƒ˜ãƒƒãƒ€ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒ0ä»¥å¤–ã§ã™: #{dwAddInfo.to_hex}\n")  if dwAddInfo != 0

		data_offset = dwHeadSize
		sp_read_count = {}
		dwTrackHead.each.with_index do |track_offset, trkno|
			next  if track_offset == 0

			nsecs, wDiag = filedata[track_offset, 2 * 2].to_words
			track_offset += 0x10

			trk = (@track[trkno] ||= Track.new)
			(0 ... nsecs).each do |sec|
				s = Sector.new
				s.c, s.h, s.r, s.n, s.mfm, s.ddam, s.status, s.st0, s.st1, s.st2, byRetry, s.pda =
					filedata[track_offset, 12].unpack("C12")
				track_offset += 0x10

				if s.n > 6
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nã®å€¤ãŒç•°å¸¸ã§ã™: #{s.n}\n")
					next # è‡´å‘½çš„ãªã®ã§ã“ã®ã‚»ã‚¯ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®flMFMã®å€¤ãŒä¸æ­£: #{s.mfm}\n")
					s.mfm = nil
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®flDDAMã®å€¤ãŒä¸æ­£: #{s.ddam}\n")
					s.ddam = nil
				end

				ssize = 128 << s.n
				if byRetry == 0
					s.data = filedata[data_offset, ssize] || ""
					data_offset += ssize
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã«ãƒªãƒˆãƒ©ã‚¤ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã™: 1+#{byRetry}å›\n")
					s.data = []
					(0 .. byRetry).each do
						s.data << (filedata[data_offset, ssize] || "")
						data_offset += ssize
					end
				end

				trk.sector << s
			end

			# ç‰¹æ®Šèª­ã¿è¾¼ã¿ãƒ‡ãƒ¼ã‚¿
			(0 ... wDiag).each do
				d_cmd, d_c, d_h, d_r, d_n, d_byStatus, d_bySTS0, d_bySTS1, d_bySTS2, d_byRetry, d_dwDataLen, d_byPDA =
					filedata[track_offset, 15].unpack("C10VC")
				track_offset += 0x10
				data_offset += d_dwDataLen

				sp_read_count[d_cmd] ||= 0
				sp_read_count[d_cmd] += 1
			end
		end
		excess_data_check(filedata.length, data_offset)
		sweep_niltrack

		if byHead != heads
			$stdout.print("  ãƒ˜ãƒƒãƒ€éƒ¨ã®ãƒ˜ãƒƒãƒ‰æ•°ã¨å®Ÿéš›ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒ˜ãƒƒãƒ‰æ•°ãŒä¸€è‡´ã—ã¾ã›ã‚“\n")
		end

		sp_read_count = sp_read_count.to_a.sort_by{ |e| e[1] }.reverse
		sp_read_count.each do |cmd, count|
			case cmd
			when 0x0
				cmd_s = "Seek"
			when 0x1
				cmd_s = "Verify"
			when 0x2
				cmd_s = "Read Diagnostic"
			when 0x3
				cmd_s = "Initialize"
			when 0x4
				cmd_s = "Sense"
			when 0x5
				cmd_s = "Write Data"
			when 0x6
				cmd_s = "Read Data"
			when 0x7
				cmd_s = "Recalibrate"
			when 0x9
				cmd_s = "Write Deleted Data"
			when 0xa
				cmd_s = "Read ID"
			when 0xc
				cmd_s = "Read Deleted Data"
			when 0xd
				cmd_s = "Format Track"
			when 0xe
				cmd_s = "Set Operation Mode"
			else
				cmd_s = "ä¸æ˜ãªã‚³ãƒãƒ³ãƒ‰"
			end

			$stdout.print("  ç‰¹æ®Šèª­ã¿è¾¼ã¿ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã™: #{cmd_s}: #{count}å€‹\n")
		end
	end

	def dump
		raise("Not implemented")
	end
end

# SL9821 ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ˜ãƒƒãƒ€(16ãƒã‚¤ãƒˆ)+ãƒˆãƒ©ãƒƒã‚¯ãƒ˜ãƒƒãƒ€(32*80*2=5120ãƒã‚¤ãƒˆ)+ãƒ‡ãƒ¼ã‚¿ https://www.satotomi.com/pifdc/pifdc_slf.html
class SLF < DiskImage
	IMAGE_FORMATNAME = "SL9821å½¢å¼"
	IMAGE_EXTNAMES = [".slf"]
	HEADER_SIZE = 16 + 32 * 80 * 2

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 4] == "FDIM" &&
			filedata[4, 4].to_dword == 0x10000 &&
			filedata[8, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		version, filesize, flag = filedata[4, 12].to_dwords
		$stdout.print("  SLFãƒãƒ¼ã‚¸ãƒ§ãƒ³: #{version.to_hex}\n")

		if filesize != filedata.length
			$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã¨å®Ÿéš›ã®ã‚µã‚¤ã‚ºãŒç•°ãªã‚Šã¾ã™: #{filesize} (!=#{filedata.length})\n")
		end

		if flag != 0
			$stdout.print("  ãƒ•ãƒ©ã‚°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™: #{flag.to_hex}\n")
		end

		cyls, heads = 80, 2
		(0 ... cyls * heads).each do |trkno|
			tdata_offset, tdata_size, unformat_size, data_type, nsecs, gap4a_size, sync_size, gap1_size =
				filedata[0x10 + 0x20 * trkno, 28].unpack("V3v2V3")

			case data_type
			when 0xffff # -1:æœªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
				# NOP
			when 0 # ç‰©ç†ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ‡ãƒ¼ã‚¿
				$stdout.print("  ç‰©ç†ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã«ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“: #{trkno+1}ãƒˆãƒ©ãƒƒã‚¯\n")
			when 1, 2 # 1:FM/2:MFMãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ‡ãƒ¼ã‚¿
				sheader_offset = tdata_offset
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					sdata_offset, status, isync_size, gap2_size, dsync_size, gap3_size,
						id_crc, data_crc, idam_pattern, s.c, s.h, s.r, s.n, dataam_pattern =
						filedata[sheader_offset, 32].unpack("V2v6VC4V")
					sheader_offset += 0x20

					if s.n > 6
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nã®å€¤ãŒç•°å¸¸ã§ã™: #{s.n}\n")
						next # è‡´å‘½çš„ãªã®ã§ã“ã®ã‚»ã‚¯ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—
					end

					sdata_offset = tdata_offset + sdata_offset
					ssize = 128 << s.n
					s.mfm = (data_type == 2) ? true : false
					s.data = filedata[sdata_offset, ssize] || ""
					trk.sector << s

					chrn_s = "[#{s.c}/#{s.h}/#{s.r}/#{s.n}]"
					if (status & 0x1) != 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ #{chrn_s}: IDAMãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x2) != 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ #{chrn_s}: ID CRCã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x4) != 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ #{chrn_s}: DATAAMãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x8) != 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ #{chrn_s}: DATA CRCã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x10) != 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ #{chrn_s}: ã‚»ã‚¯ã‚¿æ§‹é€ ã®ã‚¨ãƒ©ãƒ¼\n")
					end
					if (status & 0x100) != 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ #{chrn_s}: Deletedã‚»ã‚¯ã‚¿\n")
					end
					if (status & 0x200) != 0
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ #{chrn_s}: å…¥ã‚Œå­ã‚»ã‚¯ã‚¿\n")
					end
					if (status | 0x31f) != 0x31f # ä¸Šè¨˜ä»¥å¤–ã®ãƒ“ãƒƒãƒˆãŒç«‹ã£ã¦ã„ãŸã‚‰
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ #{chrn_s}: ä¸æ˜ãªå€¤(#{status.to_hex})\n")
					end
				end
			end
		end
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# Virtual98 ãƒ˜ãƒƒãƒ€+å¯å¤‰é•·ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/fdd.html
class V98FDD < DiskImage
	IMAGE_FORMATNAME = "Virtual98å½¢å¼"
	IMAGE_EXTNAMES = [".fdd"]
	HEADER_SIZE = 0xc3fc

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 7] == "VFD1.00"
	end

	def load(filedata)
		clear

		@mediatype = :"2hd" # é•ã£ãŸã‚‰ã‚ã¨ã§ãƒªã‚»ãƒƒãƒˆ
		@comment = filedata[0x8, 0x80].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		@writeprotect = (filedata[0x88, 2].to_word != 0) ? true : false
		special_read_drive = filedata[0x8a, 2].to_word

		cyls, heads = 80, 2
		offset = 0xdc
		(0 ... cyls * heads).each do |trkno|
			(0 ... 26).each do
				s = Sector.new
				s.c, s.h, s.r, s.n, fill_byte, s.ddam, s.mfm, hd, sector_offset =
					filedata[offset, 12].unpack("C4aC3V")
				offset += 12

				next  if s.c == 0xff

				if s.n > 6
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nã®å€¤ãŒç•°å¸¸ã§ã™: #{s.n}\n")
					next # è‡´å‘½çš„ãªã®ã§ã“ã®ã‚»ã‚¯ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®DDAMã®å€¤ãŒä¸æ­£: #{s.ddam}\n")
					s.ddam = nil
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®MFã®å€¤ãŒä¸æ­£: #{s.mfm}\n")
					s.mfm = nil
				end

				if hd != 1
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã«2HDãƒ•ãƒ©ã‚°ãŒ1ã§ãªã„ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™: #{hd}\n")
					@mediatype = nil
				end

				ssize = 128 << s.n
				s.data = (sector_offset == 0xffffffff) ? fill_byte * ssize : filedata[sector_offset, ssize]

				trk = (@track[trkno] ||= Track.new)
				trk.sector << s
			end
		end
		sweep_niltrack

		if special_read_drive != 0xffff
			$stdout.print("  ç‰¹æ®Šèª­ã¿è¾¼ã¿ãƒ‰ãƒ©ã‚¤ãƒ–è¨­å®šãŒã‚ã‚Šã¾ã™: #{special_read_drive.to_hex}\n")

			next_point = special_read_drive # 0xc3dc
			begin
				trkno, in_ax, in_bx, in_cx, in_dx, out_ax, out_bx, out_cx, out_dx, out_flag, data_point, next_point, count, neg_count =
					filedata[next_point, 32].unpack("v10V2v2")
			end while(next_point != 0xffffffff && next_point != 0)
		end
	end

	def dump
		raise("Not implemented")
	end
end

# ERCVFD ãƒ˜ãƒƒãƒ€(64ãƒã‚¤ãƒˆ)+ã‚»ã‚¯ã‚¿æ¯ã«(ãƒ˜ãƒƒãƒ€(10ãƒã‚¤ãƒˆ)+ãƒ‡ãƒ¼ã‚¿)
class ERCVFD < DiskImage
	IMAGE_FORMATNAME = "ERCACHE ERCVFDå½¢å¼"
	IMAGE_EXTNAMES = [".vfd"]
	HEADER_SIZE = 0x40

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 8] == "ERCVFD01"
	end

	def load(filedata)
		$stdout.print("  ERCVFD.load not implemented\n")
	end

	def dump
		raise("Not implemented")
	end
end

# DIP ãƒ˜ãƒƒãƒ€(256ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/dip.html
class DIP < DiskImage
	IMAGE_FORMATNAME = "DIPå½¢å¼"
	IMAGE_EXTNAMES = [".dip"]
	HEADER_SIZE = 256

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 8] == "\x01\x08\x00\x13\x41\x00\x01\x00" &&
			filedata.length == HEADER_SIZE + (77 * 2 * 8 * 1024)
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0xf0].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		offset = HEADER_SIZE
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# D88 ãƒ‡ã‚£ã‚¹ã‚¯ãƒ˜ãƒƒãƒ€+ã‚»ã‚¯ã‚¿æ¯ã«(ãƒ˜ãƒƒãƒ€+ãƒ‡ãƒ¼ã‚¿) https://www.pc98.org/project/doc/d88.html https://github.com/waitingmoon/quasi88/blob/develop/document/FORMAT.TXT
class D88 < DiskImage
	IMAGE_FORMATNAME = "D88å½¢å¼"
	IMAGE_EXTNAMES = [".d88", ".d98", ".88d", ".98d"]
	HEADER_SIZE = 0x2a0 # or 0x2b0

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0x10, 10] == "\0" * 10 &&
			[0x00, 0x10, 0x20, 0x21, 0x30, 0x40].include?(filedata[0x1b].to_byte) &&
			filedata.length == filedata[0x1c, 4].to_dword
	end

	def load(filedata)
		clear

		# Media flag
		media_flag = filedata[0x1b].to_byte
		case media_flag
		when 0x00 # 2D
			@mediatype = :"2d"
		when 0x10 # 2DD
			@mediatype = :"2dd"
		when 0x20 # 2HD
			@mediatype = :"2hd"
		when 0x21 # 2HD 1.44MB NP2kai
			$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—: 2HD 1.44MB NP2kaiæ‹¡å¼µ\n")
			@mediatype = :"2hd"
		when 0x30 # 1D
			@mediatype = :"1d"
		when 0x40 # 1DD
			@mediatype = :"1dd"
		else
			$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{media_flag.to_hex}\n")
			@mediatype = :unknown
		end

		# Write protect flag
		@writeprotect = (filedata[0x1a].to_byte == 0) ? false : true

		# Disk name / comment
		@comment = filedata[0, 16].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		# Track data
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find{ |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4 # 0x2b0(688byte:164entry) or 0x2a0(672byte:160entry)
		track_offsets = track_offsets.first(header_tracks)

		rpm_count = [0, 0]
		track_offsets.each.with_index do |offset, trkno|
			if offset != 0
				trk = (@track[trkno] ||= Track.new)
				track_nsectors = nil
				begin
					s = Sector.new
					s.c, s.h, s.r, s.n, nsecs, s.mfm, s.ddam, s.status, rpm, datasize =
						filedata[offset, 16].unpack("C4vC3x4Cv")
					offset += 0x10

					if s.n > 6
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nã®å€¤ãŒç•°å¸¸ã§ã™: #{s.n}\n")
						break # è‡´å‘½çš„ãªã®ã§ã“ã®ãƒˆãƒ©ãƒƒã‚¯ã¯ã‚¹ã‚­ãƒƒãƒ—
					end

					if !track_nsectors
						track_nsectors = nsecs
					elsif track_nsectors != nsecs
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ç·ã‚»ã‚¯ã‚¿æ•°ãŒçµ±ä¸€ã•ã‚Œã¦ã„ã¾ã›ã‚“: #{nsecs} (!=#{track_nsectors})\n")
					end

					case s.mfm
					when 0x00 # double density
						s.mfm = true
					when 0x40 # single density
						s.mfm = false
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®Density flagä¸æ­£: #{s.mfm.to_hex}\n")
						s.mfm = nil
					end

					case s.ddam
					when 0x00 # normal
						s.ddam = false
					when 0x10 #deleted
						s.ddam = true
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®DDAM flagä¸æ­£: #{s.ddam.to_hex}\n")
						s.ddam = nil
					end

					if rpm == 0 || rpm == 1
						rpm_count[rpm] += 1
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®NP2kai RPMä¸æ­£: #{rpm}\n")
					end

					ssize = 128 << s.n
					if ssize != datasize
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ã‚»ã‚¯ã‚¿ã®Nã®å€¤ã¨ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºãŒç•°ãªã‚Šã¾ã™: N:#{datasize} (!=#{ssize})\n")
					end

					s.data = filedata[offset, ssize] || ""
					offset += ssize

					trk.sector << s
				end while trk.nsectors < nsecs

				next_track_start = (track_offsets[(trkno + 1) .. -1].find{ |o| o != 0 }) || filedata.length
				if offset != next_track_start
					if offset < next_track_start
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ãƒ‡ãƒ¼ã‚¿ã®å¾Œã«ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™\n")
					else
						$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ãƒ‡ãƒ¼ã‚¿ãŒæ¬¡ã®ãƒˆãƒ©ãƒƒã‚¯ã«é”ã—ã¦ã„ã¾ã™\n")
					end
				end
			end
		end
		sweep_niltrack

		if media_flag == 0x21
			if rpm_count[0] > 0
				$stdout.print("  ãƒ‡ã‚£ã‚¹ã‚¯ãƒ˜ãƒƒãƒ€ä¸Šã¯2HD 1.44MBã§ã™ãŒã€#{rpm_count[0]}å€‹ã®ã‚»ã‚¯ã‚¿ã®RPMãŒ0ã§ã™\n")
			end
		else
			if rpm_count[1] > 0
				$stdout.print("  #{rpm_count[1]}å€‹ã®ã‚»ã‚¯ã‚¿ã®RPMãŒ1ã§ã™\n")
			end
		end
	end

	def dump
		raise("Not implemented")
	end
end

# Anex86 ãƒ˜ãƒƒãƒ€(é€šå¸¸4096ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/hdi.html
class FDI < DiskImage
	IMAGE_FORMATNAME = "Anex86å½¢å¼"
	IMAGE_EXTNAMES = [".fdi"]
	HEADER_SIZE = 0x20 # ã‚³ãƒ¡ãƒ³ãƒˆé™¤ãæœ€å°ã‚µã‚¤ã‚º

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 4].to_dword == 0 &&
			[0x90, 0x30, 0x10].include?(filedata[4, 4].to_dword) &&
			filedata[0x8, 4].to_dword + filedata[0xc, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		fddtype_id = filedata[4, 4].to_dword
		case fddtype_id
		when 0x90 # 2HD 1.2MB
			@mediatype = :"2hd"
		when 0x30 # 2HD 1.44MB
			@mediatype = :"2hd"
		when 0x10 # 2DD 640KB or 720KB
			@mediatype = :"2dd"
		else
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{fddtype_id.to_hex}\n")
			@mediatype = :unknown
		end

		headersize = filedata[0x8, 4].to_dword
		datasize = filedata[0xc, 4].to_dword
		ssize, nsecs, heads, cyls = filedata[0x10, 4 * 4].to_dwords
		$stdout.print("  ãƒ˜ãƒƒãƒ€æƒ…å ±: #{cyls}ã‚·ãƒªãƒ³ãƒ€ x #{heads}ãƒ˜ãƒƒãƒ‰ x #{nsecs}ã‚»ã‚¯ã‚¿ x #{ssize}ãƒã‚¤ãƒˆ\n")

		@comment = filedata[0x20, headersize - 0x20].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		calc_datasize = cyls * heads * nsecs * ssize
		if calc_datasize != datasize
			$stdout.print("  ãƒ˜ãƒƒãƒ€æƒ…å ±ã®ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã¨ãƒ˜ãƒƒãƒ€ã®CHRNã‹ã‚‰ç®—å‡ºã—ãŸã‚µã‚¤ã‚ºãŒä¸€è‡´ã—ã¾ã›ã‚“: #{datasize} (!=#{calc_datasize})\n")
		end

		if headersize + datasize != filedata.length
			$stdout.print("  ãƒ˜ãƒƒãƒ€æƒ…å ±ã®ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã¨å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒä¸€è‡´ã—ã¾ã›ã‚“: #{headersize + datasize} (!=#{filedata.length})\n")
		end

		offset = headersize
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# DCP/DCU ãƒ˜ãƒƒãƒ€(162ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/dcp.html https://melog.info/archives/2004/09/30/94#comment-27
class DCU < DiskImage
	IMAGE_FORMATNAME = "DCP/DCUå½¢å¼"
	IMAGE_EXTNAMES = [".dcu", ".dcp"]
	HEADER_SIZE = 1 + 160 + 1

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		track_map = filedata[1, 160].to_bytes
		track_map.each do |t|
			if t != 0 && t != 1
				return false
			end
		end

		media_type = filedata[0].to_byte
		case [media_type, filedata.length]
		when [0x01, HEADER_SIZE + (77 * 2 * 8 * 1024)] # 2HD 1.25MB 2HS
			return true
		when [0x02, HEADER_SIZE + (80 * 2 * 15 * 512)] # 2HD 1.21MB 2HC
			return true
		when [0x03, HEADER_SIZE + (80 * 2 * 18 * 512)] # 2HQ 1.44MB 2HDE
			return true
		when [0x04, HEADER_SIZE + (80 * 2 * 8 * 512)] # 2DD 640KB
			return true
		when [0x05, HEADER_SIZE + (80 * 2 * 9 * 512)] # 2DD 720KB
			return true
		when [0x08, HEADER_SIZE + (80 * 2 * 9 * 1024)] # 2HD 1.44MB
			return true
		when [0x11, HEADER_SIZE + (1*26*128 + 153*26*256)] # 2HD Disk BASIC
			return true
		when [0x19, HEADER_SIZE + (80 * 2 * 16 * 256)] # 2DD Disk BASIC
			return true
		when [0x21, HEADER_SIZE + (80 * 2 * 26 * 256)] # 2HD 26sector
			return true
		end

		return false
	end

	def load(filedata)
		clear

		media_type = filedata[0].to_byte
		case media_type
		when 0x01 # 2HD 1.25MB 2HS
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		when 0x02 # 2HD 1.21MB 2HC
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 15, 512
		when 0x03 # 2HQ 1.44MB 2HDE
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 18, 512
		when 0x04 # 2DD 640KB
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 8, 512
		when 0x05 # 2DD 720KB
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 512
		when 0x08 # 2HD 1.44MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x11 # 2HD Disk BASIC
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize, ssize1 = 77, 2, 26, 256, 128
		when 0x19 # 2DD Disk BASIC
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 16, 256
		when 0x21 # 2HD 26sector
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 26, 256
		else
			$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ä¸æ˜: #{media_type.to_hex}\n")
			@mediatype = :unknown
			cyls, heads, nsecs, ssize = 0, 0, 0, 0
		end

		# ãƒˆãƒ©ãƒƒã‚¯ä¿å­˜çŠ¶æ…‹
		track_flag = filedata[1, 160].to_bytes
		track_flag.each.with_index do |flag, trkno|
			if flag == 0 || flag == 1
				# OK:NOP
			else
				$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{trkno+1}ã®ãƒ‡ãƒ¼ã‚¿æœ‰ç„¡ãƒ•ãƒ©ã‚°ãŒä¸æ­£: #{flag}\n")
			end
		end

		# å…¨ãƒˆãƒ©ãƒƒã‚¯æ ¼ç´ãƒ•ãƒ©ã‚°
		all_cylinders_stored = filedata[0xa1].to_byte
		case all_cylinders_stored
		when 0
			# OK:NOP
		when 1
			$stdout.print("  å…¨ãƒˆãƒ©ãƒƒã‚¯æ ¼ç´ãƒ•ãƒ©ã‚°: ON\n")
			(0 ... cyls * heads).each do |trkno|
				track_flag[trkno] = 1
			end
		else
			$stdout.print("  å…¨ãƒˆãƒ©ãƒƒã‚¯æ ¼ç´ãƒ•ãƒ©ã‚°ä¸æ­£: #{all_cylinders_stored}\n")
		end

		# ãƒ‡ãƒ¼ã‚¿æœ¬ä½“
		offset = HEADER_SIZE
		track_flag.each.with_index do |flag, trkno|
			case flag
			when 0 # ãªã—
				# NOP
			when 1 # ã‚ã‚Š
				cyl = trkno / heads
				head = trkno % heads

				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# XDF ã¹ãŸãƒ‡ãƒ¼ã‚¿
class XDF < DiskImage
	IMAGE_FORMATNAME = "ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸"
	IMAGE_EXTNAMES = [".xdf", ".dup", ".hdm", ".tfd", ".dsk", ".2hd", ".2dd", ".2d", ".1d"]
	HEADER_SIZE = 0

	def self.image?(filedata)
		return COMMON_GEOMETRIES.find{ |g| g[1] == filedata.length } ? true : false
	end

	def load(filedata)
		clear

		geom = COMMON_GEOMETRIES.find{ |g| g[1] == filedata.length }
		cyls, heads, nsecs, ssize = geom[3 .. 6]

		offset = 0
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # ã‚·ãƒªãƒ³ãƒ€ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.h = head # ãƒ˜ãƒƒãƒ‰ã¯0ã‚ªãƒªã‚¸ãƒ³
					s.r = sec # ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯1ã‚ªãƒªã‚¸ãƒ³
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

def fdimageid(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze

	image_class = DiskImage.guess_image_format(data:filedata)
	if image_class
		$stdout.print("  ğŸ’¾ #{image_class.image_formatname} #{image_class.image_extnames_s}\n")
		image = image_class.new(data:filedata)
		image.report_all
	else
		$stdout.print("  â“ å½¢å¼ä¸æ˜(#{filedata.length}ãƒã‚¤ãƒˆ)\n")
	end
end

# .dim â†’ .xdf å¤‰æ›
def strip_dim(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze
	outfilename = filename + ".xdf"

	if !DIM.image?(filedata)
		$stderr.print("#{ProgName}: DIFC.Xå½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“: #{filename}\n")
		return
	end

	case filedata.length
	when 256 + 77 * 2 * 8 * 1024 # 1261824
		data = filedata[256, 77 * 2 * 8 * 1024]

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	when 256 + 80 * 2 * 8 * 1024 # 1310976
		data = filedata[256, 77 * 2 * 8 * 1024]
		data2 = filedata[256 + 77 * 2 * 8 * 1024, (80 - 77) * 2 * 8 * 1024]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™: #{filename}\n")
			return
		end

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	when 256 + 85 * 2 * 8 * 1024 # 1392896
		data = filedata[256, 77 * 2 * 8 * 1024]
		data2 = filedata[256 + 77 * 2 * 8 * 1024, (85 - 77) * 2 * 8 * 1024]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™: #{filename}\n")
			return
		end

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	else
		$stdout.print("  å½¢å¼ä¸æ˜(#{filedata.length}ãƒã‚¤ãƒˆ)\n")
	end
end

# 9ã‚»ã‚¯ã‚¿2DD 720KBã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã®å„ãƒˆãƒ©ãƒƒã‚¯ã®9ã‚»ã‚¯ã‚¿ç›®ã‚’åˆ‡ã‚Šæ¨ã¦ã¦8ã‚»ã‚¯ã‚¿2DD 640KBã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã«ã™ã‚‹
def truncate_9(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze

	if filedata.length == 80 * 2 * 9 * 512
		outdata = ""
		(0 ... 80 * 2).each do |track|
			outdata += filedata[track * 9 * 512, 8 * 512]
		end

		outfilename = filename + ".xdf"
		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, outdata)
	elsif D88.image?(filedata) && filedata[0x1b].to_byte == 0x10
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find{ |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4
		track_offsets = track_offsets.first(header_tracks)

		outdata = filedata[0, header_size]
		(0 ... header_tracks).each do |track|
			track_offset = track_offsets[track]
			if track_offset != 0
				outdata[0x20 + 4 * track, 4] = [outdata.length].pack("V")

				(0 ... 8).each do |r|
					data = filedata[track_offset + 0x210 * r, 0x210]
					fail if data[4, 2].to_word != 9
					data[4, 2] = [8].pack("v")
					outdata += data
				end
			end
		end

		outdata[0x1c, 4] = [outdata.length].pack("V") # Disk size

		outfilename = filename + ".d88"
		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, outdata)
	else
		$stdout.print("  å½¢å¼ä¸æ˜(#{filedata.length}ãƒã‚¤ãƒˆ)\n")
	end
end

def main(args)
	action = :identify

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] file..."

		opt.on("--strip-dim",
		".dim â†’ .xdf å¤‰æ›") do
			action = :strip_dim
		end

		opt.on("--truncate_9",
		"9ã‚»ã‚¯ã‚¿ç›®ã‚’åˆ‡ã‚Šæ¨ã¦") do
			action = :truncate_9
		end

		opt.parse!
		print(opt.help)  if args.empty?
	end

	args.each do |an_arg|
		if !File.exist?(an_arg)
			$stderr.print("#{ProgName}: File not found: #{an_arg}\n")
			break
		end

		case action
		when :identify
			fdimageid(an_arg)
		when :strip_dim
			strip_dim(an_arg)
		when :truncate_9
			truncate_9(an_arg)
		end
	end

	return 0
end

exit main(ARGV)
