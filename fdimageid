#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# フロッピーディスクイメージファイルの識別
#
# 2024/09/14 opa⁠🙂
#----------------------------------------------------------------

require "optparse"
require "pp"

ProgName = "fdimageid"
Version = "0.01"
#=====dpk===== Copyright2024
Copyright = "Copyright (c) 2024 by opa"
#=====dpk=====

class String
	def to_byte;	unpack1("C");	end
	def to_word;	unpack1("v");	end
	def to_dword;	unpack1("V");	end

	def to_bytes;	unpack("C*");	end
	def to_words;	unpack("v*");	end
	def to_dwords;	unpack("V*");	end
end

class Integer
	def to_hex;	"#{to_s(16)}h";	end
end

def read_file(filename, offset=0, length=nil)
	return IO.binread(filename, length, offset)
end

def write_file(filename, data)
	return IO.binwrite(filename, data)
end

class DiskImage
	IMAGE_FORMATNAME = "Abstruct floppy disk image"
	IMAGE_EXTNAMES = []
	COMMON_GEOMETRIES = [
		# 0                   1        2      3    4     5     6     7
		# description         length   media  cyls heads nsecs ssize ssize1
		["2ED 2.88MB",       2949120, :"2hd",   80,    2,   36,  512],
		["2HD 1.44MB PC/AT", 1474560, :"2hd",   80,    2,   18,  512],
		["2HD 1.44MB",       1474560, :"2hd",   80,    2,    9, 1024],
		["2HD 1.23MB PC98",  1261568, :"2hd",   77,    2,    8, 1024],
		["2HC 1.2MB PC/AT",  1228800, :"2hd",   80,    2,   15,  512],
		["2HD 1.04MB",       1064960, :"2hd",   80,    2,   26,  256],
		["2HD 1.00MB",       1025024, :"2hd",   77,    2,   26,  256],
		["2HD DISK BASIC",   1021696, :"2hd",   77,    2,   26,  256,  128],
		["2DD 800KB",         819200, :"2dd",   80,    2,   10,  512],
		["2DD 720KB MSX",     737280, :"2dd",   80,    2,    9,  512],
		["2DD 640KB",         655360, :"2dd",   80,    2,    8,  512],
		["2DD DISK BASIC",    655360, :"2dd",   80,    2,   16,  256],
		["2D 360KB",          368640, :"2d",    40,    2,    9,  512],
		["2D 320KB",          327680, :"2d",    40,    2,   16,  256],
		["1DD 320KB",         327680, :"1dd",   80,    1,   16,  256],
		["1D 160KB",          163840, :"1d",    40,    1,   16,  256],
	]

	attr_accessor(:mediatype, :track, :writeprotect, :comment)

	def self.image_formatname
		return self::IMAGE_FORMATNAME
	end

	def self.image_extnames
		return self::IMAGE_EXTNAMES
	end

	def self.image_extnames_s
		return "[#{image_extnames.join(" ")}]"
	end

	def self.guess_image_format(filename:nil, data:nil)
		if filename
			data = read_file(filename)
		end

		[DIM, NFD_R0, NFD_R1, SLF, V98FDD, ERCVFD, DIP, D88, FDI, DCU, XDF].each do |c|
			if c.image?(data)
				return c
			end
		end

		return nil
	end

	def self.mediatype_s(mediatype)
		case mediatype
		when nil
			return ""
		when :"1d"
			return "1D"
		when :"1dd"
			return "1DD"
		when :"2d"
			return "2D"
		when :"2dd"
			return "2DD"
		when :"2hd"
			return "2HD"
		when :unknown
			return "不明"
		else
			return "不正な値(#{mediatype})"
		end
	end

	def initialize(filename:nil, data:nil)
		clear

		if filename
			data = read_file(filename)
		end

		if data
			load(data)
		end
	end

	def clear
		@mediatype = nil # :"1d", :"1dd", :"2d", :"2dd", :"2hd", :unknown
		@track = [] # 要素はTrack(要素がnilのことはない)
		@writeprotect = nil # true:Write Protected false:Writeable
		@comment = nil
		return self
	end

	def to_h
		return {
			mediatype: @mediatype,
			track: @track.map{ |t| t.to_h },
			writeprotect: @writeprotect,
			comment: @comment,
		}
	end

	class Track
		attr_accessor(:sector)

		def initialize
			clear
		end

		def clear
			@sector = [] # 要素はSector(要素がnilのことはない)
			return self
		end

		def to_h
			return {
				sector: @sector.map{ |r| r.to_h },
			}
		end

		# 空か?
		def empty?
			return @sector.empty?
		end

		# トラックに含まれるセクタ数
		def nsectors
			return @sector.length
		end

		# C(シリンダ)番号 不統一の場合は :mix
		def c
			return nil  if empty?
			val = @sector.first.c
			return @sector.all?{ |s| s.c == val } ? val : :mix
		end

		# H(ヘッド)番号 不統一の場合は :mix
		def h
			return nil  if empty?
			val = @sector.first.h
			return @sector.all?{ |s| s.h == val } ? val : :mix
		end

		# R(レコード)番号の配列
		def r
			return @sector.map{ |s| s.r }
		end

		# N(セクタ長)番号 不統一の場合は :mix
		def n
			return nil  if empty?
			val = @sector.first.n
			return @sector.all?{ |s| s.n == val } ? val : :mix
		end

		# セクタ長 不統一の場合は :mix
		def ssize
			return nil  if empty?
			val = @sector.first.ssize
			return @sector.all?{ |s| s.ssize == val } ? val : :mix
		end

		# 総データサイズ
		def total_size
			return @sector.sum{ |s| s.ssize }
		end

		# 全バイトが同一値であるか
		def is_uniform?(test_value=nil)
			return nil  if @sector.empty?
			test_value ||= @sector.first.data[0]
			return @sector.all?{ |s| s.is_uniform?(test_value) }
		end
	end

	class Sector
		attr_accessor(:data, :c, :h, :r, :n, :mfm, :ddam, :status, :st0, :st1, :st2, :pda)

		def initialize
			clear
		end

		def clear
			@data = ""
			@c = nil
			@h = nil
			@r = nil
			@n = nil
			@mfm = nil		# false:FM(S) true:MFM(D,H)
			@ddam = nil		# false:DAM true:DDAM
			@status = nil	# BIOS Read Data Status 0:Normal Terminate
			@st0 = nil		# ST0
			@st1 = nil		# ST1
			@st2 = nil		# ST2
			@pda = nil		# PDA 0x90:1.2M 0x30:1.44M 0x10:640K
			return self
		end

		def to_h
			return {
				data: @data,
				c: @c,
				h: @h,
				r: @r,
				n: @n,
				mfm: @mfm,
				ddam: @ddam,
				status: @status,
				st0: @st0,
				st1: @st1,
				st2: @st2,
				pda: @pda,
			}
		end

		# セクタ長
		def ssize
			return @data.length
		end

		# 全バイトが同一値であるか
		def is_uniform?(test_value=nil)
			return nil  if @data.empty?
			test_value ||= @data[0]
			return @data == test_value * ssize
		end
	end

	def mediatype_s(mediatype=@mediatype)
		return self.class.mediatype_s(mediatype)
	end

	# 空か?
	def empty?
		return @mediatype.nil? && @writeprotect.nil? && @comment.nil? && @track.empty?
	end

	# データのある最終トラック番号
	def ntracks
		return @track.length
	end

	# データのあるトラック数
	def xtracks
		return @track.count{ |t| !t.empty? }
	end

	# シリンダ数 (Cの最大値+1)
	def cyls
		maxc = nil
		@track.each do |t|
			c = t.c
			next  if !c.is_a?(Integer)
			maxc = c  if !maxc || c > maxc
		end
		return maxc ? (maxc + 1) : nil
	end

	# ヘッド数 (Hの最大値+1)
	def heads
		maxh = nil
		@track.each do |t|
			h = t.h
			next  if !h.is_a?(Integer)
			maxh = h  if !maxh || h > maxh
		end
		return maxh ? (maxh + 1) : nil
	end

	# 1トラックのセクタ数 不統一の場合は :mix
	def nsectors
		return nil  if @track.empty?
		nsectors = @track.first.nsectors
		return @track.all?{ |t| t.nsectors == nsectors } ? nsectors : :mix
	end

	# 1セクタのセクタ長 不統一の場合は :mix
	def ssize
		return nil  if @track.empty?
		ssize = @track.first.ssize
		return @track.all?{ |t| t.ssize == ssize } ? ssize : :mix
	end

	# 全セクタ数
	def total_sectors
		return @track.sum{ |t| t.nsectors }
	end

	# 総データサイズ
	def total_size
		return @track.sum{ |t| t.total_size }
	end

	# 全データをCHRN順に連結したもの
	def whole_data
	end

	# (内部用)@track内のnil要素をは空のTrackで埋める
	def sweep_niltrack
		@track.map!{ |t| t || Track.new }
	end
	protected(:sweep_niltrack)

	# (内部用)ファイルサイズチェック
	def excess_data_check(expect, actual)
		excess_data_length = expect - actual
		if excess_data_length > 0
			$stdout.print("  末尾に不要なデータがあります(#{excess_data_length}バイト余剰)\n")
		elsif excess_data_length < 0
			$stdout.print("  読み込み中に末尾に達しました(#{-excess_data_length}バイト不足)\n")
		end
	end
	protected(:excess_data_check)

	# 情報を表示
	def report_all
		if empty?
			$stdout.print("  データがありません(初期状態)\n")
			return
		end

		if @comment && !@comment.empty?
			$stdout.print("  コメント: #{@comment.inspect}\n")
		end

		if @mediatype
			$stdout.print("  メディア種別: #{mediatype_s}\n")
		end

		if !@writeprotect.nil?
			if @writeprotect
				$stdout.print("  ライトプロテクト: 書き込み禁止\n")
			else
				$stdout.print("  ライトプロテクト: 書き込み可\n")
			end
		end

		# セクタ情報の統計を算出
		nsecs_count = {}
		ssize_count = {}
		mfm_count = {}
		ddam_count = 0
		status_count = {}
		st0_count = {}
		st1_count = {}
		st2_count = {}
		pda_count = {}
		@track.each.with_index do |trk, trkno|
			nsecs = trk.nsectors
			nsecs_count[nsecs] ||= 0
			nsecs_count[nsecs] += 1

			sector_count = []
			trk.sector.each.with_index do |s, sec|
				if s.c > 90
					$stdout.print("  トラック#{trkno+1}のセクタのCの値が異常です: #{s.c}\n")
				end

				if s.c != trkno / 2
					$stdout.print("  トラック#{trkno+1}のセクタのCの値が特殊です: C:#{s.c} (!=#{trkno / 2})\n")
				end

				if s.h > 1
					$stdout.print("  トラック#{trkno+1}のセクタのHの値が異常です: #{s.h}\n")
				end

				if s.h != trkno % 2
					$stdout.print("  トラック#{trkno+1}のセクタのHの値が特殊です: H:#{s.h} (!=#{trkno % 2})\n")
				end

				if s.r < 1 || s.r > 32
					$stdout.print("  トラック#{trkno+1}のセクタのRの値が異常です: #{s.r}\n")
				end

				# インターリーブしてるディスクでは普通に異なるのでコメントアウト
				# if s.r != sec + 1
				# 	$stdout.print("  トラック#{trkno+1}のセクタのRの値が特殊です: R:#{s.r} (!=#{sec+1})\n")
				# end

				if s.n > 6
					$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
				end

				ssize_n = 128 << s.n.clamp(..6)
				ssize = s.ssize
				if ssize_n != ssize
					$stdout.print("  トラック#{trkno+1}のセクタのNの値と実際のサイズが異なります: N:#{ssize_n} != #{ssize}\n")
				end

				sector_count[s.r] ||= 0
				sector_count[s.r] += 1

				ssize_count[ssize] ||= 0
				ssize_count[ssize] += 1

				if !s.mfm.nil?
					mfm_count[s.mfm] ||= 0
					mfm_count[s.mfm] += 1
				end

				if s.ddam == true # DDAMはtrueの数を数えるだけ
					ddam_count += 1
				end

				if s.status && s.status != 0
					status_count[s.status] ||= 0
					status_count[s.status] += 1
				end

				if s.st0
					st0 = s.st0 & 0xf8 # Head Address, Unit Select は無視
					if st0 != 0
						st0_count[st0] ||= 0
						st0_count[st0] += 1
					end
				end

				if s.st1 && s.st1 != 0
					st1_count[s.st1] ||= 0
					st1_count[s.st1] += 1
				end

				if s.st2 && s.st2 != 0
					st2_count[s.st2] ||= 0
					st2_count[s.st2] += 1
				end

				if s.pda
					pda_count[s.pda] ||= 0
					pda_count[s.pda] += 1
				end
			end

			# セクタ番号のヌケ・重複のチェック
			sector_count.each.with_index do |count, sec|
				count ||= 0
				if sec == 0
					if count > 0
						$stdout.print("  トラック#{trkno+1}にR=#{sec}のセクタが#{count}個あります\n")
					end
				else
					if count < 1
						$stdout.print("  トラック#{trkno+1}にR=#{sec}のセクタがありません\n")
					elsif count > 1
						$stdout.print("  トラック#{trkno+1}にR=#{sec}のセクタが#{count}個あります\n")
					end
				end
			end
		end

		# 出現頻度順の配列にする
		nsecs_major = nsecs_count.to_a.sort_by{ |e| e[1] }.reverse
		ssize_major = ssize_count.to_a.sort_by{ |e| e[1] }.reverse
		mfm_major = mfm_count.to_a.sort_by{ |e| e[1] }.reverse
		status_major = status_count.to_a.sort_by{ |e| e[1] }.reverse
		st0_major = st0_count.to_a.sort_by{ |e| e[1] }.reverse
		st1_major = st1_count.to_a.sort_by{ |e| e[1] }.reverse
		st2_major = st2_count.to_a.sort_by{ |e| e[1] }.reverse
		pda_major = pda_count.to_a.sort_by{ |e| e[1] }.reverse

		# ジオメトリ算出
		wk_ssize2 = wk_ssize = ssize
		if wk_ssize
			if wk_ssize == :mix
				wk_ssize2 = ssize_major[0][0]
				ssize_s = "#{wk_ssize2}バイト(混在あり)"
			else
				ssize_s = "#{wk_ssize}バイト"
			end
		else
			ssize_s = "0バイト"
		end

		wk_nsectors2 = wk_nsectors = nsectors
		if wk_nsectors
			if wk_nsectors == :mix
				wk_nsectors2 = nsecs_major[0][0]
				nsecs_s = "#{wk_nsectors2}セクタ(混在あり)"
			else
				nsecs_s = "#{wk_nsectors}セクタ"
			end
		else
			nsecs_s = "セクタなし"
		end

		wk_ntracks = ntracks
		if(wk_ntracks == xtracks)
			ntracks_s = "#{wk_ntracks}トラック"
		else
			ntracks_s = "#{wk_ntracks}(#{xtracks})トラック"
		end

		wk_total_size = total_size
		if wk_total_size / 1024 >= 1000
			total_size_kb = "%.2fMB" % ((wk_total_size / 1024) / 1000.0)
		else
			total_size_kb = "%dKB" % (wk_total_size / 1024)
		end

		wk_cyls = cyls
		wk_heads = heads
		$stdout.print("  #{wk_cyls}シリンダ x #{wk_heads}ヘッド = #{ntracks_s}\n")
		$stdout.print("  #{wk_cyls}シリンダ x #{wk_heads}ヘッド x #{nsecs_s} = #{total_sectors}セクタ\n")
		$stdout.print("  #{wk_cyls}シリンダ x #{wk_heads}ヘッド x #{nsecs_s} x #{ssize_s} = #{wk_total_size}バイト(#{total_size_kb})\n")

		# 推定フォーマット
		guess_format = nil
		if !guess_format # 普通に全要素をチェック
			COMMON_GEOMETRIES.each.with_index do |g, i|
				g_desc, g_len, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = g
				wk_media = @mediatype || g_media
				if g_ssize1
					if wk_total_size == g_len && wk_media == g_media && wk_cyls == g_cyls && wk_heads == g_heads && wk_nsectors2 == g_nsecs && wk_ssize2 == g_ssize && track[0].ssize == g_ssize1
						guess_format = i
						break
					end
				else
					if wk_total_size == g_len && wk_media == g_media && wk_cyls == g_cyls && wk_heads == g_heads && wk_nsectors2 == g_nsecs && wk_ssize2 == g_ssize
						guess_format = i
						break
					end
				end
			end
		end
		if !guess_format # 総データサイズとシリンダ数を曖昧検索
			COMMON_GEOMETRIES.each.with_index do |g, i|
				g_desc, g_len, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = g
				wk_media = @mediatype || g_media
				cyls_ok = ((wk_cyls <= 45 && g_cyls <= 45) || (wk_cyls > 45 && g_cyls > 45)) ? true : false
				if g_ssize1
					if wk_media == g_media && cyls_ok && wk_heads == g_heads && wk_nsectors2 == g_nsecs && wk_ssize2 == g_ssize && track[0].ssize == g_ssize1
						guess_format = i
						break
					end
				else
					if wk_media == g_media && cyls_ok && wk_heads == g_heads && wk_nsectors2 == g_nsecs && wk_ssize2 == g_ssize
						guess_format = i
						break
					end
				end
			end
		end

		if guess_format
			g_desc, g_len, g_media, g_cyls, g_heads, g_nsecs, g_ssize, g_ssize1 = COMMON_GEOMETRIES[guess_format]

			$stdout.print("  推定フォーマット: #{g_desc}\n")

			if @mediatype && @mediatype != g_media
				$stdout.print("  メディア種別と実際のフォーマットが異なります\n")
			end

			if wk_cyls != g_cyls
				$stdout.print("  シリンダ数が通常と異なります: 標準は#{g_cyls}(#{g_cyls * g_heads}トラック)\n")
			end
		else
			$stdout.print("  一般的でないフォーマットがされています\n")
		end

		if mfm_count.length >= 2
			$stdout.print("  FM/MFM混在: FM:#{mfm_count[false]}セクタ MFM:#{mfm_count[true]}セクタ\n")
		end

		if ddam_count > 0
			$stdout.print("  Deleted Data Address Markの立ったセクタが#{ddam_count}個あります\n")
		end

		if !status_major.empty?
			status_major_s = "#{status_major[0][0].to_hex}が#{status_major[0][1]}個"
			status_major_s += " 他"  if status_major.length >= 2
			$stdout.print("  FDC Statusが0でないセクタがあります(#{status_major_s})\n")
		end

		st0_major.each do |val, count|
			$stdout.print("  ST0が#{val.to_hex}のセクタが#{count}個あります\n")
		end

		st1_major.each do |val, count|
			$stdout.print("  ST1が#{val.to_hex}のセクタが#{count}個あります\n")
		end

		st2_major.each do |val, count|
			$stdout.print("  ST2が#{val.to_hex}のセクタが#{count}個あります\n")
		end

		pda_major.each do |val, count|
			mediatype_unmatch = false
			case val
			when 0x90
				val_s = "2HD 1.2MB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2hd"
			when 0x30
				val_s = "2HD 1.44MB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2hd"
			when 0x10
				val_s = "2DD 640KB"
				mediatype_unmatch = true  if @mediatype && @mediatype != :"2dd"
			else
				val_s = "不明"
			end
			if mediatype_unmatch
				$stdout.print("  PDAが#{val.to_hex}: #{val_s}(メディア種別と不整合)のセクタが#{count}個あります#{mediatype_unmatch_s}\n")
			end
		end

		trkno = 1
		uniform_map = @track.map do |t|
			(t.is_uniform?) ? t.sector.first.data[0] : false
		end
		uniform_map.chunk{ |d| d }.each do |cval, cdata|
			ctracks = cdata.length

			if cval
				if ctracks == 1
					$stdout.print("  トラック#{trkno}は全て#{cval.ord.to_hex}です\n")
				else
					$stdout.print("  トラック#{trkno}～#{trkno+ctracks-1}は全て#{cval.ord.to_hex}です\n")
				end
			end

			trkno += ctracks
		end
	end
end

# DIFC.X ヘッダ(256バイト)+べたデータ https://stdkmd.net/xeij/source/FDMedia.htm https://www.pc98.org/project/doc/dim.html
class DIM < DiskImage
	IMAGE_FORMATNAME = "X68000 DIFC.X形式"
	IMAGE_EXTNAMES = [".dim"]
	HEADER_SIZE = 0x100

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[171, 15] == "DIFC HEADER  \0\0" &&
			[0x00, 0x01, 0x02, 0x03, 0x09, 0x11].include?(filedata[0].to_byte)
	end

	def load(filedata)
		clear

		# DIFC.Xバージョン
		difc_version = filedata[0xfe].to_byte
		difc_version_s = "1.%02x" % difc_version
		$stdout.print("  DIFC.xバージョン: #{difc_version_s}\n")

		# メディアタイプ
		media_byte = filedata[0].to_byte
		case media_byte
		when 0x00 # 2HD 1.23MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		when 0x01 # 2HS 1.44MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x02 # 2HC 1.2MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 15, 512
		when 0x03 # 2HDE 1.44MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x09 # 2HQ 1.44MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 18, 512
		else
			$stdout.print("  メディアタイプ不明: #{media_byte.to_hex}\n")
			@mediatype = :unknown
			cyls, heads, nsecs, ssize = 0, 0, 0, 0
		end

		# ファイル作成時刻
		create_time = filedata[0xba, 8]
		if create_time != "\0" * 8
			create_time = create_time.unpack("CH2H2H2CH2H2H2").map{ |e| e.to_i }
			create_time[0] = "日月火水木金土"[create_time[0]]
			create_time[1] = 1980 + create_time[1]
			$stdout.print("  ファイル作成時刻: " +
				"#{create_time[1]}/#{"%02d" % create_time[2]}/#{"%02d" % create_time[3]}(#{create_time[0]}) " +
				"#{create_time[5]}:#{"%02d" % create_time[6]}:#{"%02d" % create_time[7]}(#{(create_time[4]==0) ? "12" : "24"}時間計)\n")
		end

		# コメント
		@comment = filedata[0xc2, 60].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		# オーバートラック
		header_ntracks = filedata[0xff].to_byte
		$stdout.print("  ヘッダのトラック数: #{header_ntracks}トラック\n")  if header_ntracks > 0

		# データ本体
		offset = HEADER_SIZE
		track_flag = filedata[1, 170].to_bytes
		track_flag.each.with_index do |flag, trkno|
			case flag
			when 0 # なし
				# NOP
			when 1 # あり
				cyl = trkno / heads
				head = trkno % heads

				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			else
				$stdout.print("  トラック#{trkno+1}のデータ有無フラグが不正: #{flag}\n")
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# T98Next R0 ヘッダ(68112バイト)+べたデータ https://www.pc98.org/project/doc/nfdr0.txt
class NFD_R0 < DiskImage
	IMAGE_FORMATNAME = "T98-Next NFD r0形式"
	IMAGE_EXTNAMES = [".nfd"]
	HEADER_SIZE = 0x10a10

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 15] == "T98FDDIMAGE.R0\0"
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		@writeprotect = (filedata[0x10 + 0x100 + 4].to_byte != 0) ? true : false
		byHead = filedata[0x10 + 0x100 + 5].to_byte
		$stdout.print("  ヘッダ部のヘッド数: #{byHead}\n")

		id_offset = 0x120
		data_offset = dwHeadSize
		(0 ... 163).each do |trkno|
			(0 ... 26).each do |sec|
				s = Sector.new
				s.c, s.h, s.r, s.n, s.mfm, s.ddam, s.status, s.st0, s.st1, s.st2, s.pda =
					filedata[id_offset, 11].unpack("C11")
				id_offset += 0x10

				next  if s.c == 0xff

				if s.n > 6
					$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
					next # 致命的なのでこのセクタはスキップ
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのflMFMの値が不正: #{s.mfm}\n")
					s.mfm = nil
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのflDDAMの値が不正: #{s.ddam}\n")
					s.ddam = nil
				end

				ssize = 128 << s.n
				s.data = filedata[data_offset, ssize] || ""
				data_offset += ssize

				trk = (@track[trkno] ||= Track.new)
				trk.sector << s
			end
		end
		excess_data_check(filedata.length, data_offset)
		sweep_niltrack

		if byHead != heads
			$stdout.print("  ヘッダ部のヘッド数と実際に使われているヘッド数が一致しません\n")
		end
	end

	def dump
		raise("Not implemented")
	end
end

# T98Next R1 ヘッダ(全体(960バイト)+セクタ+特殊読み込み)+データ https://www.pc98.org/project/doc/nfdr1.txt
class NFD_R1 < DiskImage
	IMAGE_FORMATNAME = "T98-Next NFD r1形式"
	IMAGE_EXTNAMES = [".nfd"]
	HEADER_SIZE = 0x3c0

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 15] == "T98FDDIMAGE.R1\0"
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		@writeprotect = (filedata[0x10 + 0x100 + 4].to_byte != 0) ? true : false
		byHead = filedata[0x10 + 0x100 + 5].to_byte
		dwTrackHead = filedata[0x10 + 0x100 + 0x10, 4 * 164].to_dwords
		dwAddInfo = filedata[0x10 + 0x100 + 0x10 + 4 * 164, 4].to_dword

		$stdout.print("  ヘッダ部のヘッド数: #{byHead}\n")
		$stdout.print("  追加情報ヘッダのアドレスが0以外です: #{dwAddInfo.to_hex}\n")  if dwAddInfo != 0

		data_offset = dwHeadSize
		sp_read_count = {}
		dwTrackHead.each.with_index do |track_offset, trkno|
			next  if track_offset == 0

			nsecs, wDiag = filedata[track_offset, 2 * 2].to_words
			track_offset += 0x10

			trk = (@track[trkno] ||= Track.new)
			(0 ... nsecs).each do |sec|
				s = Sector.new
				s.c, s.h, s.r, s.n, s.mfm, s.ddam, s.status, s.st0, s.st1, s.st2, byRetry, s.pda =
					filedata[track_offset, 12].unpack("C12")
				track_offset += 0x10

				if s.n > 6
					$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
					next # 致命的なのでこのセクタはスキップ
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのflMFMの値が不正: #{s.mfm}\n")
					s.mfm = nil
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのflDDAMの値が不正: #{s.ddam}\n")
					s.ddam = nil
				end

				ssize = 128 << s.n
				if byRetry == 0
					s.data = filedata[data_offset, ssize] || ""
					data_offset += ssize
				else
					$stdout.print("  トラック#{trkno+1}にリトライデータが存在します: 1+#{byRetry}回\n")
					s.data = []
					(0 .. byRetry).each do
						s.data << (filedata[data_offset, ssize] || "")
						data_offset += ssize
					end
				end

				trk.sector << s
			end

			# 特殊読み込みデータ
			(0 ... wDiag).each do
				d_cmd, d_c, d_h, d_r, d_n, d_byStatus, d_bySTS0, d_bySTS1, d_bySTS2, d_byRetry, d_dwDataLen, d_byPDA =
					filedata[track_offset, 15].unpack("C10VC")
				track_offset += 0x10
				data_offset += d_dwDataLen

				sp_read_count[d_cmd] ||= 0
				sp_read_count[d_cmd] += 1
			end
		end
		excess_data_check(filedata.length, data_offset)
		sweep_niltrack

		if byHead != heads
			$stdout.print("  ヘッダ部のヘッド数と実際に使われているヘッド数が一致しません\n")
		end

		sp_read_count = sp_read_count.to_a.sort_by{ |e| e[1] }.reverse
		sp_read_count.each do |cmd, count|
			case cmd
			when 0x0
				cmd_s = "Seek"
			when 0x1
				cmd_s = "Verify"
			when 0x2
				cmd_s = "Read Diagnostic"
			when 0x3
				cmd_s = "Initialize"
			when 0x4
				cmd_s = "Sense"
			when 0x5
				cmd_s = "Write Data"
			when 0x6
				cmd_s = "Read Data"
			when 0x7
				cmd_s = "Recalibrate"
			when 0x9
				cmd_s = "Write Deleted Data"
			when 0xa
				cmd_s = "Read ID"
			when 0xc
				cmd_s = "Read Deleted Data"
			when 0xd
				cmd_s = "Format Track"
			when 0xe
				cmd_s = "Set Operation Mode"
			else
				cmd_s = "不明なコマンド"
			end

			$stdout.print("  特殊読み込みデータが存在します: #{cmd_s}: #{count}個\n")
		end
	end

	def dump
		raise("Not implemented")
	end
end

# SL9821 フォーマットヘッダ(16バイト)+トラックヘッダ(32*80*2=5120バイト)+データ https://www.satotomi.com/pifdc/pifdc_slf.html
class SLF < DiskImage
	IMAGE_FORMATNAME = "SL9821形式"
	IMAGE_EXTNAMES = [".slf"]
	HEADER_SIZE = 16 + 32 * 80 * 2

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 4] == "FDIM" &&
			filedata[4, 4].to_dword == 0x10000 &&
			filedata[8, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		version, filesize, flag = filedata[4, 12].to_dwords
		$stdout.print("  SLFバージョン: #{version.to_hex}\n")

		if filesize != filedata.length
			$stdout.print("  ヘッダのファイルサイズと実際のサイズが異なります: #{filesize} (!=#{filedata.length})\n")
		end

		if flag != 0
			$stdout.print("  フラグが設定されています: #{flag.to_hex}\n")
		end

		cyls, heads = 80, 2
		(0 ... cyls * heads).each do |trkno|
			tdata_offset, tdata_size, unformat_size, data_type, nsecs, gap4a_size, sync_size, gap1_size =
				filedata[0x10 + 0x20 * trkno, 28].unpack("V3v2V3")

			case data_type
			when 0xffff # -1:未フォーマット
				# NOP
			when 0 # 物理フォーマットデータ
				$stdout.print("  物理フォーマットのトラックデータには対応していません: #{trkno+1}トラック\n")
			when 1, 2 # 1:FM/2:MFMフォーマットデータ
				sheader_offset = tdata_offset
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					sdata_offset, status, isync_size, gap2_size, dsync_size, gap3_size,
						id_crc, data_crc, idam_pattern, s.c, s.h, s.r, s.n, dataam_pattern =
						filedata[sheader_offset, 32].unpack("V2v6VC4V")
					sheader_offset += 0x20

					if s.n > 6
						$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
						next # 致命的なのでこのセクタはスキップ
					end

					sdata_offset = tdata_offset + sdata_offset
					ssize = 128 << s.n
					s.mfm = (data_type == 2) ? true : false
					s.data = filedata[sdata_offset, ssize] || ""
					trk.sector << s

					chrn_s = "[#{s.c}/#{s.h}/#{s.r}/#{s.n}]"
					if (status & 0x1) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: IDAMパターンエラー\n")
					end
					if (status & 0x2) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: ID CRCエラー\n")
					end
					if (status & 0x4) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: DATAAMパターンエラー\n")
					end
					if (status & 0x8) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: DATA CRCエラー\n")
					end
					if (status & 0x10) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: セクタ構造のエラー\n")
					end
					if (status & 0x100) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: Deletedセクタ\n")
					end
					if (status & 0x200) != 0
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: 入れ子セクタ\n")
					end
					if (status | 0x31f) != 0x31f # 上記以外のビットが立っていたら
						$stdout.print("  トラック#{trkno+1}のステータス #{chrn_s}: 不明な値(#{status.to_hex})\n")
					end
				end
			end
		end
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# Virtual98 ヘッダ+可変長データ https://www.pc98.org/project/doc/fdd.html
class V98FDD < DiskImage
	IMAGE_FORMATNAME = "Virtual98形式"
	IMAGE_EXTNAMES = [".fdd"]
	HEADER_SIZE = 0xc3fc

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 7] == "VFD1.00"
	end

	def load(filedata)
		clear

		@mediatype = :"2hd" # 違ったらあとでリセット
		@comment = filedata[0x8, 0x80].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		@writeprotect = (filedata[0x88, 2].to_word != 0) ? true : false
		special_read_drive = filedata[0x8a, 2].to_word

		cyls, heads = 80, 2
		offset = 0xdc
		(0 ... cyls * heads).each do |trkno|
			(0 ... 26).each do
				s = Sector.new
				s.c, s.h, s.r, s.n, fill_byte, s.ddam, s.mfm, hd, sector_offset =
					filedata[offset, 12].unpack("C4aC3V")
				offset += 12

				next  if s.c == 0xff

				if s.n > 6
					$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
					next # 致命的なのでこのセクタはスキップ
				end

				case s.ddam
				when 0
					s.ddam = false
				when 1
					s.ddam = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのDDAMの値が不正: #{s.ddam}\n")
					s.ddam = nil
				end

				case s.mfm
				when 0
					s.mfm = false
				when 1
					s.mfm = true
				else
					$stdout.print("  トラック#{trkno+1}のセクタのMFの値が不正: #{s.mfm}\n")
					s.mfm = nil
				end

				if hd != 1
					$stdout.print("  トラック#{trkno+1}に2HDフラグが1でないセクタがあります: #{hd}\n")
					@mediatype = nil
				end

				ssize = 128 << s.n
				s.data = (sector_offset == 0xffffffff) ? fill_byte * ssize : filedata[sector_offset, ssize]

				trk = (@track[trkno] ||= Track.new)
				trk.sector << s
			end
		end
		sweep_niltrack

		if special_read_drive != 0xffff
			$stdout.print("  特殊読み込みドライブ設定があります: #{special_read_drive.to_hex}\n")

			next_point = special_read_drive # 0xc3dc
			begin
				trkno, in_ax, in_bx, in_cx, in_dx, out_ax, out_bx, out_cx, out_dx, out_flag, data_point, next_point, count, neg_count =
					filedata[next_point, 32].unpack("v10V2v2")
			end while(next_point != 0xffffffff && next_point != 0)
		end
	end

	def dump
		raise("Not implemented")
	end
end

# ERCVFD ヘッダ(64バイト)+セクタ毎に(ヘッダ(10バイト)+データ)
class ERCVFD < DiskImage
	IMAGE_FORMATNAME = "ERCACHE ERCVFD形式"
	IMAGE_EXTNAMES = [".vfd"]
	HEADER_SIZE = 0x40

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 8] == "ERCVFD01"
	end

	def load(filedata)
		$stdout.print("  ERCVFD.load not implemented\n")
	end

	def dump
		raise("Not implemented")
	end
end

# DIP ヘッダ(256バイト)+べたデータ https://www.pc98.org/project/doc/dip.html
class DIP < DiskImage
	IMAGE_FORMATNAME = "DIP形式"
	IMAGE_EXTNAMES = [".dip"]
	HEADER_SIZE = 256

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 8] == "\x01\x08\x00\x13\x41\x00\x01\x00" &&
			filedata.length == HEADER_SIZE + (77 * 2 * 8 * 1024)
	end

	def load(filedata)
		clear

		@comment = filedata[0x10, 0xf0].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		offset = HEADER_SIZE
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# D88 ディスクヘッダ+セクタ毎に(ヘッダ+データ) https://www.pc98.org/project/doc/d88.html https://github.com/waitingmoon/quasi88/blob/develop/document/FORMAT.TXT
class D88 < DiskImage
	IMAGE_FORMATNAME = "D88形式"
	IMAGE_EXTNAMES = [".d88", ".d98", ".88d", ".98d"]
	HEADER_SIZE = 0x2a0 # or 0x2b0

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0x10, 10] == "\0" * 10 &&
			[0x00, 0x10, 0x20, 0x21, 0x30, 0x40].include?(filedata[0x1b].to_byte) &&
			filedata.length == filedata[0x1c, 4].to_dword
	end

	def load(filedata)
		clear

		# Media flag
		media_flag = filedata[0x1b].to_byte
		case media_flag
		when 0x00 # 2D
			@mediatype = :"2d"
		when 0x10 # 2DD
			@mediatype = :"2dd"
		when 0x20 # 2HD
			@mediatype = :"2hd"
		when 0x21 # 2HD 1.44MB NP2kai
			$stdout.print("  ヘッダのメディアタイプ: 2HD 1.44MB NP2kai拡張\n")
			@mediatype = :"2hd"
		when 0x30 # 1D
			@mediatype = :"1d"
		when 0x40 # 1DD
			@mediatype = :"1dd"
		else
			$stdout.print("  ヘッダのメディアタイプ不明: #{media_flag.to_hex}\n")
			@mediatype = :unknown
		end

		# Write protect flag
		@writeprotect = (filedata[0x1a].to_byte == 0) ? false : true

		# Disk name / comment
		@comment = filedata[0, 16].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		# Track data
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find{ |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4 # 0x2b0(688byte:164entry) or 0x2a0(672byte:160entry)
		track_offsets = track_offsets.first(header_tracks)

		rpm_count = [0, 0]
		track_offsets.each.with_index do |offset, trkno|
			if offset != 0
				trk = (@track[trkno] ||= Track.new)
				track_nsectors = nil
				begin
					s = Sector.new
					s.c, s.h, s.r, s.n, nsecs, s.mfm, s.ddam, s.status, rpm, datasize =
						filedata[offset, 16].unpack("C4vC3x4Cv")
					offset += 0x10

					if s.n > 6
						$stdout.print("  トラック#{trkno+1}のセクタのNの値が異常です: #{s.n}\n")
						break # 致命的なのでこのトラックはスキップ
					end

					if !track_nsectors
						track_nsectors = nsecs
					elsif track_nsectors != nsecs
						$stdout.print("  トラック#{trkno+1}の総セクタ数が統一されていません: #{nsecs} (!=#{track_nsectors})\n")
					end

					case s.mfm
					when 0x00 # double density
						s.mfm = true
					when 0x40 # single density
						s.mfm = false
					else
						$stdout.print("  トラック#{trkno+1}のDensity flag不正: #{s.mfm.to_hex}\n")
						s.mfm = nil
					end

					case s.ddam
					when 0x00 # normal
						s.ddam = false
					when 0x10 #deleted
						s.ddam = true
					else
						$stdout.print("  トラック#{trkno+1}のDDAM flag不正: #{s.ddam.to_hex}\n")
						s.ddam = nil
					end

					if rpm == 0 || rpm == 1
						rpm_count[rpm] += 1
					else
						$stdout.print("  トラック#{trkno+1}のNP2kai RPM不正: #{rpm}\n")
					end

					ssize = 128 << s.n
					if ssize != datasize
						$stdout.print("  トラック#{trkno+1}のセクタのNの値とデータサイズが異なります: N:#{datasize} (!=#{ssize})\n")
					end

					s.data = filedata[offset, ssize] || ""
					offset += ssize

					trk.sector << s
				end while trk.nsectors < nsecs

				next_track_start = (track_offsets[(trkno + 1) .. -1].find{ |o| o != 0 }) || filedata.length
				if offset != next_track_start
					if offset < next_track_start
						$stdout.print("  トラック#{trkno+1}のデータの後に不要なデータがあります\n")
					else
						$stdout.print("  トラック#{trkno+1}のデータが次のトラックに達しています\n")
					end
				end
			end
		end
		sweep_niltrack

		if media_flag == 0x21
			if rpm_count[0] > 0
				$stdout.print("  ディスクヘッダ上は2HD 1.44MBですが、#{rpm_count[0]}個のセクタのRPMが0です\n")
			end
		else
			if rpm_count[1] > 0
				$stdout.print("  #{rpm_count[1]}個のセクタのRPMが1です\n")
			end
		end
	end

	def dump
		raise("Not implemented")
	end
end

# Anex86 ヘッダ(通常4096バイト)+べたデータ https://www.pc98.org/project/doc/hdi.html
class FDI < DiskImage
	IMAGE_FORMATNAME = "Anex86形式"
	IMAGE_EXTNAMES = [".fdi"]
	HEADER_SIZE = 0x20 # コメント除く最小サイズ

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		return filedata[0, 4].to_dword == 0 &&
			[0x90, 0x30, 0x10].include?(filedata[4, 4].to_dword) &&
			filedata[0x8, 4].to_dword + filedata[0xc, 4].to_dword == filedata.length
	end

	def load(filedata)
		clear

		fddtype_id = filedata[4, 4].to_dword
		case fddtype_id
		when 0x90 # 2HD 1.2MB
			@mediatype = :"2hd"
		when 0x30 # 2HD 1.44MB
			@mediatype = :"2hd"
		when 0x10 # 2DD 640KB or 720KB
			@mediatype = :"2dd"
		else
			$stdout.print("  メディアタイプ不明: #{fddtype_id.to_hex}\n")
			@mediatype = :unknown
		end

		headersize = filedata[0x8, 4].to_dword
		datasize = filedata[0xc, 4].to_dword
		ssize, nsecs, heads, cyls = filedata[0x10, 4 * 4].to_dwords
		$stdout.print("  ヘッダ情報: #{cyls}シリンダ x #{heads}ヘッド x #{nsecs}セクタ x #{ssize}バイト\n")

		@comment = filedata[0x20, headersize - 0x20].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")

		calc_datasize = cyls * heads * nsecs * ssize
		if calc_datasize != datasize
			$stdout.print("  ヘッダ情報のデータサイズとヘッダのCHRNから算出したサイズが一致しません: #{datasize} (!=#{calc_datasize})\n")
		end

		if headersize + datasize != filedata.length
			$stdout.print("  ヘッダ情報のデータサイズと実際のファイルサイズが一致しません: #{headersize + datasize} (!=#{filedata.length})\n")
		end

		offset = headersize
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# DCP/DCU ヘッダ(162バイト)+べたデータ https://www.pc98.org/project/doc/dcp.html https://melog.info/archives/2004/09/30/94#comment-27
class DCU < DiskImage
	IMAGE_FORMATNAME = "DCP/DCU形式"
	IMAGE_EXTNAMES = [".dcu", ".dcp"]
	HEADER_SIZE = 1 + 160 + 1

	def self.image?(filedata)
		return false  if filedata.length < HEADER_SIZE

		track_map = filedata[1, 160].to_bytes
		track_map.each do |t|
			if t != 0 && t != 1
				return false
			end
		end

		media_type = filedata[0].to_byte
		case [media_type, filedata.length]
		when [0x01, HEADER_SIZE + (77 * 2 * 8 * 1024)] # 2HD 1.25MB 2HS
			return true
		when [0x02, HEADER_SIZE + (80 * 2 * 15 * 512)] # 2HD 1.21MB 2HC
			return true
		when [0x03, HEADER_SIZE + (80 * 2 * 18 * 512)] # 2HQ 1.44MB 2HDE
			return true
		when [0x04, HEADER_SIZE + (80 * 2 * 8 * 512)] # 2DD 640KB
			return true
		when [0x05, HEADER_SIZE + (80 * 2 * 9 * 512)] # 2DD 720KB
			return true
		when [0x08, HEADER_SIZE + (80 * 2 * 9 * 1024)] # 2HD 1.44MB
			return true
		when [0x11, HEADER_SIZE + (1*26*128 + 153*26*256)] # 2HD Disk BASIC
			return true
		when [0x19, HEADER_SIZE + (80 * 2 * 16 * 256)] # 2DD Disk BASIC
			return true
		when [0x21, HEADER_SIZE + (80 * 2 * 26 * 256)] # 2HD 26sector
			return true
		end

		return false
	end

	def load(filedata)
		clear

		media_type = filedata[0].to_byte
		case media_type
		when 0x01 # 2HD 1.25MB 2HS
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 77, 2, 8, 1024
		when 0x02 # 2HD 1.21MB 2HC
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 15, 512
		when 0x03 # 2HQ 1.44MB 2HDE
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 18, 512
		when 0x04 # 2DD 640KB
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 8, 512
		when 0x05 # 2DD 720KB
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 512
		when 0x08 # 2HD 1.44MB
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 9, 1024
		when 0x11 # 2HD Disk BASIC
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize, ssize1 = 77, 2, 26, 256, 128
		when 0x19 # 2DD Disk BASIC
			@mediatype = :"2dd"
			cyls, heads, nsecs, ssize = 80, 2, 16, 256
		when 0x21 # 2HD 26sector
			@mediatype = :"2hd"
			cyls, heads, nsecs, ssize = 80, 2, 26, 256
		else
			$stdout.print("  メディアタイプ不明: #{media_type.to_hex}\n")
			@mediatype = :unknown
			cyls, heads, nsecs, ssize = 0, 0, 0, 0
		end

		# トラック保存状態
		track_flag = filedata[1, 160].to_bytes
		track_flag.each.with_index do |flag, trkno|
			if flag == 0 || flag == 1
				# OK:NOP
			else
				$stdout.print("  トラック#{trkno+1}のデータ有無フラグが不正: #{flag}\n")
			end
		end

		# 全トラック格納フラグ
		all_cylinders_stored = filedata[0xa1].to_byte
		case all_cylinders_stored
		when 0
			# OK:NOP
		when 1
			$stdout.print("  全トラック格納フラグ: ON\n")
			(0 ... cyls * heads).each do |trkno|
				track_flag[trkno] = 1
			end
		else
			$stdout.print("  全トラック格納フラグ不正: #{all_cylinders_stored}\n")
		end

		# データ本体
		offset = HEADER_SIZE
		track_flag.each.with_index do |flag, trkno|
			case flag
			when 0 # なし
				# NOP
			when 1 # あり
				cyl = trkno / heads
				head = trkno % heads

				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

# XDF べたデータ
class XDF < DiskImage
	IMAGE_FORMATNAME = "べたイメージ"
	IMAGE_EXTNAMES = [".xdf", ".dup", ".hdm", ".tfd", ".dsk", ".2hd", ".2dd", ".2d", ".1d"]
	HEADER_SIZE = 0

	def self.image?(filedata)
		return COMMON_GEOMETRIES.find{ |g| g[1] == filedata.length } ? true : false
	end

	def load(filedata)
		clear

		geom = COMMON_GEOMETRIES.find{ |g| g[1] == filedata.length }
		cyls, heads, nsecs, ssize = geom[3 .. 6]

		offset = 0
		(0 ... cyls).each do |cyl|
			(0 ... heads).each do |head|
				trkno = cyl * heads + head
				trk = (@track[trkno] ||= Track.new)
				(1 .. nsecs).each do |sec|
					s = Sector.new
					s.c = cyl # シリンダは0オリジン
					s.h = head # ヘッドは0オリジン
					s.r = sec # レコードは1オリジン
					s.n = (ssize / 128).bit_length - 1
					s.data = filedata[offset, ssize] || ""
					offset += ssize
					trk.sector << s
				end
			end
		end
		excess_data_check(filedata.length, offset)
		sweep_niltrack
	end

	def dump
		raise("Not implemented")
	end
end

def fdimageid(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze

	image_class = DiskImage.guess_image_format(data:filedata)
	if image_class
		$stdout.print("  💾 #{image_class.image_formatname} #{image_class.image_extnames_s}\n")
		image = image_class.new(data:filedata)
		image.report_all
	else
		$stdout.print("  ❓ 形式不明(#{filedata.length}バイト)\n")
	end
end

# .dim → .xdf 変換
def strip_dim(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze
	outfilename = filename + ".xdf"

	if !DIM.image?(filedata)
		$stderr.print("#{ProgName}: DIFC.X形式ではありません: #{filename}\n")
		return
	end

	case filedata.length
	when 256 + 77 * 2 * 8 * 1024 # 1261824
		data = filedata[256, 77 * 2 * 8 * 1024]

		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, data)
	when 256 + 80 * 2 * 8 * 1024 # 1310976
		data = filedata[256, 77 * 2 * 8 * 1024]
		data2 = filedata[256 + 77 * 2 * 8 * 1024, (80 - 77) * 2 * 8 * 1024]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: オーバートラックデータがあります: #{filename}\n")
			return
		end

		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, data)
	when 256 + 85 * 2 * 8 * 1024 # 1392896
		data = filedata[256, 77 * 2 * 8 * 1024]
		data2 = filedata[256 + 77 * 2 * 8 * 1024, (85 - 77) * 2 * 8 * 1024]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: オーバートラックデータがあります: #{filename}\n")
			return
		end

		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, data)
	else
		$stdout.print("  形式不明(#{filedata.length}バイト)\n")
	end
end

# 9セクタ2DD 720KBのイメージの各トラックの9セクタ目を切り捨てて8セクタ2DD 640KBのイメージにする
def truncate_9(filename)
	$stdout.print("#{filename}:\n")
	filedata = read_file(filename).freeze

	if filedata.length == 80 * 2 * 9 * 512
		outdata = ""
		(0 ... 80 * 2).each do |track|
			outdata += filedata[track * 9 * 512, 8 * 512]
		end

		outfilename = filename + ".xdf"
		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, outdata)
	elsif D88.image?(filedata) && filedata[0x1b].to_byte == 0x10
		track_offsets = filedata[0x20, 4 * 164].to_dwords
		header_size = track_offsets.find{ |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4
		track_offsets = track_offsets.first(header_tracks)

		outdata = filedata[0, header_size]
		(0 ... header_tracks).each do |track|
			track_offset = track_offsets[track]
			if track_offset != 0
				outdata[0x20 + 4 * track, 4] = [outdata.length].pack("V")

				(0 ... 8).each do |r|
					data = filedata[track_offset + 0x210 * r, 0x210]
					fail if data[4, 2].to_word != 9
					data[4, 2] = [8].pack("v")
					outdata += data
				end
			end
		end

		outdata[0x1c, 4] = [outdata.length].pack("V") # Disk size

		outfilename = filename + ".d88"
		$stdout.print("  → #{outfilename}:\n")
		write_file(outfilename, outdata)
	else
		$stdout.print("  形式不明(#{filedata.length}バイト)\n")
	end
end

def main(args)
	action = :identify

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] file..."

		opt.on("--strip-dim",
		".dim → .xdf 変換") do
			action = :strip_dim
		end

		opt.on("--truncate_9",
		"9セクタ目を切り捨て") do
			action = :truncate_9
		end

		opt.parse!
		print(opt.help)  if args.empty?
	end

	args.each do |an_arg|
		if !File.exist?(an_arg)
			$stderr.print("#{ProgName}: File not found: #{an_arg}\n")
			break
		end

		case action
		when :identify
			fdimageid(an_arg)
		when :strip_dim
			strip_dim(an_arg)
		when :truncate_9
			truncate_9(an_arg)
		end
	end

	return 0
end

exit main(ARGV)
