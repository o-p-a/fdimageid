#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# ãƒ•ãƒ­ãƒƒãƒ”ãƒ¼ãƒ‡ã‚£ã‚¹ã‚¯ã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®è­˜åˆ¥
#
# 2024/09/14 opaâ ğŸ™‚
#----------------------------------------------------------------

require "optparse"
require "pp"

ProgName = "fdimageid"
Version = "0.01"
#=====dpk===== Copyright2024
Copyright = "Copyright (c) 2024 by opa"
#=====dpk=====

class String
	def to_byte
		return unpack("C")[0]
	end

	def to_word
		return unpack("v")[0]
	end

	def to_dword
		return unpack("V")[0]
	end
end

def read_file(filename, offset=0, length=nil)
	return IO.binread(filename, length, offset)
end

def write_file(filename, data)
	return IO.binwrite(filename, data)
end

def filetype_is_dcu?(filedata)
	filesize = filedata.length
	media_type = filedata[0].to_byte
	track_map = filedata[1, 160].unpack("C*")

	track_map_ok = true
	track_map.each do |t|
		if t != 0 && t != 1
			track_map_ok = false
			break
		end
	end
	return false  if !track_map_ok

	if media_type == 0x01 && filesize == 162 + 1261568
		return true
	elsif media_type == 0x02 && filesize == 162 + 1228800
		return true
	elsif media_type == 0x03 && filesize == 162 + 1474560
		return true
	elsif media_type == 0x04 && filesize == 162 + 655360
		return true
	elsif media_type == 0x05 && filesize == 162 + 737280
		return true
	elsif media_type == 0x08 && filesize == 162 + 1474560
		return true
	elsif media_type == 0x11 && filesize == 162 + 128*26 + 256*26*153
		return true
	elsif media_type == 0x19 && filesize == 162 + 655360
		return true
	elsif media_type == 0x21 && filesize == 162 + 1064960
		return true
	end

	return false
end

def filetype_is_dim?(filedata)
	return filedata[171, 15] == "DIFC HEADER  \0\0"
end

def filetype_is_d88?(filedata)
	return filedata[0x10, 10] == "\0" * 10 &&
		[0x00, 0x10, 0x20, 0x21, 0x30, 0x40].include?(filedata[0x1b].to_byte) &&
		filedata.length == filedata[0x1c, 4].to_dword
end

def same_data_msg(from_track, to_track, value)
	if from_track == to_track
		$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{from_track}ã¯å…¨ã¦#{value.ord.to_s(16)}hã§ã™\n")
	else
		$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{from_track}ï½#{to_track}ã¯å…¨ã¦#{value.ord.to_s(16)}hã§ã™\n")
	end
end

# ãƒˆãƒ©ãƒƒã‚¯ã®ãƒ‡ãƒ¼ã‚¿ã®çŠ¶æ³
def track_report(filedata, sector_byte = 1024, nsectors = 8, ntracks = 2 * 77)
	track_length = sector_byte * nsectors
	$stdout.print("  #{sector_byte}ãƒã‚¤ãƒˆ Ã— #{nsectors}ã‚»ã‚¯ã‚¿ Ã— #{ntracks}ãƒˆãƒ©ãƒƒã‚¯\n")

	filled_data_value = nil
	filled_data_from = nil
	(0 ... ntracks).each do |track|
		track_data = filedata[track * track_length, track_length]
		if track_data == track_data[0] * track_data.length
			if track_data[0] == filled_data_value
				# NOP (åŒãƒ‡ãƒ¼ã‚¿ãŒç¶™ç¶š)
			else
				if filled_data_value
					same_data_msg(filled_data_from + 1, track, filled_data_value)
				end
				filled_data_value = track_data[0]
				filled_data_from = track
			end
		elsif filled_data_value
			same_data_msg(filled_data_from + 1, track, filled_data_value)
			filled_data_value = nil
		end
	end
	if filled_data_value
		same_data_msg(filled_data_from + 1, ntracks, filled_data_value)
	end
end

def fdimageid(filename)
	filedata = read_file(filename)
	filesize = filedata.length

	case
	# Virtual98(.fdd) ãƒ˜ãƒƒãƒ€+å¯å¤‰é•·ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/fdd.html
	when filedata[0, 7] == "VFD1.00"
		$stdout.print("#{filename}:\n")
		$stdout.print("  Virtual98å½¢å¼ [.fdd]\n")

	# DIFC.X(.dim) ãƒ˜ãƒƒãƒ€(256ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://stdkmd.net/xeij/source/FDMedia.htm
	when filetype_is_dim?(filedata)
		$stdout.print("#{filename}:\n")

		# DIFC.X version
		difc_ver = filedata[0xfe].to_byte

		$stdout.print("  X68000 DIFC.Xå½¢å¼(v#{difc_ver}) [.dim]\n")

		# ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆç¨®åˆ¥
		format_flag = filedata[0].to_byte
		case format_flag
		when 0x00
			format_flag_s = "00h: 2HD(1.23MB)"
			ntracks_std = 154
			track_length = 1024 * 8
		when 0x01
			format_flag_s = "01h: 2HS(1.44MB)"
			ntracks_std = 160
			track_length = 1024 * 9
		when 0x02
			format_flag_s = "02h: 2HC(1.2MB)"
			ntracks_std = 160
			track_length = 512 * 15
		when 0x03
			format_flag_s = "03h: 2HDE(1.44MB)"
			ntracks_std = 160
			track_length = 1024 * 9
		when 0x09
			format_flag_s = "09h: 2HQ(1.44MB)"
			ntracks_std = 160
			track_length = 512 * 18
		else
			format_flag_s = "ä¸æ˜(#{format_flag.to_s(16)}h)"
			ntracks_std = 0
			track_length = 0
		end

		$stdout.print("  ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆç¨®åˆ¥: #{format_flag_s}\n")
		$stdout.print("  #{track_length}ãƒã‚¤ãƒˆ/ãƒˆãƒ©ãƒƒã‚¯\n")

		# ç·ãƒˆãƒ©ãƒƒã‚¯æ•° (0ã®å ´åˆã‚‚ã‚ã‚‹)
		ntracks = filedata[0xff].to_byte
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã®ãƒˆãƒ©ãƒƒã‚¯æ•°: #{ntracks}ãƒˆãƒ©ãƒƒã‚¯\n")  if ntracks > 0

		# ãƒˆãƒ©ãƒƒã‚¯ã®ä¿å­˜çŠ¶æ…‹
		xtracks = 0
		filled_data_value = nil
		filled_data_from = nil
		filedata[1, 170].unpack("C*").each.with_index(1) do |flag, track|
			case flag
			when 0 # ãªã—
				if filled_data_value
					same_data_msg(filled_data_from, track-1, filled_data_value)
					filled_data_value = nil
				end
			when 1 # ã‚ã‚Š
				track_data = filedata[256 + xtracks * track_length, track_length]
				xtracks += 1
				if track_data == track_data[0] * track_data.length
					if track_data[0] == filled_data_value
						# NOP (åŒãƒ‡ãƒ¼ã‚¿ãŒç¶™ç¶š)
					else
						if filled_data_value
							same_data_msg(filled_data_from, track-1, filled_data_value)
						end
						filled_data_value = track_data[0]
						filled_data_from = track
					end
				elsif filled_data_value
					same_data_msg(filled_data_from, track-1, filled_data_value)
					filled_data_value = nil
				end
			else
				$stderr.print("#{ProgName}: ãƒˆãƒ©ãƒƒã‚¯ä¿å­˜çŠ¶æ…‹ãŒä¸æ­£: #{flag}\n")
			end
		end
		if filled_data_value
			same_data_msg(filled_data_from, 170, filled_data_value)
		end

		if xtracks == ntracks_std
			$stdout.print("  #{xtracks}ãƒˆãƒ©ãƒƒã‚¯(æ¨™æº–)ã®ãƒ‡ãƒ¼ã‚¿ãŒæ ¼ç´ã•ã‚Œã¦ã„ã¾ã™\n")
		else
			$stdout.print("  #{xtracks}ãƒˆãƒ©ãƒƒã‚¯åˆ†ã®ãƒ‡ãƒ¼ã‚¿ãŒæ ¼ç´ã•ã‚Œã¦ã„ã¾ã™(æ¨™æº–ã¯#{ntracks_std})\n")
		end

		if filesize != 256 + xtracks * track_length
			$stdout.print("  ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒä¸æ­£(#{filesize}ãƒã‚¤ãƒˆ)\n")
		end

	# T98Next R0(.nfd) ãƒ˜ãƒƒãƒ€(68112ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/nfdr0.txt
	when filedata[0, 15] == "T98FDDIMAGE.R0\0"
		$stdout.print("#{filename}:\n")
		$stdout.print("  T98-Next NFD r0å½¢å¼ [.nfd]\n")

		szComment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		flProtect = filedata[0x10 + 0x100 + 4].to_byte

		$stdout.print("  ã‚³ãƒ¡ãƒ³ãƒˆ: #{szComment.inspect}\n")  if !szComment.empty?
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã‚µã‚¤ã‚º: #{dwHeadSize}ãƒã‚¤ãƒˆ\n")
		$stdout.print("  èª­ã¿å–ã‚Šå°‚ç”¨\n")  if flProtect != 0

		trackInfo = []
		(0 ... 163).each do |track|
			trackInfo[track] = { sectorInfo:[] }
			(0 ... 26).each do |sector|
				w = {}
				w[:c], w[:h], w[:r], w[:n], w[:flMFM], w[:flDDAM], w[:byStatus], w[:byST0], w[:byST1], w[:byST2], w[:byPDA] =
					filedata[0x10 + 0x100 + 0x10 + (track * 26 + sector) * 0x10, 11].unpack("C*")
				w[:byST0] &= 0xfb # Head Address ã¯ç„¡è¦–
				trackInfo[track][:sectorInfo] << w  if w[:c] != 0xff
			end
		end

		minval = {}
		maxval = {}
		minnsec = nil
		maxnsec = nil
		trackInfo.each do |ti|
			next  if ti[:sectorInfo].empty?

			ti[:sectorInfo].each do |si|
				[:c, :h, :r, :n, :flMFM, :flDDAM, :byStatus, :byST0, :byST1, :byST2, :byPDA].each do |member|
					minval[member] = si[member]  if !minval[member] || minval[member] > si[member]
					maxval[member] = si[member]  if !maxval[member] || maxval[member] < si[member]
				end
			end
			minnsec = ti[:sectorInfo].length  if !minnsec || minnsec > ti[:sectorInfo].length
			maxnsec = ti[:sectorInfo].length  if !maxnsec || maxnsec < ti[:sectorInfo].length
		end

		ntracks = trackInfo.count { |ti| !ti[:sectorInfo].empty? }
		ntracks_s = "#{ntracks}ãƒˆãƒ©ãƒƒã‚¯"

		sector_size = 128 << maxval[:n]
		if maxval[:n] == minval[:n]
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ"
		else
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ(æ··åœ¨ã‚ã‚Š)"
		end

		nsectors = maxnsec
		if maxnsec == minnsec
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿"
		else
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿(æ··åœ¨ã‚ã‚Š)"
		end

		byPDA = maxval[:byPDA]
		case byPDA
		when 0x90
			byPDA_s = "90h: 2HD(1.2MB)"
		when 0x30
			byPDA_s = "30h: 2HD(1.44MB)"
		when 0x10
			byPDA_s = "10h: 2DD(640KB)"
		else
			byPDA_s = "#{byPDA.to_s(16)}h"
		end
		if maxval[:byPDA] != minval[:byPDA]
			byPDA_s += "(æ··åœ¨)"
		end

		$stdout.print("  #{sector_size_s} Ã— #{nsectors_s} Ã— #{ntracks_s}\n")
		$stdout.print("  FM/MFMæ··åœ¨\n")  if maxval[:flMFM] != minval[:flMFM]
		$stdout.print("  Deleted Data Address Markã®ç«‹ã£ãŸã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:flDDAM] != 0
		$stdout.print("  BIOS ResultãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byStatus] != 0
		$stdout.print("  FDC Store Status 0ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byST0] != 0
		$stdout.print("  FDC Store Status 1ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byST1] != 0
		$stdout.print("  FDC Store Status 2ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byST2] != 0
		$stdout.print("  PDAãƒ‡ãƒã‚¤ã‚¹ã‚¢ãƒ‰ãƒ¬ã‚¹: #{byPDA_s}\n")

	# T98Next R1(.nfd) ãƒ˜ãƒƒãƒ€(å…¨ä½“+ã‚»ã‚¯ã‚¿+ç‰¹æ®Šèª­ã¿è¾¼ã¿)+ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/nfdr1.txt
	when filedata[0, 15] == "T98FDDIMAGE.R1\0"
		$stdout.print("#{filename}:\n")
		$stdout.print("  T98-Next NFD r1å½¢å¼ [.nfd]\n")

		szComment = filedata[0x10, 0x100].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		dwHeadSize = filedata[0x10 + 0x100, 4].to_dword
		flProtect = filedata[0x10 + 0x100 + 4].to_byte

		$stdout.print("  ã‚³ãƒ¡ãƒ³ãƒˆ: #{szComment.inspect}\n")  if !szComment.empty?
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã‚µã‚¤ã‚º: #{dwHeadSize}ãƒã‚¤ãƒˆ\n")
		$stdout.print("  èª­ã¿å–ã‚Šå°‚ç”¨\n")  if flProtect != 0

		trackInfo = []
		dwTrackHead = filedata[0x10 + 0x100 + 0x10, 4 * 164].unpack("V*")
		(0 ... dwTrackHead.length).each do |track|
			track_offset = dwTrackHead[track]
			next  if track_offset == 0

			wSector, wDiag = filedata[track_offset, 2 * 2].unpack("vv")
			trackInfo[track] = { sectorInfo:[], diagInfo:[] }

			(0 ... wSector).each do |sector|
				w = {}
				w[:c], w[:h], w[:r], w[:n], w[:flMFM], w[:flDDAM], w[:byStatus], w[:bySTS0], w[:bySTS1], w[:bySTS2], w[:byRetry], w[:byPDA] =
					filedata[track_offset + 0x10 + sector * 0x10, 12].unpack("C*")
				w[:bySTS0] &= 0xfb # Head Address ã¯ç„¡è¦–
				trackInfo[track][:sectorInfo] << w
			end

			(0 ... wDiag).each do |diag|
				w = {}
				w[:cmd], w[:c], w[:h], w[:r], w[:n], w[:byStatus], w[:bySTS0], w[:bySTS1], w[:bySTS2], w[:byRetry], w[:dwDataLen], w[:byPDA] =
					filedata[track_offset + 0x10 + wSector * 0x10 + diag * 0x10, 15].unpack("C10VC")
				trackInfo[track][:diagInfo] << w
			end
		end

		minval = {}
		maxval = {}
		minnsec = nil
		maxnsec = nil
		trackInfo.each do |ti|
			ti[:sectorInfo].each do |si|
				[:c, :h, :r, :n, :flMFM, :flDDAM, :byStatus, :bySTS0, :bySTS1, :bySTS2, :byRetry, :byPDA].each do |member|
					minval[member] = si[member]  if !minval[member] || minval[member] > si[member]
					maxval[member] = si[member]  if !maxval[member] || maxval[member] < si[member]
				end
			end
			minnsec = ti[:sectorInfo].length  if !minnsec || minnsec > ti[:sectorInfo].length
			maxnsec = ti[:sectorInfo].length  if !maxnsec || maxnsec < ti[:sectorInfo].length

			ti[:diagInfo].each do |di|
				$stdout.print("  ç‰¹æ®Šèª­ã¿è¾¼ã¿ã‚»ã‚¯ã‚¿: Cmd:#{di[:cmd]} C:#{di[:c]} H:#{di[:h]} R:#{di[:r]} N:#{di[:n]} STS:#{di[:bySTS0]},#{di[:bySTS1]},#{di[:bySTS2]} Status:#{di[:byStatus]} Retry:#{di[:byRetry]} DataLen:#{di[:dwDataLen]}\n")
			end
		end

		ntracks = trackInfo.length
		ntracks_s = "#{ntracks}ãƒˆãƒ©ãƒƒã‚¯"

		sector_size = 128 << maxval[:n]
		if maxval[:n] == minval[:n]
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ"
		else
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ(æ··åœ¨ã‚ã‚Š)"
		end

		nsectors = maxnsec
		if maxnsec == minnsec
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿"
		else
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿(æ··åœ¨ã‚ã‚Š)"
		end

		$stdout.print("  #{sector_size_s} Ã— #{nsectors_s} Ã— #{ntracks_s}\n")
		$stdout.print("  FM/MFMæ··åœ¨\n")  if maxval[:flMFM] != minval[:flMFM]
		$stdout.print("  Deleted Data Address Markã®ç«‹ã£ãŸã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:flDDAM] != 0
		$stdout.print("  BIOS ResultãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byStatus] != 0
		$stdout.print("  FDC Store Status 0ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:bySTS0] != 0
		$stdout.print("  FDC Store Status 1ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:bySTS1] != 0
		$stdout.print("  FDC Store Status 2ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:bySTS2] != 0
		$stdout.print("  ä¸å®‰å®šãƒ‡ãƒ¼ã‚¿ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byRetry] != 0
		$stdout.print("  PDAãƒ‡ãƒã‚¤ã‚¹ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:byPDA] != 0

	# D88(.d88) ãƒ‡ã‚£ã‚¹ã‚¯ãƒ˜ãƒƒãƒ€+ã‚»ã‚¯ã‚¿æ¯ã«(ãƒ˜ãƒƒãƒ€+ãƒ‡ãƒ¼ã‚¿) https://www.pc98.org/project/doc/d88.html
	when filetype_is_d88?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  D88å½¢å¼ [.d88 .d98 .88d .98d]\n")

		media_flag = filedata[0x1b].to_byte
		case media_flag
		when 0x00
			media_flag_s = "00h: 2D"
			ntracks_std = 80
		when 0x10
			media_flag_s = "10h: 2DD"
			ntracks_std = 160
		when 0x20
			media_flag_s = "20h: 2HD"
			ntracks_std = 154
		when 0x21
			media_flag_s = "21h: 2HD(1.44MB NP2kai)"
			ntracks_std = 160
		when 0x30
			media_flag_s = "30h: 1D"
			ntracks_std = 40
		when 0x40
			media_flag_s = "40h: 1DD"
			ntracks_std = 80
		else
			media_flag_s = "ä¸æ˜(#{media_flag.to_s(16)}h)"
			ntracks_std = 0
		end

		$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ç¨®åˆ¥: #{media_flag_s}\n")

		comment = filedata[0, 16].force_encoding("WINDOWS-31J").encode.sub(/\0+$/, "")
		write_protect = filedata[0x1a].to_byte

		$stdout.print("  ã‚³ãƒ¡ãƒ³ãƒˆ: #{comment.inspect}\n")  if !comment.empty?
		$stdout.print("  æ›¸ãè¾¼ã¿ç¦æ­¢(#{write_protect.to_s(16)}h)\n")  if write_protect != 0

		track_offsets = filedata[0x20, 4 * 164].unpack("V*")
		header_size = track_offsets.find { |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4
		track_offsets = track_offsets.first(header_tracks)

		ntracks = track_offsets.length - track_offsets.reverse.find_index { |to| to != 0 } # æœ€çµ‚ãƒˆãƒ©ãƒƒã‚¯ç•ªå·
		track_offsets = track_offsets.first(ntracks) # å…ˆé ­nãƒˆãƒ©ãƒƒã‚¯ã§åˆ‡ã‚Šè©°ã‚
		xtracks = track_offsets.count { |to| to != 0 } # ãƒ‡ãƒ¼ã‚¿ã®æœ‰ã‚‹ãƒˆãƒ©ãƒƒã‚¯æ•°
		if(ntracks == xtracks)
			ntracks_s = "#{ntracks}ãƒˆãƒ©ãƒƒã‚¯"
		else
			ntracks_s = "#{ntracks}(#{xtracks})ãƒˆãƒ©ãƒƒã‚¯"
		end

		if ntracks == ntracks_std
			ntracks_s += "(æ¨™æº–)"
		else
			ntracks_s += "(æ¨™æº–ã¯#{ntracks_std})"
		end

		trackInfo = []
		trackData = ""
		track_offsets.each.with_index do |track_offset, track|
			next  if track_offset == 0

			trackInfo[track] = { sectorInfo:[] }
			sector_offset = track_offset
			while true
				w = {}
				w[:c], w[:h], w[:r], w[:n], w[:nsectors], w[:density], w[:ddam], w[:status], w[:rpm], w[:datasize] =
					filedata[sector_offset, 16].unpack("C4vC3x4Cv")
				sector_offset += 0x10

				if w[:c] > 90 || w[:h] > 1 || w[:r] > 20 || w[:n] > 6
					$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®CHRNä¸æ­£: #{w[:c]} #{w[:h]} #{w[:r]} #{w[:n]}\n")
					break
				end

				trackInfo[track][:sectorInfo] << w

				nsize = 128 << w[:n]
				if nsize != w[:datasize]
					$stdout.print("  ã‚»ã‚¯ã‚¿ã®Nå€¤ã¨ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºãŒç•°ãªã‚Šã¾ã™: N:#{nsize} != #{w[:datasize]}\n")
				end
				trackData += filedata[sector_offset, nsize]
				sector_offset += nsize

				if trackInfo[track][:sectorInfo].length >= w[:nsectors]
					next_track_start = (track_offsets[(track + 1) .. -1].find { |o| o != 0 }) || filesize
					if sector_offset != next_track_start
						if sector_offset < next_track_start
							$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®ãƒ‡ãƒ¼ã‚¿ã®å¾Œã«ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™\n")
						else
							$stdout.print("  ãƒˆãƒ©ãƒƒã‚¯#{track+1}ã®ãƒ‡ãƒ¼ã‚¿ãŒæ¬¡ã®ãƒˆãƒ©ãƒƒã‚¯ã«é”ã—ã¦ã„ã¾ã™\n")
						end
					end
					break
				end
			end
		end

		minval = {}
		maxval = {}
		minnsec = nil
		maxnsec = nil
		trackInfo.each do |ti|
			next  if !ti

			ti[:sectorInfo].each do |si|
				[:c, :h, :r, :n, :nsectors, :density, :ddam, :status, :rpm].each do |member|
					minval[member] = si[member]  if !minval[member] || minval[member] > si[member]
					maxval[member] = si[member]  if !maxval[member] || maxval[member] < si[member]
				end
			end
			minnsec = ti[:sectorInfo].length  if !minnsec || minnsec > ti[:sectorInfo].length
			maxnsec = ti[:sectorInfo].length  if !maxnsec || maxnsec < ti[:sectorInfo].length
		end

		sector_size = 128 << maxval[:n]
		if maxval[:n] == minval[:n]
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ"
		else
			sector_size_s = "#{sector_size}ãƒã‚¤ãƒˆ(æ··åœ¨ã‚ã‚Š)"
		end

		nsectors = maxnsec
		if maxnsec == minnsec
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿"
		else
			nsectors_s = "#{nsectors}ã‚»ã‚¯ã‚¿(æ··åœ¨ã‚ã‚Š)"
		end

		$stdout.print("  #{sector_size_s} Ã— #{nsectors_s} Ã— #{ntracks_s}\n")
		$stdout.print("  FM/MFMæ··åœ¨\n")  if maxval[:density] != minval[:density]
		$stdout.print("  Deleted Data Address Markã®ç«‹ã£ãŸã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:ddam] != 0
		$stdout.print("  FDC StatusãŒ0ä»¥å¤–ã®ã‚»ã‚¯ã‚¿ãŒã‚ã‚Šã¾ã™\n")  if maxval[:status] != 0
		if maxval[:rpm] != 0
			if maxval[:rpm] == minval[:rpm]
				$stdout.print("  NP2kai RPM FlagãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã¾ã™\n")
			else
				$stdout.print("  NP2kai RPM FlagãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã¾ã™(æ··åœ¨)\n")
			end
		end

		# write_file(filename + ".xdf", trackData)

	# DCP/DCU(.dcu) ãƒ˜ãƒƒãƒ€(162ãƒã‚¤ãƒˆ)+ãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/dcp.html
	when filetype_is_dcu?(filedata)
		$stdout.print("#{filename}:\n")
		$stdout.print("  DCP/DCUå½¢å¼ [.dcu .dcp]\n")

		media_type = filedata[0].to_byte
		case media_type
		when 0x01
			media_type_s = "01h: 2HD(1.23MB)"
		when 0x02
			media_type_s = "02h: 2HD(1.2MB 2HC)"
		when 0x03
			media_type_s = "03h: 2HQ(1.44MB 2HDE)"
		when 0x04
			media_type_s = "04h: 2DD(640KB)"
		when 0x05
			media_type_s = "05h: 2DD(720KB)"
		when 0x08
			media_type_s = "08h: 2HD(1.44MB)"
		when 0x11
			media_type_s = "11h: 2HD(Disk BASIC)"
		when 0x19
			media_type_s = "19h: 2DD(Disk BASIC)"
		when 0x21
			media_type_s = "21h: 2HD(26sector)"
		else
			media_type_s = "ä¸æ˜(#{media_type.to_s(16)}h)"
		end

		$stdout.print("  ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—: #{media_type_s}\n")

		track_map = filedata[1, 160].unpack("C*")
		all_cylinders_stored = filedata[0xa1].to_byte

	# Anex86(.fdi) ãƒ˜ãƒƒãƒ€(4096ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/hdi.html
	when filedata[0, 4].to_dword == 0 &&
		[0x90, 0x30, 0x10].include?(filedata[4, 4].to_dword) &&
		filedata[0x8, 4].to_dword + filedata[0xc, 4].to_dword == filesize

		$stdout.print("#{filename}:\n")
		$stdout.print("  Anex86å½¢å¼ [.fdi]\n")

		fddtype_id = filedata[4, 4].to_dword
		case fddtype_id
		when 0x90
			fddtype_id_s = "90h: 2HD(1.2MB)"
		when 0x30
			fddtype_id_s = "30h: 2HD(1.44MB)"
		when 0x10
			fddtype_id_s = "10h: 2DD"
		else
			fddtype_id_s = "#{fddtype_id.to_s(16)}h"
		end

		headersize = filedata[0x8, 4].to_dword

		datasize = filedata[0xc, 4].to_dword
		case datasize
		when 1474560
			datasize_s = " 2HD(1.44MB)"
		when 1261568
			datasize_s = " 2HD(1.23MB)"
		when 1228800
			datasize_s = " 2HD(1.2MB)"
		when 737280
			datasize_s = " 2DD(720KB)"
		when 655360
			datasize_s = " 2DD(640KB)"
		else
			datasize_s = ""
		end

		$stdout.print("  FDD Type: #{fddtype_id_s}\n")
		$stdout.print("  ãƒ˜ãƒƒãƒ€ã‚µã‚¤ã‚º: #{headersize}ãƒã‚¤ãƒˆ\n")
		$stdout.print("  ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: #{datasize}ãƒã‚¤ãƒˆ#{datasize_s}\n")

	# DIP(.dip) ãƒ˜ãƒƒãƒ€(256ãƒã‚¤ãƒˆ)+ã¹ãŸãƒ‡ãƒ¼ã‚¿ https://www.pc98.org/project/doc/dip.html
	when filedata[0, 8] == "\x01\x08\x00\x13\x41\x00\x01\x00" &&
		filesize == 256 + 1261568

		$stdout.print("#{filename}:\n")
		$stdout.print("  DIPå½¢å¼ [.dip]\n")

	# SL9821(.slf) ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ˜ãƒƒãƒ€(16ãƒã‚¤ãƒˆ)+ãƒˆãƒ©ãƒƒã‚¯ãƒ˜ãƒƒãƒ€(80*2*32=5120ãƒã‚¤ãƒˆ)+ãƒ‡ãƒ¼ã‚¿ https://www.satotomi.com/pifdc/pifdc_slf.html
	when filedata[0, 4] == "FDIM" &&
		filedata[4, 4].to_dword == 0x10000 &&
		filedata[8, 4].to_dword == filesize

		$stdout.print("#{filename}:\n")
		$stdout.print("  SL9821å½¢å¼ [.slf]\n")

	# 1.44MB 2HD ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—18ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—80ã‚·ãƒªãƒ³ãƒ€ = 1474560ãƒã‚¤ãƒˆ)
	when filesize == 512 * 18 * 2 * 80
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.44MB PC/AT) [.2hd]\n")

		track_report(filedata, 512, 18, 2 * 80)

	# 1.23MB 2HD ã¹ãŸ (1024ãƒã‚¤ãƒˆÃ—8ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—77ã‚·ãƒªãƒ³ãƒ€ = 1261568ãƒã‚¤ãƒˆ)
	when filesize == 1024 * 8 * 2 * 77
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.23MB PC98) [.xdf .2hd .dup .hdm .tfd]\n")

		track_report(filedata, 1024, 8, 2 * 77)

	# 1.2MB 2HD ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—15ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—80ã‚·ãƒªãƒ³ãƒ€ = 1228800ãƒã‚¤ãƒˆ)
	when filesize == 512 * 15 * 2 * 80
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2HD(1.2MB PC/AT) [.2hd]\n")

		track_report(filedata, 512, 15, 2 * 80)

	# 720KB 2DD ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—9ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—80ã‚·ãƒªãƒ³ãƒ€ = 737280ãƒã‚¤ãƒˆ)
	when filesize == 512 * 9 * 2 * 80
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2DD(720KB MSX) [.dsk]\n")

		track_report(filedata, 512, 9, 2 * 80)

	# 640KB 2DD ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—8ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—80ã‚·ãƒªãƒ³ãƒ€ = 655360ãƒã‚¤ãƒˆ)
	when filesize == 512 * 8 * 2 * 80
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2DD(640KB) [.2dd]\n")

		track_report(filedata, 512, 8, 2 * 80)

	# 320KB 2D ã¹ãŸ (512ãƒã‚¤ãƒˆÃ—8ã‚»ã‚¯ã‚¿Ã—2ãƒ˜ãƒƒãƒ‰Ã—40ã‚·ãƒªãƒ³ãƒ€ = 327680ãƒã‚¤ãƒˆ)
	when filesize == 512 * 8 * 2 * 40
		$stdout.print("#{filename}:\n  ã¹ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ 2D(320KB) [.2d]\n")

		track_report(filedata, 512, 8, 2 * 40)

	else
		$stdout.print("#{filename}:\n  ä¸æ˜ãªå½¢å¼ (#{filesize}ãƒã‚¤ãƒˆ)\n")
	end
end

# .dim â†’ .xdf å¤‰æ›
def strip_dim(filename)
	if !filetype_is_dim?(filedata)
		$stderr.print("#{ProgName}: DIFC.Xå½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“: #{filename}\n")
		return
	end

	$stdout.print("#{filename}:\n")

	filedata = read_file(filename)
	filesize = filedata.length
	outfilename = filename + ".xdf"

	if filesize == 256 + 1024 * 8 * 2 * 77 # 1261824
		data = filedata[256, 1024 * 8 * 2 * 77]

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	elsif filesize == 256 + 1024 * 8 * 2 * 80 # 1310976
		data = filedata[256, 1024 * 8 * 2 * 77]
		data2 = filedata[256 + 1024 * 8 * 2 * 77, 1024 * 8 * 2 * (80 - 77)]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™: #{filename}\n")
			return
		end

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	elsif filesize == 256 + 1024 * 8 * 2 * 85 # 1392896
		data = filedata[256, 1024 * 8 * 2 * 77]
		data2 = filedata[256 + 1024 * 8 * 2 * 77, 1024 * 8 * 2 * (85 - 77)]
		if data2 != data2[0] * data2.length
			$stderr.print("#{ProgName}: ã‚ªãƒ¼ãƒãƒ¼ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™: #{filename}\n")
			return
		end

		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, data)
	else
		$stdout.print("  ä¸æ˜ãªå½¢å¼ (#{filesize}ãƒã‚¤ãƒˆ)\n")
	end
end

# 9ã‚»ã‚¯ã‚¿2DD(720KB)ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã®å„ãƒˆãƒ©ãƒƒã‚¯ã®9ã‚»ã‚¯ã‚¿ç›®ã‚’åˆ‡ã‚Šæ¨ã¦ã¦8ã‚»ã‚¯ã‚¿2DD(640KB)ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã«ã™ã‚‹
def truncate_9(filename)
	filedata = read_file(filename)
	filesize = filedata.length

	$stdout.print("#{filename}:\n")

	if filesize == 512 * 9 * 2 * 80
		outdata = ""
		(0 ... 2 * 80).each do |track|
			outdata += filedata[512 * 9 * track, 512 * 8]
		end

		outfilename = filename + ".xdf"
		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, outdata)
	elsif filetype_is_d88?(filedata) && filedata[0x1b].to_byte == 0x10
		track_offsets = filedata[0x20, 4 * 164].unpack("V*")
		header_size = track_offsets.find { |o| o != 0 }
		header_tracks = (header_size - 0x20) / 4
		track_offsets = track_offsets.first(header_tracks)

		outdata = filedata[0, header_size]
		(0 ... header_tracks).each do |track|
			track_offset = track_offsets[track]
			if track_offset != 0
				outdata[0x20 + 4 * track, 4] = [outdata.length].pack("V")

				(0 ... 8).each do |r|
					data = filedata[track_offset + 0x210 * r, 0x210]
					fail if data[4, 2].to_word != 9
					data[4, 2] = [8].pack("v")
					outdata += data
				end
			end
		end

		outdata[0x1c, 4] = [outdata.length].pack("V") # Disk size

		outfilename = filename + ".d88"
		$stdout.print("  â†’ #{outfilename}:\n")
		write_file(outfilename, outdata)
	else
		$stdout.print("  ä¸æ˜ãªå½¢å¼ (#{filesize}ãƒã‚¤ãƒˆ)\n")
	end
end

def main(args)
	action = :identify

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] file..."

		opt.on("--strip-dim",
		".dim â†’ .xdf å¤‰æ›") do
			action = :strip_dim
		end

		opt.on("--truncate_9",
		"9ã‚»ã‚¯ã‚¿ç›®ã‚’åˆ‡ã‚Šæ¨ã¦") do
			action = :truncate_9
		end

		opt.parse!
		print(opt.help)  if args.empty?
	end

	args.each do |an_arg|
		if !File.exist?(an_arg)
			$stderr.print("#{ProgName}: File not found: #{an_arg}\n")
			break
		end

		case action
		when :identify
			fdimageid(an_arg)
		when :strip_dim
			strip_dim(an_arg)
		when :truncate_9
			truncate_9(an_arg)
		end
	end

	return 0
end

exit main(ARGV)
